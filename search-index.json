[{"content":"A new protocol is now supported in WLDT through the introduction of CoAP Adapters! The CoAP Digital and Physical Adapters enable seamless integration between Digital Twins and CoAP-based applications or physical assets.\nFor more information, check out the documentation:\nCoAP Digital Adapter Documentation CoAP Physical Adapter Documentation These new adapters are supported starting from WLDT version 0.4.0.\nWe believe these new adapters will significantly enhance the capabilities of WLDT in IoT and resource-constrained environments. Stay tuned for more updates and features in future releases!\n","date":"January 8, 2026","id":0,"permalink":"/blog/coap-adapters-release/","summary":"A new protocol is now supported in WLDT through the introduction of CoAP Adapters! The CoAP Digital and Physical Adapters enable seamless integration between Digital Twins and CoAP-based applications or physical assets.","tags":"","title":"CoAP Adapters Release"},{"content":"We\u0026rsquo;re excited to announce the release of WLDT version 0.5.0! This update is focused on two main areas:\nA Management Interface associated with the concept of Managed Resources, enabling better control and monitoring of resources within the WLDT ecosystem. The introduction of a flexible and configurable logging layer, allowing developers to integrate their preferred logging frameworks or implement custom logging solutions. For detailed information about these changes and their impact, please refer to the information provided:\nOfficial Changelog Details about the new features:\nLogging Guide API Reference for Management Interface Stay tuned for more updates!\n","date":"January 8, 2026","id":1,"permalink":"/blog/wldt-library-version-0.5.0/","summary":"We\u0026rsquo;re excited to announce the release of WLDT version 0.5.0! This update is focused on two main areas:\nA Management Interface associated with the concept of Managed Resources, enabling better control and monitoring of resources within the WLDT ecosystem.","tags":"","title":"WLDT Library Version 0.5.0"},{"content":"We\u0026rsquo;re excited to announce the release of WLDT version 0.4.0! This update brings powerful new features to enhance your Digital Twin (DT) experience, including event observation capabilities, a robust storage layer, and a flexible query system.\nFor detailed information about these changes and their impact, please refer to the information provided:\nOfficial Changelog Official Documentation Key Highlights WldtEventObserver: A new class has been introduced, simplifying the observation of specific events generated by Digital Twins and their components Storage Layer: The new storage layer allows DTs to store data related to their state, events, actions, and more. It consists of: Storage Manager: Manage and use various storage systems (e.g., in-memory, file-based, DBMS) simultaneously. WldtStorage: An abstract class to implement custom storage systems. The default in-memory storage is available for development and testing. Query System: The query system enables external components like Digital Adapters to retrieve stored data efficiently, supporting both synchronous and asynchronous queries. WLDT 0.4.0 significantly enhances the flexibility and capabilities of Digital Twins, making it easier to manage and retrieve data, and observe events. We encourage developers to explore these new features and integrate them into their projects.\nStay tuned for more updates!\n","date":"August 29, 2024","id":2,"permalink":"/blog/wldt-library-version-0.4.0/","summary":"We\u0026rsquo;re excited to announce the release of WLDT version 0.4.0! This update brings powerful new features to enhance your Digital Twin (DT) experience, including event observation capabilities, a robust storage layer, and a flexible query system.","tags":"","title":"WLDT Library Version 0.4.0"},{"content":"ðŸ“£ We\u0026rsquo;re thrilled to announce the release of version 0.3.0 of the White Label Digital Twins (WLDT) library! This release brings significant enhancements, improvements, and new features to further empower developers in designing, developing, and deploying Digital Twins within Internet of Things (IoT) ecosystems.\nFor detailed information about these changes and their impact, please refer to the information provided:\nOfficial Changelog Official Documentation Let\u0026rsquo;s dive into the key changes and updates included in this release:\nMigration Digital Adapters In version 0.3.0, we\u0026rsquo;ve made several enhancements and adjustments to the Digital Adapter class to improve its functionality and usability. Notable changes include:\nDiscontinued Methods: Several methods have been discontinued and removed from the DigitalAdapter class to streamline its interface and improve clarity. Method Signature Changes: The signatures of certain methods have been updated for consistency and clarity, ensuring a more intuitive developer experience. New Methods: We\u0026rsquo;ve introduced new methods to provide additional functionality and flexibility for handling state updates and event notifications. Migration Shadowing Function We\u0026rsquo;ve made significant improvements to the ShadowingModelFunction, which is now renamed to ShadowingFunction. Additionally, we\u0026rsquo;ve introduced changes to how the DigitalTwinState is managed within the Shadowing Function, providing developers with more control and flexibility.\nMigrating WLDT Engine \u0026amp; DT Creation In version 0.3.0, the WldtEngine class has been renamed to DigitalTwin, offering improved clarity and consistency. We\u0026rsquo;ve also made adjustments to the lifecycle management of Digital Twins, streamlining the process and enhancing usability.\nDigital Twin \u0026amp; Digital Twin Engine We\u0026rsquo;ve introduced enhancements to the Digital Twin and Digital Twin Engine classes, providing developers with improved functionality and ease of use. Notable updates include:\nSimplified Digital Twin Creation: Creating and managing Digital Twins is now more intuitive and streamlined. Lifecycle Management: We\u0026rsquo;ve enhanced the lifecycle management of Digital Twins, making it easier to start, stop, and manage multiple instances. Digital Twin State Manager The DigitalTwinStateManager class has been improved to provide better support for managing the state of Digital Twins. With features such as transaction support and event notification, developers can more effectively manage changes to Digital Twin states and respond to events.\nTo learn more about the capabilities of the DigitalTwinStateManager, please refer to the Digital Twin State Manager section.\nDigital Adapter We\u0026rsquo;ve extended and improved the Digital Adapter base class to provide enhanced support for handling Digital Twin state updates and event notifications. With the introduction of the onStateUpdate and onEventNotificationReceived methods, developers can more effectively respond to changes in Digital Twin states and events.\nGet Started with WLDT 0.3.0 To get started with version 0.3.0 of the WLDT library, simply update your dependencies to include the latest release. Detailed documentation and usage examples are available in the project repository, providing comprehensive guidance on leveraging the new features and enhancements.\nWe\u0026rsquo;re excited about the improvements and new capabilities introduced in WLDT 0.3.0, and we can\u0026rsquo;t wait to see how developers utilize them to create innovative IoT solutions powered by Digital Twins. As always, we welcome your feedback and contributions to help us further improve the library and empower the community.\nHappy coding with WLDT 0.3.0! ðŸš€\n","date":"March 13, 2024","id":3,"permalink":"/blog/wldt-library-version-0.3.0/","summary":"ðŸ“£ We\u0026rsquo;re thrilled to announce the release of version 0.3.0 of the White Label Digital Twins (WLDT) library! This release brings significant enhancements, improvements, and new features to further empower developers in designing, developing, and deploying Digital Twins within Internet of Things (IoT) ecosystems.","tags":"","title":"WLDT Library Version 0.3.0"},{"content":"","date":"September 7, 2023","id":4,"permalink":"/blog/","summary":"","tags":"","title":"Blog"},{"content":"","date":"September 7, 2023","id":5,"permalink":"/docs/introduction/","summary":"","tags":"","title":"Introduction"},{"content":"","date":"February 9, 2024","id":6,"permalink":"/docs/guides/","summary":"","tags":"","title":"Getting Started"},{"content":"The developer can use an existing Physical Adapter or create a new one to handle the communication with a specific physical twin. In this documentation we focus on the creation of a new Physical Adapter in order to explain library core functionalities. However, existing Physical Adapters can be found on the official repository and linked in the core documentation and webpage (WLDT-GitHub).\nIn general WLDT Physical Adapter extends the class PhysicalAdapter and it is responsible to talk with the physical world and handling the following main tasks:\nGenerate a PAD describing the properties, events, actions and relationships available on the physical twin using the class PhysicalAssetDescription Generate Physical Event using the class PhysicalAssetEventWldtEvent associated to the variation of any aspect of the physical state (properties, events, and relationships) Handle action request coming from the Digital World through the DT Shadowing Function by implementing the method onIncomingPhysicalAction and processing events modeled through the class PhysicalAssetActionWldtEvent Create a new class called DemoPhysicalAdapter extending the library class PhysicalAdapter and implement the following methods:\nonAdapterStart: A callback method used to notify when the adapter has been effectively started withing the DT\u0026rsquo;s life cycle onAdapterStop: A call method invoked when the adapter has been stopped and will be dismissed by the core onIncomingPhysicalAction: The callback method called when a new PhysicalAssetActionWldtEvent is sent by the Shadowing Function upon the receiving of a valid Digital Action through a Digital Adapter Then you have to create a constructor for your Physical Adapter with a single String parameter representing the id of the adapter. This id will be used internally by the library to handle and coordinate multiple adapters, adapts logs and execute functions upon the arrival of a new event. The resulting empty class will the following:\npublic class DemoPhysicalAdapter extends PhysicalAdapter { public DemoPhysicalAdapter(String id) { super(id); } @Override public void onIncomingPhysicalAction(PhysicalAssetActionWldtEvent\u0026lt;?\u0026gt; physicalAssetActionWldtEvent) { } @Override public void onAdapterStart() { } @Override public void onAdapterStop() { } } In our test Physical Adapter example we are going to emulate the communication with an Internet of Things device with the following sensing and actuation characteristics:\nA Temperature Sensor generating data about new measurements The possibility to generate OVER-HEATING events An action to set the target desired temperature value The first step will be to generate and publish the PhysicalAssetDescription (PAD) to describe the capabilities and the characteristics of our object allowing the Shadowing Function to decide how to digitalize its physical counterpart. Of course in our case the PAD is generated manually but according to the nature of the connected physical twin it can be automatically generated starting from a discovery or a configuration passed to the adapter.\nThe generation of the PAD for each active Physical Adapter is the fundamental DT process to handle the binding procedure and to allow the Shadowing Function and consequently the core of the twin to be aware of what is available in the physical world and consequently decide what to observe and digitalize.\nIn order to publish the PAD we can update the onAdapterStart method with the following lines of code:\nprivate final static String TEMPERATURE_PROPERTY_KEY = \u0026#34;temperature-property-key\u0026#34;; private final static String OVERHEATING_EVENT_KEY = \u0026#34;overheating-event-key\u0026#34;; private final static String SET_TEMPERATURE_ACTION_KEY = \u0026#34;set-temperatura-action-key\u0026#34;; @Override public void onAdapterStart() { try { //Create an empty PAD PhysicalAssetDescription pad = new PhysicalAssetDescription(); //Add a new Property associated to the target PAD with a key and a default value PhysicalAssetProperty\u0026lt;Double\u0026gt; temperatureProperty = new PhysicalAssetProperty\u0026lt;Double\u0026gt;(TEMPERATURE_PROPERTY_KEY, 0.0); pad.getProperties().add(temperatureProperty); //Add the declaration of a new type of generated event associated to a event key // and the content type of the generated payload PhysicalAssetEvent overheatingEvent = new PhysicalAssetEvent(OVERHEATING_EVENT_KEY, \u0026#34;text/plain\u0026#34;); pad.getEvents().add(overheatingEvent); //Declare the availability of a target action characterized by a Key, an action type // and the expected content type and the request body PhysicalAssetAction setTemperatureAction = new PhysicalAssetAction(SET_TEMPERATURE_ACTION_KEY, \u0026#34;temperature.actuation\u0026#34;, \u0026#34;text/plain\u0026#34;); pad.getActions().add(setTemperatureAction); //Notify the new PAD to the DT\u0026#39;s Shadowing Function this.notifyPhysicalAdapterBound(pad); //TODO add here the Device Emulation method } catch (PhysicalAdapterException | EventBusException e) { e.printStackTrace(); } } Now we need a simple code to emulate the generation of new temperature measurements and over-heating events. In a real Physical Adapter implementation we have to implement the real communication with the physical twin in order to read its state variation over time according to the supported protocols. In our simplified Physical Adapter we can the following function:\nprivate final static int MESSAGE_UPDATE_TIME = 1000; private final static int MESSAGE_UPDATE_NUMBER = 10; private final static double TEMPERATURE_MIN_VALUE = 20; private final static double TEMPERATURE_MAX_VALUE = 30; private Runnable deviceEmulation(){ return () -\u0026gt; { try { //Sleep 5 seconds to emulate device startup Thread.sleep(5000); //Create a new random object to emulate temperature variations Random r = new Random(); //Publish an initial Event for a normal condition publishPhysicalAssetEventWldtEvent(new PhysicalAssetEventWldtEvent\u0026lt;\u0026gt;(OVERHEATING_EVENT_KEY, \u0026#34;normal\u0026#34;)); //Emulate the generation on \u0026#39;n\u0026#39; temperature measurements for(int i = 0; i \u0026lt; MESSAGE_UPDATE_NUMBER; i++){ //Sleep to emulate sensor measurement Thread.sleep(MESSAGE_UPDATE_TIME); //Update the double randomTemperature = TEMPERATURE_MIN_VALUE + (TEMPERATURE_MAX_VALUE - TEMPERATURE_MIN_VALUE) * r.nextDouble(); //Create a new event to notify the variation of a Physical Property PhysicalAssetPropertyWldtEvent\u0026lt;Double\u0026gt; newPhysicalPropertyEvent = new PhysicalAssetPropertyWldtEvent\u0026lt;\u0026gt;(TEMPERATURE_PROPERTY_KEY, randomTemperature); //Publish the WLDTEvent associated to the Physical Property Variation publishPhysicalAssetPropertyWldtEvent(newPhysicalPropertyEvent); } //Publish a demo Physical Event associated to a \u0026#39;critical\u0026#39; overheating condition publishPhysicalAssetEventWldtEvent(new PhysicalAssetEventWldtEvent\u0026lt;\u0026gt;(OVERHEATING_EVENT_KEY, \u0026#34;critical\u0026#34;)); } catch (EventBusException | InterruptedException e) { e.printStackTrace(); } }; } Now we have to call the deviceEmulationFunction() inside the onAdapterStart() triggering its execution and emulating the physical counterpart of our DT. To do that add the following line at the end of the onAdapterStart() method after the this.notifyPhysicalAdapterBound(pad);.\nThe last step will be to handle an incoming action trying to set a new temperature on the device by implementing the method onIncomingPhysicalAction(). This method will receive a PhysicalAssetActionWldtEvent\u0026lt;?\u0026gt; physicalAssetActionWldtEvent associated to the action request generated by the shadowing function. Since a Physical Adapter can handle multiple action we have to check both action-key and body type in order to properly process the action (in our case just logging the request). The new update method will result like this:\n@Override public void onIncomingPhysicalAction(PhysicalAssetActionWldtEvent\u0026lt;?\u0026gt; physicalAssetActionWldtEvent) { try{ if(physicalAssetActionWldtEvent != null \u0026amp;\u0026amp; physicalAssetActionWldtEvent.getActionKey().equals(SET_TEMPERATURE_ACTION_KEY) \u0026amp;\u0026amp; physicalAssetActionWldtEvent.getBody() instanceof String) { System.out.println(\u0026#34;Received Action Request: \u0026#34; + physicalAssetActionWldtEvent.getActionKey() + \u0026#34; with Body: \u0026#34; + physicalAssetActionWldtEvent.getBody()); } else System.err.println(\u0026#34;Wrong Action Received !\u0026#34;); }catch (Exception e){ e.printStackTrace(); } } The overall class will result as following:\nimport it.wldt.adapter.physical.*; import it.wldt.adapter.physical.event.PhysicalAssetActionWldtEvent; import it.wldt.adapter.physical.event.PhysicalAssetEventWldtEvent; import it.wldt.adapter.physical.event.PhysicalAssetPropertyWldtEvent; import it.wldt.exception.EventBusException; import it.wldt.exception.PhysicalAdapterException; import java.util.Random; public class DemoPhysicalAdapter extends PhysicalAdapter { private final static String TEMPERATURE_PROPERTY_KEY = \u0026#34;temperature-property-key\u0026#34;; private final static String OVERHEATING_EVENT_KEY = \u0026#34;overheating-event-key\u0026#34;; private final static String SET_TEMPERATURE_ACTION_KEY = \u0026#34;set-temperature-action-key\u0026#34;; private final static int MESSAGE_UPDATE_TIME = 1000; private final static int MESSAGE_UPDATE_NUMBER = 10; private final static double TEMPERATURE_MIN_VALUE = 20; private final static double TEMPERATURE_MAX_VALUE = 30; public DemoPhysicalAdapter(String id) { super(id); } @Override public void onIncomingPhysicalAction(PhysicalAssetActionWldtEvent\u0026lt;?\u0026gt; physicalAssetActionWldtEvent) { try{ if(physicalAssetActionWldtEvent != null \u0026amp;\u0026amp; physicalAssetActionWldtEvent.getActionKey().equals(SET_TEMPERATURE_ACTION_KEY) \u0026amp;\u0026amp; physicalAssetActionWldtEvent.getBody() instanceof Double) { System.out.println(\u0026#34;Received Action Request: \u0026#34; + physicalAssetActionWldtEvent.getActionKey() + \u0026#34; with Body: \u0026#34; + physicalAssetActionWldtEvent.getBody()); } else System.err.println(\u0026#34;Wrong Action Received !\u0026#34;); }catch (Exception e){ e.printStackTrace(); } } @Override public void onAdapterStart() { try { //Create an empty PAD PhysicalAssetDescription pad = new PhysicalAssetDescription(); //Add a new Property associated to the target PAD with a key and a default value PhysicalAssetProperty\u0026lt;Double\u0026gt; temperatureProperty = new PhysicalAssetProperty\u0026lt;Double\u0026gt;(GlobalKeywords.TEMPERATURE_PROPERTY_KEY, 0.0); pad.getProperties().add(temperatureProperty); //Add the declaration of a new type of generated event associated to a event key // and the content type of the generated payload PhysicalAssetEvent overheatingEvent = new PhysicalAssetEvent(GlobalKeywords.OVERHEATING_EVENT_KEY, \u0026#34;text/plain\u0026#34;); pad.getEvents().add(overheatingEvent); //Declare the availability of a target action characterized by a Key, an action type // and the expected content type and the request body PhysicalAssetAction setTemperatureAction = new PhysicalAssetAction(GlobalKeywords.SET_TEMPERATURE_ACTION_KEY, \u0026#34;temperature.actuation\u0026#34;, \u0026#34;text/plain\u0026#34;); pad.getActions().add(setTemperatureAction); //Notify the new PAD to the DT\u0026#39;s Shadowing Function this.notifyPhysicalAdapterBound(pad); //Start Device Emulation new Thread(deviceEmulation()).start(); } catch (PhysicalAdapterException | EventBusException e) { e.printStackTrace(); } } @Override public void onAdapterStop() { } private Runnable deviceEmulation(){ return () -\u0026gt; { try { //Sleep 5 seconds to emulate device startup Thread.sleep(5000); //Create a new random object to emulate temperature variations Random r = new Random(); //Publish an initial Event for a normal condition publishPhysicalAssetEventWldtEvent(new PhysicalAssetEventWldtEvent\u0026lt;\u0026gt;(GlobalKeywords.OVERHEATING_EVENT_KEY, \u0026#34;normal\u0026#34;)); //Emulate the generation on \u0026#39;n\u0026#39; temperature measurements for(int i = 0; i \u0026lt; GlobalKeywords.MESSAGE_UPDATE_NUMBER; i++){ //Sleep to emulate sensor measurement Thread.sleep(GlobalKeywords.MESSAGE_UPDATE_TIME); //Update the double randomTemperature = GlobalKeywords.TEMPERATURE_MIN_VALUE + (GlobalKeywords.TEMPERATURE_MAX_VALUE - GlobalKeywords.TEMPERATURE_MIN_VALUE) * r.nextDouble(); //Create a new event to notify the variation of a Physical Property PhysicalAssetPropertyWldtEvent\u0026lt;Double\u0026gt; newPhysicalPropertyEvent = new PhysicalAssetPropertyWldtEvent\u0026lt;\u0026gt;(GlobalKeywords.TEMPERATURE_PROPERTY_KEY, randomTemperature); //Publish the WLDTEvent associated to the Physical Property Variation publishPhysicalAssetPropertyWldtEvent(newPhysicalPropertyEvent); } //Publish a demo Physical Event associated to a \u0026#39;critical\u0026#39; overheating condition publishPhysicalAssetEventWldtEvent(new PhysicalAssetEventWldtEvent\u0026lt;\u0026gt;(GlobalKeywords.OVERHEATING_EVENT_KEY, \u0026#34;critical\u0026#34;)); } catch (EventBusException | InterruptedException e) { e.printStackTrace(); } }; } } Both Physical Adapters and Digital Adapters can be defined natively with a custom configuration provided by the developer as illustrated in the dedicated Section: Configurable Physical \u0026amp; Digital Adapters.\n","date":"February 9, 2024","id":7,"permalink":"/docs/guides/physical-adapter/","summary":"The developer can use an existing Physical Adapter or create a new one to handle the communication with a specific physical twin.","tags":"","title":"Physical Adapter"},{"content":"After the definition of the Physical Adapter it is time to start implementing the core of our DT through the definition of its shadowing function in charge of:\nHandle received PAD from Physical Adapters in order to device which properties, events, relationships or actions available on connected physical twins should be mapped and managed into the DT State Manage incoming notifications/callbacks associated to the variation of physical properties (e.g, temperature variation) or the generation of physical event (e.g., overheating) Process action requests from the digital world that should be validated and forward to the correct Physical Adapter in order to trigger the associated actions on the physical world The Shadowing Function has the responsibility to build and maintain the updated state of the Digital Twin The internal variable of any WLDT Shadowing Function (available through the base class ShadowingFunction) used to do that is DigitalTwinStateManager accessible through the variable: this.digitalTwinStateManager\nWhen the Shadowing Function has to compute the new DT State it can now work with the following method to handle DT State Transition:\nStart the DT State Transaction: startStateTransaction() DT State variation methods such as: createProperty() updateProperty() updatePropertyValue() deleteProperty() enableAction() updateAction() disableAction() registerEvent() updateRegisteredEvent() unRegisterEvent() createRelationship() addRelationshipInstance() deleteRelationship() deleteRelationshipInstance() At the end the transaction can be committed using the method: commitStateTransaction() To access the current DT State the Shadowing Function implementation can use the method this.digitalTwinStateManager.getDigitalTwinState() The information available on the DT State are:\nproperties: List of Properties with their values (if available) actions: List of Actions that can be called on the DT events: List of Events that can be generated by the DT relationships: List of Relationships and their instances (if available) evaluationInstant: The timestamp representing the evaluation instant of the DT state Available main methods on that class instance are:\nProperties: getProperty(String propertyKey): Retrieves if present the target DigitalTwinStateProperty by Key containsProperty(String propertyKey): Checks if a target Property Key is already available in the current Digital Twin\u0026rsquo;s State getPropertyList(): Loads the list of available Properties (described by the class DigitalTwinStateProperty) available on the Digital Twin\u0026rsquo;s State createProperty(DigitalTwinStateProperty\u0026lt;?\u0026gt; dtStateProperty): Allows the creation of a new Property on the Digital Twin\u0026rsquo;s State through the class DigitalTwinStateProperty readProperty(String propertyKey): Retrieves if present the target DigitalTwinStateProperty by Key updateProperty(DigitalTwinStateProperty\u0026lt;?\u0026gt; dtStateProperty): Updates the target property using the DigitalTwinStateProperty and the associated Property Key field deleteProperty(String propertyKey): Deletes the target property identified by the specified key Actions: containsAction(String actionKey): Checks if a Digital Twin State Action with the specified key is correctly registered getAction(String actionKey): Loads the target DigitalTwinStateAction by key getActionList(): Gets the list of available Actions registered on the Digital Twin\u0026rsquo;s State enableAction(DigitalTwinStateAction digitalTwinStateAction): Enables and registers the target Action described through an instance of the DigitalTwinStateAction class updateAction(DigitalTwinStateAction digitalTwinStateAction): Update the already registered target Action described through an instance of the DigitalTwinStateAction class disableAction(String actionKey): Disables and unregisters the target Action described through an instance of the DigitalTwinStateAction class Events: containsEvent(String eventKey): Check if a Digital Twin State Event with the specified key is correctly registered getEvent(String eventKey): Return the description of a registered Digital Twin State Event according to its Key getEventList(): Return the list of existing and registered Digital Twin State Events registerEvent(DigitalTwinStateEvent digitalTwinStateEvent): Register a new Digital Twin State Event updateRegisteredEvent(DigitalTwinStateEvent digitalTwinStateEvent): Update the registration and signature of an existing Digital Twin State Event unRegisterEvent(String eventKey): Un-register a Digital Twin State Event notifyDigitalTwinStateEvent(DigitalTwinStateEventNotification\u0026lt;?\u0026gt; digitalTwinStateEventNotification): Method to notify the occurrence of the target Digital Twin State Event Relationships: containsRelationship(String relationshipName): Checks if a Relationship Name is already available in the current Digital Twin\u0026rsquo;s State createRelationship(DigitalTwinStateRelationship\u0026lt;?\u0026gt; relationship): Creates a new Relationships (described by the class DigitalTwinStateRelationship) in the Digital Twin\u0026rsquo;s State addRelationshipInstance(String name, DigitalTwinStateRelationshipInstance\u0026lt;?\u0026gt; instance): Adds a new Relationship instance described through the class DigitalTwinStateRelationshipInstance and identified through its name getRelationshipList(): Loads the list of existing relationships on the Digital Twin\u0026rsquo;s State through a list of DigitalTwinStateRelationship getRelationship(String name): Gets a target Relationship identified through its name and described through the class DigitalTwinStateRelationship deleteRelationship(String name): Deletes a target Relationship identified through its name deleteRelationshipInstance(String relationshipName, String instanceKey): Deletes the target Relationship Instance using relationship name and instance Key The basic library class that we are going to extend is called ShadowingFunction and creating a new class named DemoShadowingFunction the resulting code is the same after implementing required methods the basic constructor with the id String parameter.\nimport it.wldt.adapter.digital.event.DigitalActionWldtEvent; import it.wldt.adapter.physical.PhysicalAssetDescription; import it.wldt.adapter.physical.event.PhysicalAssetEventWldtEvent; import it.wldt.adapter.physical.event.PhysicalAssetPropertyWldtEvent; import it.wldt.adapter.physical.event.PhysicalAssetRelationshipInstanceCreatedWldtEvent; import it.wldt.adapter.physical.event.PhysicalAssetRelationshipInstanceDeletedWldtEvent; import it.wldt.core.model.ShadowingModelFunction; import java.util.Map; public class DemoShadowingFunction extends ShadowingModelFunction { public DemoShadowingFunction(String id) { super(id); } //// Shadowing Function Management Callbacks //// @Override protected void onCreate() { } @Override protected void onStart() { } @Override protected void onStop() { } //// Bound LifeCycle State Management Callbacks //// @Override protected void onDigitalTwinBound(Map\u0026lt;String, PhysicalAssetDescription\u0026gt; adaptersPhysicalAssetDescriptionMap) { } @Override protected void onDigitalTwinUnBound(Map\u0026lt;String, PhysicalAssetDescription\u0026gt; map, String s) { } @Override protected void onPhysicalAdapterBidingUpdate(String s, PhysicalAssetDescription physicalAssetDescription) { } //// Physical Property Variation Callback //// @Override protected void onPhysicalAssetPropertyVariation(PhysicalAssetPropertyWldtEvent\u0026lt;?\u0026gt; physicalAssetPropertyWldtEvent) { } //// Physical Event Notification Callback //// @Override protected void onPhysicalAssetEventNotification(PhysicalAssetEventWldtEvent\u0026lt;?\u0026gt; physicalAssetEventWldtEvent) { } //// Physical Relationships Notification Callbacks //// @Override protected void onPhysicalAssetRelationshipEstablished(PhysicalAssetRelationshipInstanceCreatedWldtEvent\u0026lt;?\u0026gt; physicalAssetRelationshipInstanceCreatedWldtEvent) { } @Override protected void onPhysicalAssetRelationshipDeleted(PhysicalAssetRelationshipInstanceDeletedWldtEvent\u0026lt;?\u0026gt; physicalAssetRelationshipInstanceDeletedWldtEvent) { } //// Digital Action Received Callbacks //// @Override protected void onDigitalActionEvent(DigitalActionWldtEvent\u0026lt;?\u0026gt; digitalActionWldtEvent) { } } The methods onCreate(), onStart() and onStop() are used to receive callbacks from the DT\u0026rsquo;s core when the Shadowing Function has been effectively created within the twin, is started or stopped according to the evolution of its life cycle. In our initial implementation we are not implementing any of them but they can be useful to trigger specific behaviours according to the different phases.\nThe first method that we have to implement in order to analyze received PAD and build the Digital Twin State in terms of properties, events, relationships and available actions is the onDigitalTwinBound(Map\u0026lt;String, PhysicalAssetDescription\u0026gt; map) method. In our initial implementation we just pass through all the received characteristics recevied from each connected Physical Adapter mapping every physical entity into the DT\u0026rsquo;s state without any change or adaptation (Of course complex behaviour can be implemented to customized the digitalization process).\nThrough the following method we implement the following behaviour:\nAnalyze each received PAD from each connected and active Physical Adapter (in our case we will have just 1 Physical Adapter) Iterate over all the received Properties for each PAD and create the same Property on the Digital Twin State Start observing target Physical Properties in order to receive notification callback about physical variation through the method observePhysicalAssetProperty(property); Analyze received PAD\u0026rsquo;s Events declaration and recreates them also on the DT\u0026rsquo;s State Start observing target Physical Event in order to receive notification callback about physical event generation through the method observePhysicalAssetEvent(event); Check available Physical Action and enable them on the DT\u0026rsquo;s State. Enabled Digital Action are automatically observed by the Shadowing Function in order to receive action requests from active Digital Adapters The possibility to manually observe Physical Properties and Event has been introduced to allow the Shadowing Function to decide what to do according to the nature of the property or of the target event. For example in some cases with static properties it will not be necessary to observe any variation, and it will be enough to read the initial value to build the digital replica of that specific property.\nSince the DT State is managed through the DigitalTwinStateManager class all the changes and variation should be applied on the DT ShadowingFunction using the previously presented transaction management and the correct call of methods startStateTransaction() and commitStateTransaction().\n@Override protected void onDigitalTwinBound(Map\u0026lt;String, PhysicalAssetDescription\u0026gt; adaptersPhysicalAssetDescriptionMap) { try{ // NEW from 0.3.0 -\u0026gt; Start DT State Change Transaction this.digitalTwinStateManager.startStateTransaction(); //Iterate over all the received PAD from connected Physical Adapters adaptersPhysicalAssetDescriptionMap.values().forEach(pad -\u0026gt; { //Iterate over all the received PAD from connected Physical Adapters adaptersPhysicalAssetDescriptionMap.values().forEach(pad -\u0026gt; { pad.getProperties().forEach(property -\u0026gt; { try { //Create and write the property on the DT\u0026#39;s State this.digitalTwinState.createProperty(new DigitalTwinStateProperty\u0026lt;\u0026gt;(property.getKey(),(Double) property.getInitialValue())); //Start observing the variation of the physical property in order to receive notifications //Without this call the Shadowing Function will not receive any notifications or callback about //incoming physical property of the target type and with the target key this.observePhysicalAssetProperty(property); } catch (Exception e) { e.printStackTrace(); } }); //Iterate over available declared Physical Events for the target Physical Adapter\u0026#39;s PAD pad.getEvents().forEach(event -\u0026gt; { try { //Instantiate a new DT State Event with the same key and type DigitalTwinStateEvent dtStateEvent = new DigitalTwinStateEvent(event.getKey(), event.getType()); //Create and write the event on the DT\u0026#39;s State this.digitalTwinState.registerEvent(dtStateEvent); //Start observing the variation of the physical event in order to receive notifications //Without this call the Shadowing Function will not receive any notifications or callback about //incoming physical events of the target type and with the target key this.observePhysicalAssetEvent(event); } catch (Exception e) { e.printStackTrace(); } }); //Iterate over available declared Physical Actions for the target Physical Adapter\u0026#39;s PAD pad.getActions().forEach(action -\u0026gt; { try { //Instantiate a new DT State Action with the same key and type DigitalTwinStateAction dtStateAction = new DigitalTwinStateAction(action.getKey(), action.getType(), action.getContentType()); //Enable the action on the DT\u0026#39;s State this.digitalTwinState.enableAction(dtStateAction); } catch (Exception e) { e.printStackTrace(); } }); }); // NEW from 0.3.0 -\u0026gt; Commit DT State Change Transaction to apply the changes on the DT State and notify about the change this.digitalTwinStateManager.commitStateTransaction(); //Start observation to receive all incoming Digital Action through active Digital Adapter //Without this call the Shadowing Function will not receive any notifications or callback about //incoming request to execute an exposed DT\u0026#39;s Action observeDigitalActionEvents(); //Notify the DT Core that the Bounding phase has been correctly completed and the DT has evaluated its //internal status according to what is available and declared through the Physical Adapters notifyShadowingSync(); }catch (Exception e){ e.printStackTrace(); } } In particular the method observeDigitalActionEvents() should be called start the observation of digital actions and to receive all incoming Digital Action through active Digital Adapters. Without this call the Shadowing Function will not receive any notifications or callback about incoming request to execute an exposed DT\u0026rsquo;s Action. Of course, we have to call this method if we are mapping any digital action in our DT.\nAnother fundamental method is notifyShadowingSync() used to notify the DT Core that the Bounding phase has been correctly completed and the DT has evaluated its internal status according to what is available and declared through the Physical Adapters.\nAs mentioned, in the previous example the Shadowing Function does not apply any control or check on the nature of declared physical property. Of course in order to have a more granular control, it will be possible to use property Key or any other field or even the type of the instance through an instanceof check to implement different controls and behaviours.\nA variation (only for the property management code) to the previous method can be the following:\n//Iterate over available declared Physical Property for the target Physical Adapter\u0026#39;s PAD pad.getProperties().forEach(property -\u0026gt; { try { //Check property Key and Instance of to validate that is a Double if(property.getKey().equals(\u0026#34;temperature-property-key\u0026#34;) \u0026amp;\u0026amp; property.getInitialValue() != null \u0026amp;\u0026amp; property.getInitialValue() instanceof Double) { //Instantiate a new DT State Property of the right type, the same key and initial value DigitalTwinStateProperty\u0026lt;Double\u0026gt; dtStateProperty = new DigitalTwinStateProperty\u0026lt;Double\u0026gt;(property.getKey(),(Double) property.getInitialValue()); //Create and write the property on the DT\u0026#39;s State this.digitalTwinState.createProperty(dtStateProperty); //Start observing the variation of the physical property in order to receive notifications //Without this call the Shadowing Function will not receive any notifications or callback about //incoming physical property of the target type and with the target key this.observePhysicalAssetProperty(property); } } catch (Exception e) { e.printStackTrace(); } }); The next method that we have to implement in order to properly define and implement the behaviour of our DT through its ShadowingModelFunction are:\nonPhysicalAssetPropertyVariation: Method called when a new variation for a specific Physical Property has been detected by the associated Physical Adapter. The method receive as parameter a specific WLDT Event called PhysicalAssetPropertyWldtEvent\u0026lt;?\u0026gt; physicalPropertyEventMessage containing all the information generated by the Physical Adapter upon the variation of the monitored physical counterpart. onPhysicalAssetEventNotification: Callback method used to be notified by a PhysicalAdapter about the generation of a Physical Event. As for the previous method, also this function receive a WLDT Event parameter of type onPhysicalAssetEventNotification(PhysicalAssetEventWldtEvent\u0026lt;?\u0026gt; physicalAssetEventWldtEvent)) containing all the field of the generated physical event. onDigitalActionEvent: On the opposite this method is triggered from one of the active Digital Adapter when an Action request has been received on the Digital Interface. The method receive as parameter an instance of the WLDT Event class DigitalActionWldtEvent\u0026lt;?\u0026gt; digitalActionWldtEvent describing the target digital action request and the associated body. For the onPhysicalAssetPropertyVariation a simple implementation in charge ONLY of mapping the new Physical Property value into the corresponding DT\u0026rsquo;State property can be implemented as follows:\nThe DT State transaction management should be applied in the point of the code where the Shadowing Function receive a variation from the Physical world through a target adapter and the callback method onPhysicalAssetPropertyVariation(...)\n@Override protected void onPhysicalAssetPropertyVariation(PhysicalAssetPropertyWldtEvent\u0026lt;?\u0026gt; physicalPropertyEventMessage) { try { //Update Digital Twin State //NEW from 0.3.0 -\u0026gt; Start State Transaction this.digitalTwinStateManager.startStateTransaction(); this.digitalTwinState.updateProperty(new DigitalTwinStateProperty\u0026lt;\u0026gt;(physicalPropertyEventMessage.getPhysicalPropertyId(), physicalPropertyEventMessage.getBody())); //NEW from 0.3.0 -\u0026gt; Commit State Transaction this.digitalTwinStateManager.commitStateTransaction(); } catch (WldtDigitalTwinStatePropertyException | WldtDigitalTwinStatePropertyBadRequestException | WldtDigitalTwinStatePropertyNotFoundException | WldtDigitalTwinStateException e) { e.printStackTrace(); } } In this case as reported in the code, we call the method this.digitalTwinState.updateProperty on the Shadowing Function in order to update an existing DT\u0026rsquo;State property (previously created in the onDigitalTwinBound method). To update the value we directly use the received data on the PhysicalAssetPropertyWldtEvent without any additional check or change that might be instead needed in advanced examples.\nFollowing the same principle, a simplified digital mapping between physical and digital state upon the receving of a physical event variation can be the following:\n@Override protected void onPhysicalAssetEventNotification(PhysicalAssetEventWldtEvent\u0026lt;?\u0026gt; physicalAssetEventWldtEvent) { try { this.digitalTwinStateManager.notifyDigitalTwinStateEvent(new DigitalTwinStateEventNotification\u0026lt;\u0026gt;(physicalAssetEventWldtEvent.getPhysicalEventKey(), physicalAssetEventWldtEvent.getBody(), physicalAssetEventWldtEvent.getCreationTimestamp())); } catch (WldtDigitalTwinStateEventNotificationException | EventBusException e) { e.printStackTrace(); } } With respect to events management, we use the Shadowint Function method this.digitalTwinState.notifyDigitalTwinStateEvent to notify the other DT Components (e.g., Digital Adapters) the incoming Physical Event by creating a new instance of a DigitalTwinStateEventNotification class containing all the information associated to the event. Of course, additional controls and checks can be introduced in this method validating and processing the incoming physical message to define complex behaviours.\nThe last method that we are going to implement is the onDigitalActionEvent one where we have to handle an incoming Digital Action request associated to an Action declared on the DT\u0026rsquo;s State in the onDigitalTwinBound method. In that case the Digital Action should be forwarded to the Physical Interface in order to be sent to the physical counterpart for the effective execution.\n@Override protected void onDigitalActionEvent(DigitalActionWldtEvent\u0026lt;?\u0026gt; digitalActionWldtEvent) { try { this.publishPhysicalAssetActionWldtEvent(digitalActionWldtEvent.getActionKey(), digitalActionWldtEvent.getBody()); } catch (EventBusException e) { e.printStackTrace(); } } Also in that case we are forwarding the incoming Digital Action request described through the class DigitalActionWldtEvent to the Physical Adapter with the method of the Shadowing Function denoted as this.publishPhysicalAssetActionWldtEvent and passing directly the action key and the target Body. No additional processing or validation have been introduced here, but they might be required in advanced scenario in order to properly adapt incoming digital action request to what is effectively expected on the physical counterpart.\n","date":"February 9, 2024","id":8,"permalink":"/docs/guides/shadowing-function/","summary":"After the definition of the Physical Adapter it is time to start implementing the core of our DT through the definition of its shadowing function in charge of:","tags":"","title":"Shadowing Function"},{"content":"The las component that we have to implement to complete our first simple Digital Twin definition through the WLDT library is a Digital Adapter in charge of:\nReceiving event from the DT\u0026rsquo;s Core related to the variation of properties, events, available actions and relationships Expose received information to the external world according to its implementation and the supported protocol Handle incoming digital action and forward them to the Core in order to be validated and processed by the Shadowing Function The basic library class that we are going to extend is called DigitalAdapter and creating a new class named DemoDigitalAdapter. The DigitalTwinAdapter class can take as Generic Type the type of Configuration used to configure its behaviours. In this simplified example we are defining a DigitalAdapter without any Configuration.\nA Digital Adapter has direct access to the current DT\u0026rsquo;s State through callbacks or directly in a synchronous way using the internal variable called: digitalTwinState. Through it is possibile to navigate all the fields currently composing the state of our Digital Twin.\nThe Digital Adapter class has e long list of callback and notification method to allow the adapter to be updated about all the variation and changes on the twin. Available callbacks can be summarized as follows:\nDigital Adapter Start/Stop: onAdapterStart(): Feedback when the Digital Adapter correctly starts onAdapterStop(): Feedback when the Digital Adapter has been stopped Digital Twin Life Cycle Notifications: onDigitalTwinCreate(): The DT has been created onDigitalTwinStart(): The DT started onDigitalTwinSync(IDigitalTwinState digitalTwinState): The DT is Synchronized with its physical counterpart. The current DigitalTwinState is passed as parameter to allow the Digital Adapter to know the current state and consequently implement its behaviour onDigitalTwinUnSync(IDigitalTwinState digitalTwinState): The DT is not synchronized anymore with its physical counterpart. The last current DigitalTwinState is passed as parameter to allow the Digital Adapter to know the last state and consequently implement its behaviour onDigitalTwinStop(): The DT is stopped onDigitalTwinDestroy(): The DT has been destroyed and the application stopped The Digital Adapter DT State variations and DT events are received by the Adapter from the DT core belongs to the following categories:\nDigital Twin State Update through the method onStateUpdate(...) providing information about the new state of the Digital Twin, the previous state, and a list of changes that occurred between these two states. In the previous version each variation of a property, relationships, actions or events were notified. In the new version only a committed DT\u0026rsquo;State variation is notified to listeners. Event Notifications through the method onEventNotificationReceived(...) whenever there is a notification about an event related to the Digital Twin\u0026rsquo;s state coming from the physical world, generated by the twin and processed by the Shadowing Function. For example in the DT State we can have the declaration of the over-heating-alert structured and received in the DT State while the effective occurrence of the event and the associated notification is notified through this dedicated callback The onStateUpdate method is an abstract method that must be implemented by any class extending the DigitalAdapter class. This method is called whenever there is an update to the Digital Twin\u0026rsquo;s state. It provides information about the new state of the Digital Twin, the previous state, and a list of changes that occurred between these two states.\nThe explanation of the parameters is the following:\nnewDigitalTwinState: This parameter represents the updated state of the Digital Twin. It is an instance of the DigitalTwinState class, which encapsulates the current state information. previousDigitalTwinState: This parameter represents the state of the Digital Twin before the update. It is also an instance of the DigitalTwinState class. digitalTwinStateChangeList: This parameter is an ArrayList containing DigitalTwinStateChange objects. Each DigitalTwinStateChange object encapsulates information about a specific change that occurred between the previous and new states. It includes details such as the property or aspect of the state that changed, the previous value, and the new value. Another core method where a Digital Adapter receive the description of the DT\u0026rsquo;State is onDigitalTwinSync(IDigitalTwinState digitalTwinState). The Adapter using the parameter digitalTwinState can analyze available properties, actions, events and relationships and decide how to implement its internal behaviour with the methods presented in ShadowingFunction. The DT State is automatically monitored by each Digital Adapter while for the Events potentially generated by the DT can be observed by each adapter using:\nobserveAllDigitalTwinEventsNotifications: Enable the observation of available Digital Twin State Events Notifications. unObserveAllDigitalTwinEventsNotifications: Cancel the observation of Digital Twin State Events Notifications observeDigitalTwinEventsNotifications: Enable the observation of the notification associated to a specific list of Digital Twin State events. With respect to event a notification contains the new associated value unObserveDigitalTwinEventsNotifications: Cancel the observation of a target list of properties observeDigitalTwinEventNotification: Enable the observation of the notification associated to a single Digital Twin State event. With respect to event a notification contains the new associated value unObserveDigitalTwinEventNotification: Cancel the observation of a single target event The resulting code will be the following after adding the required methods (still empty) and the basic constructor with the id String parameter is the following:\nimport it.wldt.adapter.digital.DigitalAdapter; import it.wldt.core.state.*; public class DemoDigitalAdapter extends DigitalAdapter\u0026lt;Void\u0026gt; { public DemoDigitalAdapter(String id) { super(id); } /** * Callback to notify the adapter on its correct startup */ @Override public void onAdapterStart() {} /** * Callback to notify the adapter that has been stopped */ @Override public void onAdapterStop() {} /** * DT Life Cycle notification that the DT is correctly on Sync * @param digitalTwinState */ @Override public void onDigitalTwinSync(DigitalTwinState digitalTwinState) {} /** * DT Life Cycle notification that the DT is currently Not Sync * @param digitalTwinState */ @Override public void onDigitalTwinUnSync(DigitalTwinState digitalTwinState) {} /** * DT Life Cycle notification that the DT has been created */ @Override public void onDigitalTwinCreate() {} /** * DT Life Cycle Notification that the DT has correctly Started */ @Override public void onDigitalTwinStart() {} /** * DT Life Cycle Notification that the DT has been stopped */ @Override public void onDigitalTwinStop() {} /** * DT Life Cycle Notification that the DT has destroyed */ @Override public void onDigitalTwinDestroy() {} /** * Callback method allowing the Digital Adapter to receive the updated Digital Twin State together with * the previous state and the list of applied changes * * @param newDigitalTwinState The new Digital Twin State computed by the Shadowing Function * @param previousDigitalTwinState The previous Digital Twin State * @param digitalTwinStateChangeList The list of applied changes to compute the new Digital Twin State */ @Override protected void onStateUpdate(DigitalTwinState newDigitalTwinState, DigitalTwinState previousDigitalTwinState, ArrayList\u0026lt;DigitalTwinStateChange\u0026gt; digitalTwinStateChangeList) {} /** * Callback method to receive a new computed Event Notification (associated to event declared in the DT State) * * @param digitalTwinStateEventNotification The generated Notification associated to a DT Event */ @Override protected void onEventNotificationReceived(DigitalTwinStateEventNotification\u0026lt;?\u0026gt; digitalTwinStateEventNotification) {} } By default, a Digital Adapter observes all the variation on the DT\u0026rsquo;s State in terms of Properties, Relationships, Actions and Events. As previously mentioned the observation of DT\u0026rsquo;s State Properties allows to receive also properties variation on the method since a property is natively composed by its description (e.g., type) and its current value. On the opposite the observation on DT\u0026rsquo;s State Action, Relationships and Events allow ONLY to receive callbacks when a new entity is added or an update is occurred without receiving updates on values variation.\nThe only thing that we should add in the onDigitalTwinSync(IDigitalTwinState currentDigitalTwinState) callback is the direct observation for Events. Following this approach we can change our Digital Adapter in the following methods:\nIn onDigitalTwinSync we observe in this first simple implementation only the incoming values for declared Events in the DT\u0026rsquo;State. As previously mentioned the observation of any variation of the State structure together with Properties Values are by default observed by any Digital Adapter. In this method we use the internal variable digitalTwinState to access the DT\u0026rsquo;s state and find available Events declaration that we would like to observe.\npublic void onDigitalTwinSync(IDigitalTwinState currentDigitalTwinState) { try { //Retrieve the list of available events and observe all variations digitalTwinState.getEventList() .map(eventList -\u0026gt; eventList.stream() .map(DigitalTwinStateEvent::getKey) .collect(Collectors.toList())) .ifPresent(eventKeys -\u0026gt; { try { observeDigitalTwinEventsNotifications(eventKeys); } catch (EventBusException e) { e.printStackTrace(); } }); } catch (Exception e) { e.printStackTrace(); } } Developers extending the DigitalAdapter class should implement the onStateUpdate method to define custom logic that needs to be executed whenever the state of the Digital Twin is updated. This could include tasks such as processing state changes, updating internal variables, triggering specific actions, or notifying other components about the state update.\nHere\u0026rsquo;s an example of how the method might be implemented in a concrete subclass of DigitalAdapter:\n@Override protected void onStateUpdate(DigitalTwinState newDigitalTwinState, DigitalTwinState previousDigitalTwinState, ArrayList\u0026lt;DigitalTwinStateChange\u0026gt; digitalTwinStateChangeList) { // In newDigitalTwinState we have the new DT State System.out.println(\u0026#34;New DT State is: \u0026#34; + newDigitalTwinState); // The previous DT State is available through the variable previousDigitalTwinState System.out.println(\u0026#34;Previous DT State is: \u0026#34; + previousDigitalTwinState); // We can also check each DT\u0026#39;s state change potentially differentiating the behaviour for each change if (digitalTwinStateChangeList != null \u0026amp;\u0026amp; !digitalTwinStateChangeList.isEmpty()) { // Iterate through each state change in the list for (DigitalTwinStateChange stateChange : digitalTwinStateChangeList) { // Get information from the state change DigitalTwinStateChange.Operation operation = stateChange.getOperation(); DigitalTwinStateChange.ResourceType resourceType = stateChange.getResourceType(); DigitalTwinStateResource resource = stateChange.getResource(); // Perform different actions based on the type of operation switch (operation) { case OPERATION_UPDATE: // Handle an update operation System.out.println(\u0026#34;Update operation on \u0026#34; + resourceType + \u0026#34;: \u0026#34; + resource); break; case OPERATION_UPDATE_VALUE: // Handle an update value operation System.out.println(\u0026#34;Update value operation on \u0026#34; + resourceType + \u0026#34;: \u0026#34; + resource); break; case OPERATION_ADD: // Handle an add operation System.out.println(\u0026#34;Add operation on \u0026#34; + resourceType + \u0026#34;: \u0026#34; + resource); break; case OPERATION_REMOVE: // Handle a remove operation System.out.println(\u0026#34;Remove operation on \u0026#34; + resourceType + \u0026#34;: \u0026#34; + resource); break; default: // Handle unknown operation (optional) System.out.println(\u0026#34;Unknown operation on \u0026#34; + resourceType + \u0026#34;: \u0026#34; + resource); break; } } } else { // No state changes System.out.println(\u0026#34;No state changes detected.\u0026#34;); } } In this example, the method iterates over the list of state changes, extracts information about each change, and performs custom actions based on the changes. Developers can adapt this method to suit the specific requirements of their Digital Twin application.\nBoth Physical Adapters and Digital Adapters can be defined natively with a custom configuration provided by the developer as illustrated in the dedicated Section: Configurable Physical \u0026amp; Digital Adapters.\n","date":"February 9, 2024","id":9,"permalink":"/docs/guides/digital-adapter/","summary":"The las component that we have to implement to complete our first simple Digital Twin definition through the WLDT library is a Digital Adapter in charge of:","tags":"","title":"Digital Adapter"},{"content":"Now that we have created the main fundamental element of a DT (Physical Adapter, Shadowing Function and Digital Adapter) we can create Class file with a main to create the WLDT Engine with the created components and start the DT.\nCreate a new Java file called DemoDigitalTwin adding the following code:\nWith the following code we now create a new Digital Twin Instance\n// Create the new Digital Twin with its Shadowing Function DigitalTwin digitalTwin = new DigitalTwin(digitalTwinId, new DemoShadowingFunction()); // Physical Adapter with Configuration digitalTwin.addPhysicalAdapter( new DemoPhysicalAdapter( String.format(\u0026#34;%s-%s\u0026#34;, digitalTwinId, \u0026#34;test-physical-adapter\u0026#34;), new DemoPhysicalAdapterConfiguration(), true)); // Digital Adapter with Configuration digitalTwin.addDigitalAdapter( new DemoDigitalAdapter( String.format(\u0026#34;%s-%s\u0026#34;, digitalTwinId, \u0026#34;test-digital-adapter\u0026#34;), new DemoDigitalAdapterConfiguration()) ); DTs cannot be directly run but it should be added to the DigitalTwinEngine in order to be executed through the WLDT Library\n// Create the Digital Twin Engine DigitalTwinEngine digitalTwinEngine = new DigitalTwinEngine(); // Add the Digital Twin to the Engine digitalTwinEngine.addDigitalTwin(digitalTwin); In order to start a DT from the Engine you can:\n// Directly start when you add it passing a second boolean value = true digitalTwinEngine.addDigitalTwin(digitalTwin. true); // Starting the single DT on the engine through its id digitalTwinEngine.startDigitalTwin(DIGITAL_TWIN_ID); // Start all the DTs registered on the engine digitalTwinEngine.startAll(); To stop a single twin or all the twin registered on the engine:\n// Stop a single DT on the engine through its id digitalTwinEngine.stopDigitalTwin(DIGITAL_TWIN_ID); // Stop all the DTs registered on the engine digitalTwinEngine.stopAll(); It is also possible to remove a DT from the Engine with a consequent stop if it is active and the deletion of its reference from the engine:\n// Remove a single DT on the engine through its id digitalTwinEngine.removeDigitalTwin(DIGITAL_TWIN_ID); // Remove all the DTs registered on the engine digitalTwinEngine.removeAll(); The resulting code in our case is:\npublic class DemoDigitalTwin { public static void main(String[] args) { try{ // Create the new Digital Twin DigitalTwin digitalTwin = new DigitalTwin( \u0026#34;test-dt-id\u0026#34;, new DemoShadowingFunction(\u0026#34;test-shadowing-function\u0026#34;) ); //Default Physical and Digital Adapter //digitalTwin.addPhysicalAdapter(new DemoPhysicalAdapter(\u0026#34;test-physical-adapter\u0026#34;)); //digitalTwin.addDigitalAdapter(new DemoDigitalAdapter(\u0026#34;test-digital-adapter\u0026#34;)); //Physical and Digital Adapters with Configuration digitalTwin.addPhysicalAdapter(new DemoConfPhysicalAdapter(\u0026#34;test-physical-adapter\u0026#34;, new DemoPhysicalAdapterConfiguration())); digitalTwin.addDigitalAdapter(new DemoConfDigitalAdapter(\u0026#34;test-digital-adapter\u0026#34;, new DemoDigitalAdapterConfiguration())); // Create the Digital Twin Engine DigitalTwinEngine digitalTwinEngine = new DigitalTwinEngine(); // Add the Digital Twin to the Engine digitalTwinEngine.addDigitalTwin(digitalTwin); // Set a new Event-Logger to a Custom One that we created with the class \u0026#39;DemoEventLogger\u0026#39; WldtEventBus.getInstance().setEventLogger(new DemoEventLogger()); // Start all the DTs registered on the engine digitalTwinEngine.startAll(); }catch (Exception e){ e.printStackTrace(); } } } ","date":"February 9, 2024","id":10,"permalink":"/docs/guides/dt-engine-dt-instance/","summary":"Now that we have created the main fundamental element of a DT (Physical Adapter, Shadowing Function and Digital Adapter) we can create Class file with a main to create the WLDT Engine with the created components and start the DT.","tags":"","title":"DT Engine \u0026 DT Instance"},{"content":"In this demo implementation, we are going to emulate an incoming Digital Action on the Digital Adapter in order to show how it can be handled by the adapter and properly forwarded to the Shadowing Function for validation and the consequent interaction with the Physical Adapter and then with the physical twin.\nIn order to add a demo Digital Action trigger on the Digital Adapter we add the following method to the DemoDigitalAdapter class:\nprivate Runnable emulateIncomingDigitalAction(){ return () -\u0026gt; { try { System.out.println(\u0026#34;Sleeping before Emulating Incoming Digital Action ...\u0026#34;); Thread.sleep(5000); Random random = new Random(); //Emulate the generation on \u0026#39;n\u0026#39; temperature measurements for(int i = 0; i \u0026lt; 10; i++){ //Sleep to emulate sensor measurement Thread.sleep(1000); double randomTemperature = 25.0 + (30.0 - 25.0) * random.nextDouble(); publishDigitalActionWldtEvent(\u0026#34;set-temperature-action-key\u0026#34;, randomTemperature); } } catch (Exception e) { e.printStackTrace(); } }; } This method uses the Digital Adapter internal function denoted as publishDigitalActionWldtEvent(String actionKey, T body) allowing the adapter to send a notification to the DT\u0026rsquo;s Core (and consequently the Shadowing Function) about the arrival of a Digital Action with a specific key and body. In our case the key is set-temperature-action-key as declared in the Physical Adapter and in the PAD and the value is a simple Double with the new temperature value.\nThen we call this method in the following way at the end ot the onDigitalTwinSync(IDigitalTwinState currentDigitalTwinState) method.\n//Start Digital Action Emulation new Thread(emulateIncomingDigitalAction()).start(); Now the Shadowing Function should be updated in order to handle the incoming Action request from the Digital Adapter. In our case the shadowing function does not apply any validation or check and just forward to action to the Physical Adapter in order to be then forwarded to the physical twin. Of course advanced implementation can be introduced for example to validate action, adapt payload and data-formats or to augment functionalities (e.g., trigger multiple physical actions from a single digital request).\nIn our simple demo implementation the updated Shadowing Function method onDigitalActionEvent(DigitalActionWldtEvent\u0026lt;?\u0026gt; digitalActionWldtEvent) results as follows:\n@Override protected void onDigitalActionEvent(DigitalActionWldtEvent\u0026lt;?\u0026gt; digitalActionWldtEvent) { try { this.publishPhysicalAssetActionWldtEvent(digitalActionWldtEvent.getActionKey(), digitalActionWldtEvent.getBody()); } catch (Exception e) { e.printStackTrace(); } } This forwarding of the action triggers the corresponding Physical Adapter method onIncomingPhysicalAction(PhysicalAssetActionWldtEvent\u0026lt;?\u0026gt; physicalAssetActionWldtEvent) that in our case is emulated just with a Log on the console. Also in that case advanced Physical Adapter implementation can be introduced for example to adapt the request from a high-level (and potentially standard) DT action description to the custom requirements of the specific physical twin managed by the adapter.\n@Override public void onIncomingPhysicalAction(PhysicalAssetActionWldtEvent\u0026lt;?\u0026gt; physicalAssetActionWldtEvent) { try{ if(physicalAssetActionWldtEvent != null \u0026amp;\u0026amp; physicalAssetActionWldtEvent.getActionKey().equals(SET_TEMPERATURE_ACTION_KEY) \u0026amp;\u0026amp; physicalAssetActionWldtEvent.getBody() instanceof Double) { System.out.println(\u0026#34;Received Action Request: \u0026#34; + physicalAssetActionWldtEvent.getActionKey() + \u0026#34; with Body: \u0026#34; + physicalAssetActionWldtEvent.getBody()); } else System.err.println(\u0026#34;Wrong Action Received !\u0026#34;); }catch (Exception e){ e.printStackTrace(); } } ","date":"February 9, 2024","id":11,"permalink":"/docs/guides/digital-actions/","summary":"In this demo implementation, we are going to emulate an incoming Digital Action on the Digital Adapter in order to show how it can be handled by the adapter and properly forwarded to the Shadowing Function for validation and the consequent interaction with the Physical Adapter and then with the physical twin.","tags":"","title":"Digital Actions"},{"content":"The same management that we have illustrated for Properties, Events and Action can be applied also to Digital Twin Relationships. Relationships represent the links that exist between the modeled physical assets and other physical entity of the organizations through links to their corresponding Digital Twins. Like properties, relationships can be observed, dynamically created, and change over time, but unlike properties, they are not properly part of the PA\u0026rsquo;s state but of its operational context (e.g., a DT of a robot within a production line).\nIt is necessary to distinguish between two concepts: i) Relationship; and ii) Relationship Instance. The first one models the relationship from a semantic point of view, defining its name and target type. The second one represents an instantiation of the concept in reality. For example, in the context of a Smart Home, the Home Digital Twin (DT) will define a Relationship called has_room which has possible targets represented by DTs that represent different rooms of the house. The actual link between the Home DT and the Bedroom DT will be modeled by a specific Relationship Instance of the has_room relationship.\nWithin the state of the DT, it is necessary to differentiate between the concept of a relationship and that of an instance of a relationship. In the first case, we refer to a semantic concept where each relationship, through its name and the semantic type of its target, determines the different type of link that the DT can establish. On the other hand, an instanc of a relationship represents the concrete link present between the DT that establishes it and the target DT. For instance, in the case of a Smart Home, the Bedroom DT may have two relationships in its model: one named is_room_of and another called has_device. An instance of the first type of relationship could, for example, have the Home DT as its target, while the has_device relationship could have multiple instances, one for each device present in the room. An example of a possible instance is one targeting the Air Conditioner DT.\nFrom an implementation perspective, in the Physical Adapter and in particular where we handle the definition of the PAD we can also specify the existing relationships. In our case, since the Relationship is useful also to define its future instance we keep a reference of the relationship as in internal variable called insideInRelationship.\nThen we can update the code as follows:\nprivate PhysicalAssetRelationship\u0026lt;String\u0026gt; insideInRelationship = null; @Override public void onIncomingPhysicalAction(PhysicalAssetActionWldtEvent\u0026lt;?\u0026gt; physicalAssetActionWldtEvent) { try{ [...] //Create Test Relationship to describe that the Physical Device is inside a building this.insideInRelationship=new PhysicalAssetRelationship\u0026lt;\u0026gt;(\u0026#34;insideId\u0026#34;); pad.getRelationships().add(insideInRelationship); [...] } catch (Exception e){ e.printStackTrace(); } } Of course always in the Physical Adapter we need to publish an effective instance of the definite Relationship. To do that, we have defined a dedicated method that we can call inside the adapter to notify the DT\u0026rsquo;s Core and in particular the Shadowing Function on the presence of a new Relationship.\nThe following method can be added for example at the beginning of the Device Emulation:\nprivate void publishPhysicalRelationshipInstance() { try{ String relationshipTarget = \u0026#34;building-hq\u0026#34;; Map\u0026lt;String, Object\u0026gt; relationshipMetadata = new HashMap\u0026lt;\u0026gt;(); relationshipMetadata.put(\u0026#34;floor\u0026#34;, \u0026#34;f0\u0026#34;); relationshipMetadata.put(\u0026#34;room\u0026#34;, \u0026#34;r0\u0026#34;); PhysicalAssetRelationshipInstance\u0026lt;String\u0026gt; relInstance = this.insideInRelationship.createRelationshipInstance(relationshipTarget, relationshipMetadata); PhysicalAssetRelationshipInstanceCreatedWldtEvent\u0026lt;String\u0026gt; relInstanceEvent = new PhysicalAssetRelationshipInstanceCreatedWldtEvent\u0026lt;\u0026gt;(relInstance); publishPhysicalAssetRelationshipCreatedWldtEvent(relInstanceEvent); }catch (Exception e){ e.printStackTrace(); } } On the other hand, as already done for all the other Properties, Actions and Events we have to handle them on the Shadowing Function and in particular updating the onDigitalTwinBound(...) method managing Relationship declaration. Also for the Relationships there is the method denoted as observePhysicalAssetRelationship(relationship) to observe the variation of the target entity.\n@Override protected void onDigitalTwinBound(Map\u0026lt;String, PhysicalAssetDescription\u0026gt; adaptersPhysicalAssetDescriptionMap) { try{ //Iterate over all the received PAD from connected Physical Adapters adaptersPhysicalAssetDescriptionMap.values().forEach(pad -\u0026gt; { [...] //Iterate over Physical Relationships pad.getRelationships().forEach(relationship -\u0026gt; { try{ if(relationship != null \u0026amp;\u0026amp; relationship.getName().equals(GlobalKeywords.INSIDE_IN_RELATIONSHIP)){ DigitalTwinStateRelationship\u0026lt;String\u0026gt; insideInDtStateRelationship = new DigitalTwinStateRelationship\u0026lt;\u0026gt;(relationship.getName(), relationship.getName()); this.digitalTwinState.createRelationship(insideInDtStateRelationship); observePhysicalAssetRelationship(relationship); } }catch (Exception e){ e.printStackTrace(); } }); }); [...] }catch (Exception e){ e.printStackTrace(); } } When an Instance for a target observed Relationship has been notified by the Physical Adapter, we will receive a call back on the Shadowing Function method called: onPhysicalAssetRelationshipEstablished(PhysicalAssetRelationshipInstanceCreatedWldtEvent\u0026lt;?\u0026gt; physicalAssetRelationshipInstanceCreatedWldtEvent). The object PhysicalAssetRelationshipInstanceCreatedWldtEvent describes the events and contains an object PhysicalAssetRelationshipInstance with all the information about the new Relationship Instance.\nThe Shadowing Function analyzes the instance and create the corresponding Digital Relationship instance on the DT\u0026rsquo;State through the class DigitalTwinStateRelationshipInstance and the method this.digitalTwinState.addRelationshipInstance(relName, instance);. The resulting implemented method is the following:\n//// Physical Relationships Notification Callbacks //// @Override protected void onPhysicalAssetRelationshipEstablished(PhysicalAssetRelationshipInstanceCreatedWldtEvent\u0026lt;?\u0026gt; physicalAssetRelationshipInstanceCreatedWldtEvent) { try{ if(physicalAssetRelationshipInstanceCreatedWldtEvent != null \u0026amp;\u0026amp; physicalAssetRelationshipInstanceCreatedWldtEvent.getBody() != null){ PhysicalAssetRelationshipInstance\u0026lt;?\u0026gt; paRelInstance = physicalAssetRelationshipInstanceCreatedWldtEvent.getBody(); if(paRelInstance.getTargetId() instanceof String){ String relName = paRelInstance.getRelationship().getName(); String relKey = paRelInstance.getKey(); String relTargetId = (String)paRelInstance.getTargetId(); DigitalTwinStateRelationshipInstance\u0026lt;String\u0026gt; instance = new DigitalTwinStateRelationshipInstance\u0026lt;String\u0026gt;(relName, relTargetId, relKey); //Update Digital Twin State //NEW from 0.3.0 -\u0026gt; Start State Transaction this.digitalTwinStateManager.startStateTransaction(); this.digitalTwinStateManager.addRelationshipInstance(instance); //NEW from 0.3.0 -\u0026gt; Commit State Transaction this.digitalTwinStateManager.commitStateTransaction(); } } }catch (Exception e){ e.printStackTrace(); } } @Override protected void onPhysicalAssetRelationshipDeleted(PhysicalAssetRelationshipInstanceDeletedWldtEvent\u0026lt;?\u0026gt; physicalAssetRelationshipInstanceDeletedWldtEvent) { } At the end the new DT\u0026rsquo;s Relationships and the associated instances can be managed on a Digital Adapter using the onDigitalTwinSync(IDigitalTwinState currentDigitalTwinState) method and the following DT state callback method: onStateUpdate().\nFor example a simple implementation logging on the console can be:\n@Override protected void onStateUpdate(DigitalTwinState newDigitalTwinState, DigitalTwinState previousDigitalTwinState, ArrayList\u0026lt;DigitalTwinStateChange\u0026gt; digitalTwinStateChangeList) { // In newDigitalTwinState we have the new DT State System.out.println(\u0026#34;New DT State is: \u0026#34; + newDigitalTwinState); // The previous DT State is available through the variable previousDigitalTwinState System.out.println(\u0026#34;Previous DT State is: \u0026#34; + previousDigitalTwinState); // We can also check each DT\u0026#39;s state change potentially differentiating the behaviour for each change if (digitalTwinStateChangeList != null \u0026amp;\u0026amp; !digitalTwinStateChangeList.isEmpty()) { // Iterate through each state change in the list [...] // Specific log example for Relationships Instance Variation if(resourceType.equals(DigitalTwinStateChange.ResourceType.RELATIONSHIP_INSTANCE)) System.out.println(\u0026#34;New Relationship Instance operation:\u0026#34; + operation + \u0026#34; Resource:\u0026#34; + resource); } } else { // No state changes System.out.println(\u0026#34;No state changes detected.\u0026#34;); } } ","date":"February 9, 2024","id":12,"permalink":"/docs/guides/dt-relationships/","summary":"The same management that we have illustrated for Properties, Events and Action can be applied also to Digital Twin Relationships. Relationships represent the links that exist between the modeled physical assets and other physical entity of the organizations through links to their corresponding Digital Twins.","tags":"","title":"DT Relationships"},{"content":"The WLDT library provides a native method to define Configurable Physical ad Digital Adapters specifying a custom configuration class passed as parameter in the constructor.\nStarting with the Physical Adapter created in the previous example DemoPhysicalAdapter instead of extending the base class PhysicalAdapter we can extend now ConfigurablePhysicalAdapter\u0026lt;C\u0026gt; where C is the name of the that we would like to use as configuration.\nIn our example we can create a simple configuration class called DemoPhysicalAdapterConfiguration where we move the constant variable used to implement the behaviour of our demo physical adapter. The resulting class will be the following:\npublic class DemoPhysicalAdapterConfiguration { private int messageUpdateTime = GlobalKeywords.MESSAGE_UPDATE_TIME; private int messageUpdateNumber = GlobalKeywords.MESSAGE_UPDATE_NUMBER; private double temperatureMinValue = GlobalKeywords.TEMPERATURE_MIN_VALUE; private double temperatureMaxValue = GlobalKeywords.TEMPERATURE_MAX_VALUE; public DemoPhysicalAdapterConfiguration() { } public DemoPhysicalAdapterConfiguration(int messageUpdateTime, int messageUpdateNumber, double temperatureMinValue, double temperatureMaxValue) { this.messageUpdateTime = messageUpdateTime; this.messageUpdateNumber = messageUpdateNumber; this.temperatureMinValue = temperatureMinValue; this.temperatureMaxValue = temperatureMaxValue; } public int getMessageUpdateTime() { return messageUpdateTime; } public void setMessageUpdateTime(int messageUpdateTime) { this.messageUpdateTime = messageUpdateTime; } public int getMessageUpdateNumber() { return messageUpdateNumber; } public void setMessageUpdateNumber(int messageUpdateNumber) { this.messageUpdateNumber = messageUpdateNumber; } public double getTemperatureMinValue() { return temperatureMinValue; } public void setTemperatureMinValue(double temperatureMinValue) { this.temperatureMinValue = temperatureMinValue; } public double getTemperatureMaxValue() { return temperatureMaxValue; } public void setTemperatureMaxValue(double temperatureMaxValue) { this.temperatureMaxValue = temperatureMaxValue; } } Now we can create or update our Physical Adapter extending ConfigurablePhysicalAdapter\u0026lt;DemoPhysicalAdapterConfiguration\u0026gt; as illustrated in the following snippet:\npublic class DemoPhysicalAdapter extends ConfigurablePhysicalAdapter\u0026lt;DemoPhysicalAdapterConfiguration\u0026gt; { [...] } Extending this class also the constructor should be updated getting as a parameter the expected configuration instance. Our constructor will be the following:\npublic DemoConfPhysicalAdapter(String id, DemoPhysicalAdapterConfiguration configuration) { super(id, configuration); } After that change since we removed and moved the used constant values into the new Configuration class we have also to update the deviceEmulation() method having access to the configuration through the method getConfiguration() or this.getConfiguration() directly on the adapter.\nprivate Runnable deviceEmulation(){ return () -\u0026gt; { try { System.out.println(\u0026#34;[DemoPhysicalAdapter] -\u0026gt; Sleeping before Starting Physical Device Emulation ...\u0026#34;); //Sleep 5 seconds to emulate device startup Thread.sleep(10000); System.out.println(\u0026#34;[DemoPhysicalAdapter] -\u0026gt; Starting Physical Device Emulation ...\u0026#34;); //Create a new random object to emulate temperature variations Random r = new Random(); //Publish an initial Event for a normal condition publishPhysicalAssetEventWldtEvent(new PhysicalAssetEventWldtEvent\u0026lt;\u0026gt;(GlobalKeywords.OVERHEATING_EVENT_KEY, \u0026#34;normal\u0026#34;)); //Emulate the generation on \u0026#39;n\u0026#39; temperature measurements for(int i = 0; i \u0026lt; getConfiguration().getMessageUpdateNumber(); i++){ //Sleep to emulate sensor measurement Thread.sleep(getConfiguration().getMessageUpdateTime()); //Update the double randomTemperature = getConfiguration().getTemperatureMinValue() + (getConfiguration().getTemperatureMaxValue() - getConfiguration().getTemperatureMinValue()) * r.nextDouble(); //Create a new event to notify the variation of a Physical Property PhysicalAssetPropertyWldtEvent\u0026lt;Double\u0026gt; newPhysicalPropertyEvent = new PhysicalAssetPropertyWldtEvent\u0026lt;\u0026gt;(GlobalKeywords.TEMPERATURE_PROPERTY_KEY, randomTemperature); //Publish the WLDTEvent associated to the Physical Property Variation publishPhysicalAssetPropertyWldtEvent(newPhysicalPropertyEvent); } //Publish a demo Physical Event associated to a \u0026#39;critical\u0026#39; overheating condition publishPhysicalAssetEventWldtEvent(new PhysicalAssetEventWldtEvent\u0026lt;\u0026gt;(GlobalKeywords.OVERHEATING_EVENT_KEY, \u0026#34;critical\u0026#34;)); } catch (EventBusException | InterruptedException e) { e.printStackTrace(); } }; } A similar approach can be adopted also for the Digital Adapter with the small difference that the base class DigitalAdapter already allow the possibility to specify a configuration. For this reason in the previous example we extended DigitalAdapter\u0026lt;Void\u0026gt; avoiding to specifying a configuration.\nIn this updated version we can create a new DemoDigitalAdapterConfiguration class containing the parameter association to the emulation of the action and then update our adapter to support the new configuration. Our new configuration class will be:\npublic class DemoDigitalAdapterConfiguration { private int sleepTimeMs = GlobalKeywords.ACTION_SLEEP_TIME_MS; private int emulatedActionCount = GlobalKeywords.EMULATED_ACTION_COUNT; private double temperatureMinValue = GlobalKeywords.TEMPERATURE_MIN_VALUE; private double temperatureMaxValue = GlobalKeywords.TEMPERATURE_MAX_VALUE; public DemoDigitalAdapterConfiguration() { } public DemoDigitalAdapterConfiguration(int sleepTimeMs, int emulatedActionCount, double temperatureMinValue, double temperatureMaxValue) { this.sleepTimeMs = sleepTimeMs; this.emulatedActionCount = emulatedActionCount; this.temperatureMinValue = temperatureMinValue; this.temperatureMaxValue = temperatureMaxValue; } public int getSleepTimeMs() { return sleepTimeMs; } public void setSleepTimeMs(int sleepTimeMs) { this.sleepTimeMs = sleepTimeMs; } public int getEmulatedActionCount() { return emulatedActionCount; } public void setEmulatedActionCount(int emulatedActionCount) { this.emulatedActionCount = emulatedActionCount; } public double getTemperatureMinValue() { return temperatureMinValue; } public void setTemperatureMinValue(double temperatureMinValue) { this.temperatureMinValue = temperatureMinValue; } public double getTemperatureMaxValue() { return temperatureMaxValue; } public void setTemperatureMaxValue(double temperatureMaxValue) { this.temperatureMaxValue = temperatureMaxValue; } } After that we can update the declaration of our Digital Adapter and modify its constructor to accept the configuration. The resulting class will be:\npublic class DemoDigitalAdapter extends DigitalAdapter\u0026lt;DemoDigitalAdapterConfiguration\u0026gt; { public DemoDigitalAdapter(String id, DemoDigitalAdapterConfiguration configuration) { super(id, configuration); } [...] } Of course the possibility to have this configuration will allow us to improve the emulateIncomingDigitalAction method in the following way having access to the configuration through the method getConfiguration() or this.getConfiguration() directly on the adapter:\nprivate Runnable emulateIncomingDigitalAction(){ return () -\u0026gt; { try { System.out.println(\u0026#34;[DemoDigitalAdapter] -\u0026gt; Sleeping before Emulating Incoming Digital Action ...\u0026#34;); Thread.sleep(5000); Random random = new Random(); //Emulate the generation on \u0026#39;n\u0026#39; temperature measurements for(int i = 0; i \u0026lt; getConfiguration().getEmulatedActionCount(); i++){ //Sleep to emulate sensor measurement Thread.sleep(getConfiguration().getSleepTimeMs()); double randomTemperature = getConfiguration().getTemperatureMinValue() + (getConfiguration().getTemperatureMaxValue() - getConfiguration().getTemperatureMinValue()) * random.nextDouble(); publishDigitalActionWldtEvent(\u0026#34;set-temperature-action-key\u0026#34;, randomTemperature); } } catch (Exception e) { e.printStackTrace(); } }; } When we have updated both adapters making them configurable we can update our main function in the process that we have previouly device using the updated adapters and passing the configurations:\npublic class DemoDigitalTwin { public static void main(String[] args) { try{ WldtEngine digitalTwinEngine = new WldtEngine(new DemoShadowingFunction(\u0026#34;test-shadowing-function\u0026#34;), \u0026#34;test-digital-twin\u0026#34;); //Default Physical and Digital Adapter //digitalTwinEngine.addPhysicalAdapter(new DemoPhysicalAdapter(\u0026#34;test-physical-adapter\u0026#34;)); //digitalTwinEngine.addDigitalAdapter(new DemoDigitalAdapter(\u0026#34;test-digital-adapter\u0026#34;)); //Physical and Digital Adapters with Configuration digitalTwinEngine.addPhysicalAdapter(new DemoConfPhysicalAdapter(\u0026#34;test-physical-adapter\u0026#34;, new DemoPhysicalAdapterConfiguration())); digitalTwinEngine.addDigitalAdapter(new DemoConfDigitalAdapter(\u0026#34;test-digital-adapter\u0026#34;, new DemoDigitalAdapterConfiguration())); digitalTwinEngine.startLifeCycle(); }catch (Exception e){ e.printStackTrace(); } } } ","date":"February 9, 2024","id":13,"permalink":"/docs/guides/configurable-adapters/","summary":"The WLDT library provides a native method to define Configurable Physical ad Digital Adapters specifying a custom configuration class passed as parameter in the constructor.","tags":"","title":"Configurable Adapters"},{"content":"","date":"February 9, 2024","id":14,"permalink":"/docs/adapters/","summary":"","tags":"","title":"Adapters"},{"content":"The MqttPhysicalAdapter library provides a streamlined solution for efficiently managing physical assets through the MQTT protocol. It offers a range of features, including a versatile builder for effortless configuration of MQTT connections, dedicated classes for handling both incoming and outgoing topics, and a specialized adapter designed for seamless integration with diverse physical assets.\nKey Features:\nBuilder for MQTT Configuration: The library incorporates a flexible builder pattern, enabling users to effortlessly configure the essential parameters of the MQTT connection. This includes specifying the MQTT broker\u0026rsquo;s address, port, and other relevant details to establish a reliable and customizable communication link. Incoming and Outgoing Topic Handling: MqttPhysicalAdapter facilitates the handling of incoming and outgoing topics, crucial for communication between the physical assets and the MQTT broker. The library includes dedicated classes for defining and managing topics, allowing users to efficiently subscribe to incoming data and publish outgoing messages. Adapter for Physical Asset Integration: At the core of the library is a robust adapter designed specifically for integrating with various physical assets. This adapter streamlines the process of connecting and interacting with physical devices, ensuring a smooth and standardized approach to managing asset-related data. In the WLDT library, Physical Adapters has the responsibility to generate and publish the PhysicalAssetDescription (PAD) to describe the capabilities and the characteristics of our object allowing the Shadowing Function to decide how to digitalize its physical counterpart.\nIn the MqttPhysicalAdapter the generation of the PAD (Physical Asset Description) is automatically and internally executed by the adapter itself accordingly to the adapter configuration in terms of MQTT topics and their mapping with DT\u0026rsquo;s properties, events and actions.\nPrerequisites:\nExternal MQTT Broker: The MqttPhysicalAdapter library requires an external MQTT broker for optimal functionality. Users must have access to a reliable MQTT broker to which the adapter can subscribe. This external broker serves as the central communication hub, facilitating the exchange of messages between the adapter and the physical assets. A complete example is provided in the test folder with a complete DT Creation in the TestMain class together with MQTT IoT demo device and a test MQTT consumer.\nWLDT-Core Version Compatibility The correct mapping and compatibility between versions is reported in the following table\nmqtt-physical-adapter wldt-core 0.2.1 wldt-core 0.3.0 wldt-core 0.4.0 0.1.0 âœ… âŒ âŒ 0.1.1 âŒ âœ… âœ… Installation To use MqttPhysicalAdapter in your Java project, you can include it as a dependency using Maven or Gradle.\nMaven \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.github.wldt\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mqtt-physical-adapter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.1.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Gradle implementation \u0026#39;io.github.wldt:mqtt-physical-adapter:0.1.1\u0026#39; Class Structure \u0026amp; Functionalities MqttPhysicalAdapterConfigurationBuilder \u0026amp; Main Methods The MqttPhysicalAdapterConfigurationBuilder is the class used to build the configuration used by the PhysicalAdater and described and implemented through the class MqttPhysicalAdapterConfiguration.\nIn order to create a configuration builder we can use the static method builder() on the MqttPhysicalAdapterConfiguration class:\nMqttPhysicalAdapterConfiguration.builder(); On the builder the available methods that can be used are:\naddPhysicalAssetPropertyAndTopic public \u0026lt;T\u0026gt; MqttPhysicalAdapterConfigurationBuilder addPhysicalAssetPropertyAndTopic(String propertyKey, T initialValue, String topic, Function\u0026lt;String, T\u0026gt; topicFunction) throws MqttPhysicalAdapterConfigurationException Adds a physical asset property and its corresponding MQTT topic to the configuration.\nType Parameter T: The type of the property. propertyKey: The key of the property. initialValue: The initial value of the property. topic: The MQTT topic associated with the property. topicFunction: A function to parse the MQTT topic payload into the property type. Returns: The updated MqttPhysicalAdapterConfigurationBuilder.\nThrows: MqttPhysicalAdapterConfigurationException - If there is a configuration error.\naddPhysicalAssetActionAndTopic public \u0026lt;T\u0026gt; MqttPhysicalAdapterConfigurationBuilder addPhysicalAssetActionAndTopic(String actionKey, String type, String contentType, String topic, Function\u0026lt;T, String\u0026gt; topicFunction) throws MqttPhysicalAdapterConfigurationException Adds a physical asset action and its corresponding MQTT topic to the configuration.\nType Parameter T: The type of the action payload. actionKey: The key of the action. type: The type of the action. contentType: The content type of the action. topic: The MQTT topic associated with the action. topicFunction: A function to convert the action payload into the MQTT topic payload. Returns: The updated MqttPhysicalAdapterConfigurationBuilder.\nThrows: MqttPhysicalAdapterConfigurationException - If there is a configuration error.\naddPhysicalAssetEventAndTopic public \u0026lt;T\u0026gt; MqttPhysicalAdapterConfigurationBuilder addPhysicalAssetEventAndTopic(String eventKey, String type, String topic, Function\u0026lt;String, T\u0026gt; topicFunction) throws MqttPhysicalAdapterConfigurationException Adds a physical asset event and its corresponding MQTT topic to the configuration.\nType Parameter T: The type of the event payload. eventKey: The key of the event. type: The type of the event. topic: The MQTT topic associated with the event. topicFunction: A function to parse the MQTT topic payload into the event payload type. Returns: The updated MqttPhysicalAdapterConfigurationBuilder.\nThrows: MqttPhysicalAdapterConfigurationException - If there is a configuration error.\naddIncomingTopic public MqttPhysicalAdapterConfigurationBuilder addIncomingTopic(DigitalTwinIncomingTopic topic, List\u0026lt;PhysicalAssetProperty\u0026lt;?\u0026gt;\u0026gt; properties, List\u0026lt;PhysicalAssetEvent\u0026gt; events) throws MqttPhysicalAdapterConfigurationException This method is used when multiple properties or events can be associated to a single MQTT topic on the physical device. It adds a DigitalTwinIncomingTopic describing the topic where the DT will receive the data along with its related lists of properties and events associated to that topic.\ntopic: The DigitalTwinIncomingTopic to be added. properties: The list of related physical asset properties. events: The list of related physical asset events. Returns: The updated MqttPhysicalAdapterConfigurationBuilder.\nThrows: MqttPhysicalAdapterConfigurationException - If there is a configuration error.\naddOutgoingTopic public MqttPhysicalAdapterConfigurationBuilder addOutgoingTopic(String actionKey, String type, String contentType, DigitalTwinOutgoingTopic topic) throws MqttPhysicalAdapterConfigurationException Adds a DigitalTwinOutgoingTopic to the configuration.\nactionKey: The key of the associated action. type: The type of the associated action. contentType: The content type of the associated action. topic: The DigitalTwinOutgoingTopic to be added. Returns: The updated MqttPhysicalAdapterConfigurationBuilder.\nThrows: MqttPhysicalAdapterConfigurationException - If there is a configuration error.\nAdditional Methods setConnectionTimeout(Integer connectionTimeout): Sets the connection timeout for the MQTT client. Returns the builder for method chaining. Throws MqttPhysicalAdapterConfigurationException if the provided timeout is invalid. setCleanSessionFlag(boolean cleanSession): Sets the clean session flag for the MQTT client. Returns the builder for method chaining. setAutomaticReconnectFlag(boolean automaticReconnect): Sets the automatic reconnect flag for the MQTT client. Returns the builder for method chaining. setMqttClientPersistence(MqttClientPersistence persistence): Sets the persistence for the MQTT client. Returns the builder for method chaining. Throws MqttPhysicalAdapterConfigurationException if the provided persistence is null. build(): Builds and returns the finalized MqttPhysicalAdapterConfiguration object. Throws MqttPhysicalAdapterConfigurationException if the configuration is incomplete or invalid. MqttPhysicalAdapter The MqttPhysicalAdapter class is the core component for interacting with physical assets. Instantiate it with a unique ID and the configuration. It extends the default WLDT Library PhysicalAdapter implementing all the functionalities to automatically interact with an MQTT physical device following the specifications and details provided in the MqttPhysicalAdapterConfiguration and built using MqttPhysicalAdapterConfigurationBuilder.\nAn example of its creation is:\nMqttPhysicalAdapter mqttPhysicalAdapter = new MqttPhysicalAdapter(\u0026#34;uniqueId\u0026#34;, configuration); Integrated Example This example demonstrates the integration of a MqttPhysicalAdapter within a Digital Twin setup, where multiple adapters (including a console adapter) are added to a Digital Twin, and the overall system is managed by a DigitalTwinEngine.\n// Create a Digital Twin with a default shadowing function DigitalTwin digitalTwin = new DigitalTwin(\u0026#34;mqtt-digital-twin\u0026#34;, new DefaultShadowingFunction()); // Create an instance of ConsoleDigitalAdapter ConsoleDigitalAdapter consoleDigitalAdapter = new ConsoleDigitalAdapter(); // Create an instance of MqttPhysicalAdapterConfiguration MqttPhysicalAdapterConfiguration config = MqttPhysicalAdapterConfiguration.builder(\u0026#34;127.0.0.1\u0026#34;, 1883) .addPhysicalAssetPropertyAndTopic(\u0026#34;intensity\u0026#34;, 0, \u0026#34;sensor/intensity\u0026#34;, Integer::parseInt) .addIncomingTopic(new DigitalTwinIncomingTopic(\u0026#34;sensor/state\u0026#34;, getSensorStateFunction()), createIncomingTopicRelatedPropertyList(), new ArrayList\u0026lt;\u0026gt;()) .addPhysicalAssetEventAndTopic(\u0026#34;overheating\u0026#34;, \u0026#34;text/plain\u0026#34;, \u0026#34;sensor/overheating\u0026#34;, Function.identity()) .addPhysicalAssetActionAndTopic(\u0026#34;switch-off\u0026#34;, \u0026#34;sensor.actuation\u0026#34;, \u0026#34;text/plain\u0026#34;, \u0026#34;sensor/actions/switch\u0026#34;, actionBody -\u0026gt; \u0026#34;switch\u0026#34; + actionBody) .build(); // Create an instance of the MQTT Physical Adapter using the defined configuration MqttPhysicalAdapter mqttPhysicalAdapter = new MqttPhysicalAdapter(\u0026#34;test-mqtt-pa\u0026#34;, config); // Add both Digital and Physical Adapters to the Digital Twin digitalTwin.addDigitalAdapter(consoleDigitalAdapter); digitalTwin.addPhysicalAdapter(mqttPhysicalAdapter); // Create the Digital Twin Engine DigitalTwinEngine digitalTwinEngine = new DigitalTwinEngine(); // Add the Digital Twin to the Engine digitalTwinEngine.addDigitalTwin(digitalTwin); // Start all the Digital Twins registered on the engine digitalTwinEngine.startAll(); In this example the createIncomingTopicRelatedPropertyList() used to map properties and events associated to a single topic is the following:\nprivate static List\u0026lt;PhysicalAssetProperty\u0026lt;?\u0026gt;\u0026gt; createIncomingTopicRelatedPropertyList(){ List\u0026lt;PhysicalAssetProperty\u0026lt;?\u0026gt;\u0026gt; properties = new ArrayList\u0026lt;\u0026gt;(); properties.add(new PhysicalAssetProperty\u0026lt;\u0026gt;(\u0026#34;temperature\u0026#34;, 0)); properties.add(new PhysicalAssetProperty\u0026lt;\u0026gt;(\u0026#34;humidity\u0026#34;, 0)); return properties; } This information are used by the adapter to build the PAD describe the capabilities and the characteristics of our object allowing the Shadowing Function to decide how to digitalize its physical counterpart.\n","date":"February 9, 2024","id":15,"permalink":"/docs/adapters/mqtt-physical-adapter/","summary":"The MqttPhysicalAdapter library provides a streamlined solution for efficiently managing physical assets through the MQTT protocol. It offers a range of features, including a versatile builder for effortless configuration of MQTT connections, dedicated classes for handling both incoming and outgoing topics, and a specialized adapter designed for seamless integration with diverse physical assets.","tags":"","title":"MQTT Physical Adapter"},{"content":"","date":"February 9, 2024","id":16,"permalink":"/docs/change-logs/","summary":"","tags":"","title":"Change Logs"},{"content":"The storage layer has been integrated into the core WLDT library, enabling Digital Twins to manually and automatically store data related to the evolution of their state, generated events (as illustrated in DT Events Page), and any variations involving properties, events, actions, relationships, and life cycle.\nThe WLDT Storage Layer consists of two main components:\nStorage Manager: This is the central component of the storage system, facilitating the structured and modular storage and retrieval of information. It allows developers to create and utilize various storage systems (e.g., in-memory, file-based, or DBMS) simultaneously. The Storage Layer is accessible in both read and write modes internally by the DT\u0026rsquo;s Model, and in read-only mode via the Query System by Digital Adapters. Query System: To delegate and encapsulate the responsibility of data storage within the DT\u0026rsquo;s model, a query system has been integrated. This system enables Digital Adapters to retrieve stored data and expose it according to their specific logic and implementation. The storage layer is designed for easy extension, allowing developers to create and share new storage layers (e.g., using Redis, MySQL, or MongoDB). The provided in-memory implementation serves only for basic development and testing purposes. Similarly, the Query Manager can be extended and customized by developers to implement additional query management features or to enhance the default functionalities provided by the library.\nStorage Manager The main module of the Storage Layer is the one associated to Storage Capabilities and it is composed by two main classes: StorageManager and WldStorage with the following characteristics and main methods:\nStorageManager: The StorageManager class is a class that represents the storage manager for a DigitalTwin. It is responsible for managing the storage of the data related to the DigitalTwin. It is an observer of the WldtEventBus, and it is able to save the data in the available storages. The class extends a DigitalTwinWorker, in order to allow the component to work in a structure and integrated way on a different thread that the core of a DT can coordinate starting and stopping it when required. The manager allow the usage of different storage systems at the same time in order to allow the developers to memorize the information accordingly to their need in the right storage system at the same time (e.g., REDIS for quick cached information and MongDB for historical data). Main associated methods are: putStorage(WldtStorage storage): Add a new WldtStorage to the StorageManager getStorageIdList(): Returns the list of id of the WldtStorage in the StorageManager isStorageAvailable(String storageId): Checks if a target Storage Id is available in the Storage Manager getStorage(String storageId): Get the target WldtStorage by id from the Storage Manager removeStorage(String storageId): Remove an existing WldtStorage by id from the StorageManager WldtStorage: Defines an abstract class allowing the Digital Twin developer to implement its internal storage system for the Digital Twin instance. The class defines methods for the management of: Digital Twin State storage and retrieval with the associated change list; Generated State Digital Events; Life Cycle State storage and retrieval; Physical Asset Description storage and retrieval; Physical Asset Property Variation storage and retrieval; Physical Asset Relationship Instance storage and retrieval; Digital Action Request storage and retrieval; Physical Asset Action Request storage and retrieval; Physical Asset Event Notification storage and retrieval; Each WldtStorage instance can be configured (using the right constructor method) to: Observe all Wldt events (stateEvents, physicalAssetEvents, physicalAssetActionEvents, physicalAssetDescriptionEvents, digitalActionEvents, lifeCycleEvents) Filter only for specific class of events Once the WldtStorage has been properly configured to receive target events the StorageManager automatically save information of interest for that specific storage. For example we can have a StorageA (e.g, REDIS) configured to receive all the generated events and a StorageB (e.g., MongoDB) in charge of saving only DT\u0026rsquo;s state variation over time. The default implementation of the WldtStorage is the class DefaultWldtStorage. This class provides a simple storage solution for digital twin states, digital twin state changes, physical asset events, and digital twin events. The class provides ONLY a memory based approach for storage using ArrayLists and HashMaps and more advanced solution should be implemented for production oriented Digital Twins for examples using external storage and memorization solutions. Each Record written and returned by methods available through the WldtStorage implementations are extension of the StorageRecord used to represents a single record in the storage with a unique id Methods available and implemented by WldtStorage implementations are the following grouped by categories: Digital Twin State: saveDigitalTwinState(DigitalTwinState digitalTwinState, List\u0026lt;DigitalTwinStateChange\u0026gt; digitalTwinStateChangeList): Save a new computed instance of the DT State in the Storage together with the list of the changes with respect to the previous state getLastDigitalTwinState(): Returns the latest computed Digital Twin State of the target Digital Twin instance getDigitalTwinStateCount(): Returns the number of computed and stored Digital Twin States getDigitalTwinStateInTimeRange(long startTimestampMs, long endTimestampMs): Retrieves a list of DigitalTwinState objects within the specified time range getDigitalTwinStateInRange(int startIndex, int endIndex): Retrieves a list of Digital Twin states within the specified range of indices Digital Twin State Event Notification: saveDigitalTwinStateEventNotification(DigitalTwinStateEventNotification\u0026lt;?\u0026gt; digitalTwinStateEventNotification): Save the Digital Twin State Event Notification getDigitalTwinStateEventNotificationCount(): Get the number of Digital Twin State Event Notification getDigitalTwinStateEventNotificationInTimeRange(long startTimestampMs, long endTimestampMs): Get the Digital Twin State Event Notification in the specified time range getDigitalTwinStateEventNotificationInRange(int startIndex, int endIndex): Get the Digital Twin State Event Notification in the specified range of indices Life Cycle State Variation: saveLifeCycleState(LifeCycleStateVariation lifeCycleStateVariation): Save the LifeCycleState of the Digital Twin getLastLifeCycleState(): Get the last LifeCycleState of the Digital Twin getLifeCycleStateCount(): Get the number of LifeCycleState of the Digital Twin getLifeCycleStateInTimeRange(long startTimestampMs, long endTimestampMs): Get the last LifeCycleState of the Digital Twin getLifeCycleStateInRange(int startIndex, int endIndex): Get the LifeCycleState of the Digital Twin in the specified range of indices Physical Asset Event Notification: savePhysicalAssetEventNotification(PhysicalAssetEventNotification physicalAssetEventNotification): Save the Physical Asset Event Notification getPhysicalAssetEventNotificationCount(): Get the number of Physical Asset Event Notification getPhysicalAssetEventNotificationInTimeRange(long startTimestampMs, long endTimestampMs): Get the Physical Asset Event Notification in the specified time range getPhysicalAssetEventNotificationInRange(int startIndex, int endIndex): Get the Physical Asset Event Notification in the specified range of indices Physical Action Request: savePhysicalAssetActionRequest(PhysicalAssetActionRequest physicalAssetActionRequest): Save Physical Asset Action Request getPhysicalAssetActionRequestCount(): Get the number of Physical Asset Action Request getPhysicalAssetActionRequestInTimeRange(long startTimestampMs, long endTimestampMs): Get the Physical Asset Action Request in the specified time range getPhysicalAssetActionRequestInRange(int startIndex, int endIndex): Get the Physical Asset Action Request in the specified range of indices Digital Action Request: saveDigitalActionRequest(DigitalActionRequest digitalActionRequest): Save a Digital Action Request getDigitalActionRequestCount(): Get the number of Digital Action Request Stored getDigitalActionRequestInTimeRange(long startTimestampMs, long endTimestampMs): Get the Digital Action Request in the specified time range getDigitalActionRequestInRange(int startIndex, int endIndex): Get the Digital Action Request in the specified range of indices Physical Asset Description (PAD) Notification New PAD Notification saveNewPhysicalAssetDescriptionNotification(PhysicalAssetDescriptionNotification physicalAssetDescriptionNotification): Save a new Physical Asset Description Available getNewPhysicalAssetDescriptionNotificationCount(): Get the number of New Physical Asset Description Notifications available getNewPhysicalAssetDescriptionNotificationInTimeRange(long startTimestampMs, long endTimestampMs): Get the New Physical Asset Description Available in the specified time range getNewPhysicalAssetDescriptionNotificationInRange(int startIndex, int endIndex): Get the New Physical Asset Description Available in the specified range of indices Updated PAD Notification saveUpdatedPhysicalAssetDescriptionNotification(PhysicalAssetDescriptionNotification physicalAssetDescriptionNotification): Save the updated Physical Asset Description Notification getUpdatedPhysicalAssetDescriptionNotificationCount(): Get the number of Updated Physical Asset Description getUpdatedPhysicalAssetDescriptionNotificationInTimeRange(long startTimestampMs, long endTimestampMs): Get the Updated Physical Asset Description in the specified time range getUpdatedPhysicalAssetDescriptionNotificationInRange(int startIndex, int endIndex): Get the Updated Physical Asset Description in the specified range of indices Physical Asset Property Variation: savePhysicalAssetPropertyVariation(PhysicalAssetPropertyVariation physicalAssetPropertyVariation): Save the Physical Asset Property Variation getPhysicalAssetPropertyVariationCount(): Get the number of Physical Asset Property Variation getPhysicalAssetPropertyVariationInTimeRange(long startTimestampMs, long endTimestampMs): Get the Physical Asset Property Variation in the specified time range getPhysicalAssetPropertyVariationInRange(int startIndex, int endIndex): Get the Physical Asset Property Variation in the specified range of indices Physical Asset Relationship Instance Notification Created Relationship Instance savePhysicalAssetRelationshipInstanceCreatedNotification(PhysicalRelationshipInstanceVariation physicalRelationshipInstanceVariation): Save the Physical Asset Relationship Instance Created Event getPhysicalAssetRelationshipInstanceCreatedNotificationCount(): Get the number of Physical Asset Relationship Instance Created Event getPhysicalAssetRelationshipInstanceCreatedNotificationInTimeRange(long startTimestampMs, long endTimestampMs): Get the Physical Asset Relationship Instance Created Event in the specified time range getPhysicalAssetRelationshipInstanceCreatedNotificationInRange(int startIndex, int endIndex): Get the Physical Asset Relationship Instance Created Event in the specified range of indices Deleted Relationship Instance savePhysicalAssetRelationshipInstanceDeletedNotification(PhysicalRelationshipInstanceVariation physicalRelationshipInstanceVariation): Save the Physical Asset Relationship Instance Updated Event getPhysicalAssetRelationshipInstanceDeletedNotificationCount(): Get the number of Physical Asset Relationship Instance Updated Event getPhysicalAssetRelationshipInstanceDeletedNotificationInTimeRange(long startTimestampMs, long endTimestampMs): Get the Physical Asset Relationship Instance Updated Event in the specified time range getPhysicalAssetRelationshipInstanceDeletedNotificationInRange(int startIndex, int endIndex): Get the Physical Asset Relationship Instance Updated Event in the specified range of indices Storage Statistics: Retrieve and returns storage statistics in terms of the number of stored records for each type and the associated time range of the stored records (start and end timestamp in milliseconds). Storage Statistics are mapped and modeled using the classes StorageStats and StorageStatsRecord. Storage Manager Code Some examples of usage for the Storage Layer are the following:\nLets\u0026rsquo; create a new Digital Twin with a single Storage in charge of automatically observe and store all the event generated and going through the target DT instance\n// Create the Digital Twin Engine DigitalTwinEngine digitalTwinEngine = new DigitalTwinEngine(); // Create a new Digital Twin with a Demo Shadowing Function DigitalTwin digitalTwin = new DigitalTwin(TEST_DIGITAL_TWIN_ID, new DemoShadowingFunction()); // Physical Adapter Configuration DemoPhysicalAdapter physicalAdapter = new DemoPhysicalAdapter(...); digitalTwin.addPhysicalAdapter(physicalAdapter); // Digital Adapter Configuration digitalAdapter = new DemoDigitalAdapter(...); digitalTwin.addDigitalAdapter(digitalAdapter); // Create a new WldtStorage instance using the default implementation and observing all the events DefaultWldtStorage myStorage = new DefaultWldtStorage(\u0026#34;test_storage\u0026#34;, true); // Add the new Default Storage Instance to the Digital Twin Storage Manager digitalTwin.getStorageManager().putStorage(myStorage); // Add the Twin to the Engine digitalTwinEngine.addDigitalTwin(digitalTwin); // Start the Digital Twin digitalTwinEngine.startDigitalTwin(TEST_DIGITAL_TWIN_ID); Now let\u0026rsquo;s suppose to have two additional implementation of the WldtStorage class supporting Redis and MongDB and called RedisWldtStorage and MongoDbWldtStorage. We would like to use Redis to automatically observe all the events and MongoDb only to store DT\u0026rsquo;s state and life cycle variations.\n[...] // Create a new RedisWldtStorage instance using the default implementation and observing all the events RedisWldtStorage myRedisStorage = new RedisWldtStorage(\u0026#34;redis_storage\u0026#34;, true); myRedisStorage.setRedisConfiguration(myRedisConfiguration); // Add the new Redis Storage Instance to the Digital Twin Storage Manager digitalTwin.getStorageManager().putStorage(myRedisStorage); // Create a new MongoDbWldtStorage instance using the default implementation and observing only State and LifeCycle Events MongoDbWldtStorage myMongoDbStorage = new MongoDbWldtStorage(\u0026#34;mongo_db_storage\u0026#34;, true, false, false, false, false, true); myMongoDbStorage.setMongoDbConfiguration(myMongoDbConfiguration); // Add the new MongoDb Storage Instance to the Digital Twin Storage Manager digitalTwin.getStorageManager().putStorage(myRedisStorage); [...] Within the ShadowingFunction it is possible to have the reference to the StorageManager in order to access available Storage in both reading and writing mode. This is an example of how to retrieve an available WldtStorage through its id and the use it to read Properties values in a time range of the last 5 minutes:\nString TARGET_STORAGE_ID = \u0026#34;test_storage\u0026#34;; if(this.storageManager.isStorageAvailable(TARGET_STORAGE_ID)){ // Access the Storage Manager to store the last value of the property WldtStorage targetStorage = this.storageManager.getStorage(TARGET_STORAGE_ID); // Get the current time in milliseconds long endTime = System.currentTimeMillis(); // Get the Time in the last 5 minutes long startTime = endTime - (5 * 60 * 1000); // Get the last Physical Asset Action Request in the last 5 minutes List\u0026lt;PhysicalAssetPropertyVariationRecord\u0026gt; propertyVariationRecords = targetStorage.getPhysicalAssetPropertyVariationInTimeRange(startTime, endTime); for(PhysicalAssetPropertyVariationRecord propertyVariationRecord : propertyVariationRecords){ logger.info(\u0026#34;Property Variation Record: {}\u0026#34;, propertyVariationRecord); [...] } } Note: The StorageManager, as previously described, can automatically store DT-related events based on the configuration and setup of each WldtStorage instance added to the manager. However, since the ShadowingFunction has direct access to the StorageManager in both read and write modes, manual handling of data storage is also possible. To achieve this, you can disable automatic storage by setting it to false for specific event types or for all event types. This allows you to manually manage the storage of information within the ShadowingFunction.\nCustom Storage As previously mentioned, the class WldtStorage is an abstract class allowing the developer to implement its internal storage system for the Digital Twin instance. The class defines a set of abstract methods that should be implemented by the developer to shape the management of reading and writing data from and to the target Storage and associated to the identified variations and changes:\nDigital Twin State Generated State Digital Events Life Cycle State Physical Asset Description Physical Asset Property Variation Physical Asset Relationship Instance Digital Action Request Physical Asset Action Request Physical Asset Event Notification Storage Statistics According to the type of the managed resource the type of queries can be characterized in terms of:\nTime Query: Returns available records in a time range made by a start time in ms and and end time in ms Index Query: Returns available records in a index range made a start and end index Last Value Query: Return the last available value for the target resource Count Query: Returns the number of element of that specific resource All the stored and retrieve information and record as mapped into dedicated classes available in the package storage.model and associated to the different type of managed resources: digital, lifecycle, physical, state. Each record class extends the base class StorageRecord.\nA default Storage module denoted as DefaultWldtStorage is natively available in the library providing a simple in-memory storage solution but a developer can implement its own Storage module (e.g., to enable the support for MongoDb or REDIS).\nIn order to implement its own storage module the developer should extend the basic abstract class WldtStorage and implement all the supported method to handle data writing and reading. These new classes can extend also the constructor and the required information for example to handle and manager storage configuration (e.g., ip address and port of the storage system or the local folder where tha stored file should be written).\nQuery System Given the library\u0026rsquo;s goal of maximizing modularity and decoupling responsibilities among the available components, the Query System has been introduced. This system allows components external to the core responsibilities of the Digital Twin (e.g., Digital Adapters and Augmentation Functions) to retrieve stored data and use or expose it according to their specific logic and implementation. For instance, an HTTP Digital Adapter could expose stored information about a DT\u0026rsquo;s state variations over time, or a Monitoring Adapter could use available storage instances to retrieve events for a deeper understanding of the target DT instance\u0026rsquo;s behavior. The query system has been implemented entirely through dedicated events in order to maximize the decoupling of the solution and and supports at the same time both synchronous and asynchronous queries.\nThe main classes associated to the Query System are the following:\nQueryManager: This class represents the Query Manager responsible to handle the query request and manage the query execution and has been designed to be extended by the user to implement the desired query management logic (e.g., as with the DefaultQueryManager). QueryRequest: The class contains all the information needed to perform a query on the storage system QueryRequestType: This Enum represents the Query Request Type used to specify the type of query to be performed on the storage system supporting: TIME_RANGE SAMPLE_RANGE LAST_VALUE COUNT QueryResourceType: This Enum represents the Query Resource Type used to specify the type of resource to be queried on the storage system supporting the following resource types mapping those available and managed by the storage manager (and the supported and associated RequestType): PHYSICAL_ASSET_PROPERTY_VARIATION TIME_RANGE SAMPLE_RANGE COUNT PHYSICAL_ASSET_EVENT_NOTIFICATION TIME_RANGE SAMPLE_RANGE COUNT PHYSICAL_ACTION_REQUEST TIME_RANGE SAMPLE_RANGE COUNT DIGITAL_ACTION_REQUEST TIME_RANGE SAMPLE_RANGE COUNT DIGITAL_TWIN_STATE TIME_RANGE SAMPLE_RANGE COUNT LAST_VALUE NEW_PAD_NOTIFICATION TIME_RANGE SAMPLE_RANGE COUNT UPDATED_PAD_NOTIFICATION TIME_RANGE SAMPLE_RANGE COUNT PHYSICAL_RELATIONSHIP_INSTANCE_CREATED_NOTIFICATION TIME_RANGE SAMPLE_RANGE COUNT PHYSICAL_RELATIONSHIP_INSTANCE_DELETED_NOTIFICATION TIME_RANGE SAMPLE_RANGE COUNT LIFE_CYCLE_EVENT TIME_RANGE SAMPLE_RANGE COUNT LAST_VALUE STORAGE_STATS LAST_VALUE QueryExecutor: This class represents the Query Executor used to execute queries on the storage system supporting both synchronous and asynchronous query execution. Internally is implemented through an event-based mechanism to handle the query request and response QueryResult: This class represents the Query Result returned by the Query Executor containing the query results and the query status (successful or not) and error message (if any) together with also the original request IQueryResultListener: This interface represents the Query Result Listener used to receive the query results Query System Code An example of Synchronous query is:\nQueryExecutor queryExecutor = new QueryExecutor(TEST_DIGITAL_TWIN_ID, \u0026#34;query-executor\u0026#34;); // Create Query Request to the Storage Manager for the Last Digital Twin State QueryRequest queryRequest = new QueryRequest(); queryRequest.setResourceType(QueryResourceType.DIGITAL_TWIN_STATE); queryRequest.setRequestType(QueryRequestType.LAST_VALUE); // Send the Query Request to the Storage Manager for the target DT QueryResult\u0026lt;?\u0026gt; queryResult = queryExecutor.syncQueryExecute(queryRequest); Following the same approach an Asynchrounouse query can be executed as follows:\nQueryExecutor queryExecutor = new QueryExecutor(TEST_DIGITAL_TWIN_ID, \u0026#34;query-executor\u0026#34;); // Create Query Request to the Storage Manager for the Last Digital Twin State QueryRequest queryRequest = new QueryRequest(); queryRequest.setResourceType(QueryResourceType.DIGITAL_TWIN_STATE); queryRequest.setRequestType(QueryRequestType.LAST_VALUE); // Send the Query Request to the Storage Manager for the target DT queryExecutor.asyncQueryExecute(queryRequest, new IQueryResultListener() { @Override public void onQueryResult(QueryResult\u0026lt;?\u0026gt; queryResult) { [...] } }); The class DigitalAdapter has been updated adding also an internal reference to a QueryExecutor in order to simplify the interaction with the query system directly from an adapter like in the following example where we use the query Executor of the Digital Adapter invokeAction callback through its internal variable accessible through this.queryExecutor without creating a new executor:\npublic \u0026lt;T\u0026gt; void invokeAction(String actionKey, T body){ try { // Create Query Request to the Storage Manager for the Last Digital Twin State QueryRequest queryRequest = new QueryRequest(); queryRequest.setResourceType(QueryResourceType.DIGITAL_TWIN_STATE); queryRequest.setRequestType(QueryRequestType.LAST_VALUE); // Send the Query Request to the Storage Manager for the target DT QueryResult\u0026lt;?\u0026gt; queryResult = this.queryExecutor.syncQueryExecute(queryRequest); // Do Something with the Query Result for(Object result : queryResult.getResults()){ // Check the type of the Resulting class accordingly to the query if(result instanceof DigitalTwinState) logger.info(\u0026#34;LAST DT STATE: {}\u0026#34;, result); else logger.error(\u0026#34;INVALID RESULT TYPE: {}\u0026#34;, result.getClass().getName()); } logger.info(\u0026#34;INVOKING ACTION: {} BODY: {}\u0026#34;, actionKey, body); publishDigitalActionWldtEvent(actionKey, body); } catch (EventBusException e) { e.printStackTrace(); } } Custom Query Manager The class in charge of managing an incoming query is called QueryManager and it is characterized by two core methods:\nhandleQuery(QueryRequest queryRequest, Map\u0026lt;String, WldtStorage\u0026gt; storageMap): Handle Query Request allowing its management through the storage map and the associated storage objects. Uses the method getTargetStorage to select the target storage to be used to handle the query. getTargetStorage(QueryRequest queryRequest, Map\u0026lt;String, WldtStorage\u0026gt; storageMap): The method has been designed to return the desired storage object from the storage map to be used for the query management starting from the target QueryRequest and the StorageMap of the DT. In the default implementation, the method returns the first storage object available in the storage map. The QueryManager class has a list of methods that structure the type of available queries and that return an instance of QueryResult with an error and a message of \u0026ldquo;Query not supported by the current implementation !\u0026rdquo;. The list of these methods is the following:\nhandleLifeCycleEventQuery(...): Handle Life Cycle Event Query Request handlePhysicalRelationshipInstanceDeletedNotificationQuery(...): Handle Physical Relationship Instance Deleted Notification Query Request handlePhysicalRelationshipInstanceCreatedNotificationQuery(...): Handle Physical Relationship Instance Created Notification Query Request handleUpdatedPadNotification(...): Handle Updated Pad Notification Query Request handleNewPadNotification(...): Handle New Pad Notification Query Request handleDigitalActionRequestQuery(...): Handle Digital Action Request Query Request handlePhysicalActionRequestQuery(...): Handle Physical Action Request Query Request handlePhysicalAssetEventNotificationQuery(...): Handle Physical Asset Event Notification Query Request handlePhysicalAssetPropertyVariationQuery(...): Handle Physical Asset Property Variation Query Request handleStateQuery(...): Handle Digital Twin State Query Request handleStorageStatsQuery(...): Handle Storage Stats Query The library provides a default implementation that is ready to use and automatically activated in every DT instance and called DefaultQueryManager. This class extends the QueryManager class and implements the default behavior for the query management implementing each of the previous listed methods. In the default implementation the method getTargetStorage returns the first storage object available in the storage map. The behavior can be changed by overriding the method in the custom query manager implementation. In the custom implementation, the method can be used to select different storage according to the query.\nIn order to extend and customize the adopter QueryManager a developer can:\nCreate a new Class extending the QueryManager Implement (if required) a custom getTargetStorage method to return the correct available storage according to the type of request (e.g., the State of the DT are stored on MongoDB while the variation of the Physical Asset on REDIS) If required the developer can implement o change the behavior of the query manager in terms of the query management methods One a custom QueryManager has been defined it can be set and configured through the following method setQueryManager on the StorageManager of each Digital Twin:\ndigitalTwin.getStorageManager().setQueryManager(myQueryManager); ","date":"August 29, 2024","id":17,"permalink":"/docs/guides/storage-layer/","summary":"The storage layer has been integrated into the core WLDT library, enabling Digital Twins to manually and automatically store data related to the evolution of their state, generated events (as illustrated in DT Events Page), and any variations involving properties, events, actions, relationships, and life cycle.","tags":"","title":"Storage Layer"},{"content":"The MqttDigitalAdapter,\nMqttDigitalAdapterConfiguration, and MqttDigitalAdapterConfigurationBuilder classes and guides you through using these classes to set up an MQTT Digital Adapter within WLDT.\nRequires an external MQTT broker to send messages.\nMain functionalities are:\nManages the interaction between the Digital Twin and external systems. Handles state updates, events, and property changes. Dynamic configuration of the MqttDigitalAdapter with broker details, topics, and other settings. Allows customization of data and payload management associated to MQTT topics for properties, events, and actions. Prerequisites:\nExternal MQTT Broker: The MqttDigitalAdapter library requires an external MQTT broker for optimal functionality and communication. Users must have access to a reliable MQTT broker to which the adapter can subscribe and publish. This external broker serves as the central communication hub, facilitating the exchange of messages between the adapter and digital applications A complete example is provided in the test folder with a complete DT Creation in the TestMain class together with MQTT IoT demo device and a test MQTT consumer.\nWLDT-Core Version Compatibility The correct mapping and compatibility between versions is reported in the following table\nmqtt-digital-adapter wldt-core 0.2.1 wldt-core 0.3.0 wldt-core 0.4.0 0.1.0 âœ… âŒ âŒ 0.1.1 âŒ âœ… âœ… Installation To use MqttDigitalAdapter in your Java project, you can include it as a dependency using Maven or Gradle.\nMaven \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.github.wldt\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mqtt-digital-adapter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.1.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Gradle implementation \u0026#39;io.github.wldt:mqtt-digital-adapter:0.1.1\u0026#39; Class Structure \u0026amp; Functionalities MqttDigitalAdapterConfiguration MqttDigitalAdapterConfiguration is a crucial class in the Digital Twin library, allowing developers to configure the behavior of the MQTT Digital Adapter. It provides a flexible and customizable way to set up MQTT communication parameters, topics for properties, events, and actions.\nKey functionalities and exposed capabilities:\nBroker Configuration brokerAddress and brokerPort: Set the MQTT broker\u0026rsquo;s address and port. username and password: Set optional credentials for connecting to the broker. Client Configuration clientId: Unique identifier for the MQTT client. cleanSessionFlag: Flag indicating whether the client starts with a clean session. connectionTimeout: Maximum time to wait for the connection to the MQTT broker. MQTT Client Persistence persistence: Configurable persistence for the MQTT client\u0026rsquo;s data. Reconnect Configuration: automaticReconnectFlag: Flag enabling or disabling automatic reconnection. Topic Configuration: propertyUpdateTopics: Map of property update topics. eventNotificationTopics: Map of event notification topics. actionIncomingTopics: Map of incoming action topics. Builder Methods: builder: Static method to start building a new configuration. addPropertyTopic: Add a property topic with specified parameters. addEventNotificationTopic: Add an event notification topic. addActionTopic: Add an action topic. setConnectionTimeout: Set the connection timeout. setCleanSessionFlag: Set the clean session flag. setAutomaticReconnectFlag: Set the automatic reconnect flag. setMqttClientPersistence: Set the MQTT client persistence. build: Finalize the configuration and build the instance. MqttDigitalAdapterConfigurationBuilder The MqttDigitalAdapterConfigurationBuilder is a powerful tool designed to simplify the process of constructing configurations for the MQTT Digital Adapter in the Digital Twin library. It offers a fluent and intuitive interface, allowing developers to define various aspects of MQTT communication seamlessly.\nBuilder Instantiation The builder is instantiated by providing essential parameters like brokerAddress and brokerPort or including an optional clientId\nMqttDigitalAdapterConfigurationBuilder builder = MqttDigitalAdapterConfiguration.builder(\u0026#34;127.0.0.1\u0026#34;, 1883); Adding Property Topics Developers can add property topics with specific configurations, such as the key, topic, QoS level, and a function to convert property values to payload.\nbuilder.addPropertyTopic(\u0026#34;energy\u0026#34;, \u0026#34;dummy/properties/energy\u0026#34;, MqttQosLevel.MQTT_QOS_0, value -\u0026gt; String.valueOf(((Double)value).intValue())); Adding Event Notification Topics Event notification topics are easily added, including event keys, topics, QoS levels, and payload conversion functions.\nbuilder.addEventNotificationTopic(\u0026#34;overheating\u0026#34;, \u0026#34;dummy/events/overheating/notifications\u0026#34;, MqttQosLevel.MQTT_QOS_0, Object::toString); Adding Action Topics Developers can include action topics with key, topic, and a function to convert the payload to the desired action.\nbuilder.addActionTopic(\u0026#34;switch_off\u0026#34;, \u0026#34;app/actions/switch-off\u0026#34;, msg -\u0026gt; \u0026#34;OFF\u0026#34;); Connection Options Developers can set the connection timeout for the MQTT client.\nbuilder.setConnectionTimeout(30); The clean session flag can be configured based on the desired behavior.\nbuilder.setCleanSessionFlag(true); Developers can specify whether the MQTT client should automatically reconnect in case of a connection failure.\nbuilder.setAutomaticReconnectFlag(true); The builder allows setting a custom MQTT client persistence, such as an in-memory persistence or a file-based one.\nbuilder.setMqttClientPersistence(new MemoryPersistence()); Building Configuration The final configuration is built using the build method.\nMqttDigitalAdapterConfiguration configuration = builder.build(); MqttDigitalAdapter MqttDigitalAdapter extends DigitalAdapter and specializes in MQTT communication for Digital Twin instances. It handles the publication of state updates, events, and property changes over MQTT. This class facilitates seamless integration with MQTT-enabled systems.\nIt uses the information defined and provided in the `` to handle the communication both with the DT Core and external application interested to interact with the DT through the MQTT protocol.\nHere\u0026rsquo;s a basic example illustrating how to use MqttDigitalAdapter:\n// Create a Digital Twin instance DigitalTwin digitalTwin = new DigitalTwin(\u0026#34;my-digital-twin\u0026#34;, new DefaultShadowingFunction()); // Add a Physical Adapter to the DT [...] // Build the MQTT Digital Adapter Configuration MqttDigitalAdapterConfiguration configuration = MqttDigitalAdapterConfiguration.builder(\u0026#34;127.0.0.1\u0026#34;, 1883) .addPropertyTopic(\u0026#34;energy\u0026#34;, \u0026#34;dummy/properties/energy\u0026#34;, MqttQosLevel.MQTT_QOS_0, value -\u0026gt; String.valueOf(((Double)value).intValue())) .addActionTopic(\u0026#34;switch_off\u0026#34;, \u0026#34;app/actions/switch-off\u0026#34;, msg -\u0026gt; \u0026#34;OFF\u0026#34;) .build(); // Add the MQTT Digital Adapter to the Digital Twin digitalTwin.addDigitalAdapter(new MqttDigitalAdapter(\u0026#34;mqtt-da\u0026#34;, configuration)); // Create the Digital Twin Engine and start the simulation DigitalTwinEngine digitalTwinEngine = new DigitalTwinEngine(); digitalTwinEngine.addDigitalTwin(digitalTwin); digitalTwinEngine.startAll(); ","date":"February 9, 2024","id":18,"permalink":"/docs/adapters/mqtt-digital-adapter/","summary":"The MqttDigitalAdapter,\nMqttDigitalAdapterConfiguration, and MqttDigitalAdapterConfigurationBuilder classes and guides you through using these classes to set up an MQTT Digital Adapter within WLDT.","tags":"","title":"MQTT Digital Adapter"},{"content":"Digital Adapters The following methods have been discontinued and removed from the DigitalAdapter class: onStateChangePropertyCreated onStateChangePropertyUpdated onStateChangePropertyDeleted onStatePropertyUpdated onStatePropertyDeleted onStateChangeActionEnabled onStateChangeActionUpdated onStateChangeActionDisabled onStateChangeEventRegistered onStateChangeEventRegistrationUpdated onStateChangeEventUnregistered onStateChangeRelationshipInstanceDeleted onStateChangeRelationshipDeleted onStateChangeRelationshipInstanceCreated onStateChangeRelationshipCreated onDigitalTwinStateEventNotificationReceived The Signature of the following methods have been changed: onDigitalTwinSync(IDigitalTwinState currentDigitalTwinState) -\u0026gt; onDigitalTwinSync(DigitalTwinState currentDigitalTwinState) onDigitalTwinUnSync(IDigitalTwinState currentDigitalTwinState) -\u0026gt; onDigitalTwinUnSync(DigitalTwinState currentDigitalTwinState) New methods that have been added are: onStateUpdate(DigitalTwinState newDigitalTwinState, DigitalTwinState previousDigitalTwinState, ArrayList\u0026lt;DigitalTwinStateChange\u0026gt; digitalTwinStateChangeList) onEventNotificationReceived(DigitalTwinStateEventNotification\u0026lt;?\u0026gt; digitalTwinStateEventNotification) For additional details about Digital Adapters check Sub Section [[Change Log - v.0.3.0#Digital Adapter| Digital Adapters]] Shadowing Function ShadowingModelFunction is now ShadowingFunction this.digitalTwinState is not directly accessible anymore and it is wrapped through the DigitalTwinStateManager using the variable digitalTwinStateManager (see next descriptions and changes) The method addRelationshipInstance now take only one parameter that is the DigitalTwinStateRelationshipInstance The same change for example should be applied in the point of the code where the Shadowing Function receive a variation from the Physical world through a target adapter and the callback method onPhysicalAssetPropertyVariation(...) When the Shadowing Function has to compute the new DT State it can now work with the following method to handle DT State Transition: this.digitalTwinStateManager.startStateTransaction() DT State variation methods such as: digitalTwinStateManager.createProperty() digitalTwinStateManager.updateProperty() digitalTwinStateManager.updatePropertyValue() digitalTwinStateManager.deleteProperty() digitalTwinStateManager.enableAction() digitalTwinStateManager.updateAction() digitalTwinStateManager.disableAction() digitalTwinStateManager.registerEvent() digitalTwinStateManager.updateRegisteredEvent() digitalTwinStateManager.unRegisterEvent() digitalTwinStateManager.createRelationship() digitalTwinStateManager.addRelationshipInstance() digitalTwinStateManager.deleteRelationship() digitalTwinStateManager.deleteRelationshipInstance() At the end the transaction can be committed using the method: digitalTwinStateManager.commitStateTransaction() The method notifyDigitalTwinStateEvent is now available through the digitalTwinStateManager Additional Details associated to Shadowing Function Migration can be found in the dedicated section [[Change Log - v.0.3.0#Shadowing Function Changes | Shadowing Function Changes]] WLDT Engine \u0026amp; DT Creation WldtEngine is now DigitalTwin and model and structure a single Digital Twin and takes the following parameters: String digitalTwinId ShadowingFunction shadowingFunction The startLifeCycle has been removed from the DigitalTwin (previously WLDT Engine) and now DigitalTwinEngine should be used to start twins Once a new Digital Twin has been create it has to be added to the DigitalTwinEngine DigitalTwinEngine has dedicated method to start and stop twins such as: startAll() startDigitalTwin(\u0026lt;DIGITAL_TWIN_ID\u0026gt;); stopAll() digitalTwinEngine.stopDigitalTwin(\u0026lt;DIGITAL_TWIN_ID\u0026gt;); Digital Twin \u0026amp; Digital Twin Engine With the following code we now create a new Digital Twin Instance\n// Create the new Digital Twin with its Shadowing Function DigitalTwin digitalTwin = new DigitalTwin(digitalTwinId, new DemoShadowingFunction()); // Physical Adapter with Configuration digitalTwin.addPhysicalAdapter( new DemoPhysicalAdapter( String.format(\u0026#34;%s-%s\u0026#34;, digitalTwinId, \u0026#34;test-physical-adapter\u0026#34;), new DemoPhysicalAdapterConfiguration(), true)); // Digital Adapter with Configuration digitalTwin.addDigitalAdapter( new DemoDigitalAdapter( String.format(\u0026#34;%s-%s\u0026#34;, digitalTwinId, \u0026#34;test-digital-adapter\u0026#34;), new DemoDigitalAdapterConfiguration()) ); In the new version the DT cannot be directly run but it should be added to the DigitalTwinEngine in order to be executed through the WLDT Library\n// Create the Digital Twin Engine DigitalTwinEngine digitalTwinEngine = new DigitalTwinEngine(); // Add the Digital Twin to the Engine digitalTwinEngine.addDigitalTwin(digitalTwin); In order to start a DT from the Engine you can:\n// Directly start when you add it passing a second boolean value = true digitalTwinEngine.addDigitalTwin(digitalTwin. true); // Starting the single DT on the engine through its id digitalTwinEngine.startDigitalTwin(DIGITAL_TWIN_ID); // Start all the DTs registered on the engine digitalTwinEngine.startAll(); To stop a single twin or all the twin registered on the engine:\n// Stop a single DT on the engine through its id digitalTwinEngine.stopDigitalTwin(DIGITAL_TWIN_ID); // Stop all the DTs registered on the engine digitalTwinEngine.stopAll(); It is also possible to remove a DT from the Engine with a consequent stop if it is active and the deletion of its reference from the engine:\n// Remove a single DT on the engine through its id digitalTwinEngine.removeDigitalTwin(DIGITAL_TWIN_ID); // Remove all the DTs registered on the engine digitalTwinEngine.removeAll(); Digital Twin State DT State now has the reference timestamp representing the evaluation instant of the digital twin state, this timestamp is computed through the DigitalTwinStateManager and cannot manually set by the developer The information available on the DT State are: properties: List of Properties with their values (if available) actions: List of Actions that can be called on the DT events: List of Events that can be generated by the DT relationships: List of Relationships and their instances (if available) evaluationInstant: The timestamp representing the evaluation instant of the DT state Available main methods on that class instance are: Properties:\n- getProperty(String propertyKey): Retrieves if present the target DigitalTwinStateProperty by Key\n- containsProperty(String propertyKey): Checks if a target Property Key is already available in the current Digital Twin\u0026rsquo;s State\n- getPropertyList(): Loads the list of available Properties (described by the class DigitalTwinStateProperty) available on the Digital Twin\u0026rsquo;s State\n- createProperty(DigitalTwinStateProperty\u0026lt;?\u0026gt; dtStateProperty): Allows the creation of a new Property on the Digital Twin\u0026rsquo;s State through the class DigitalTwinStateProperty\n- readProperty(String propertyKey): Retrieves if present the target DigitalTwinStateProperty by Key\n- updateProperty(DigitalTwinStateProperty\u0026lt;?\u0026gt; dtStateProperty): Updates the target property using the DigitalTwinStateProperty and the associated Property Key field\n- deleteProperty(String propertyKey): Deletes the target property identified by the specified key Actions:\n- containsAction(String actionKey): Checks if a Digital Twin State Action with the specified key is correctly registered\n- getAction(String actionKey): Loads the target DigitalTwinStateAction by key\n- getActionList(): Gets the list of available Actions registered on the Digital Twin\u0026rsquo;s State\n- enableAction(DigitalTwinStateAction digitalTwinStateAction): Enables and registers the target Action described through an instance of the DigitalTwinStateAction class\n- updateAction(DigitalTwinStateAction digitalTwinStateAction): Update the already registered target Action described through an instance of the DigitalTwinStateAction class\n- disableAction(String actionKey): Disables and unregisters the target Action described through an instance of the DigitalTwinStateAction class Events:\n- containsEvent(String eventKey): Check if a Digital Twin State Event with the specified key is correctly registered\n- getEvent(String eventKey): Return the description of a registered Digital Twin State Event according to its Key\n- getEventList(): Return the list of existing and registered Digital Twin State Events\n- registerEvent(DigitalTwinStateEvent digitalTwinStateEvent): Register a new Digital Twin State Event\n- updateRegisteredEvent(DigitalTwinStateEvent digitalTwinStateEvent): Update the registration and signature of an existing Digital Twin State Event\n- unRegisterEvent(String eventKey): Un-register a Digital Twin State Event\n- notifyDigitalTwinStateEvent(DigitalTwinStateEventNotification\u0026lt;?\u0026gt; digitalTwinStateEventNotification): Method to notify the occurrence of the target Digital Twin State Event Relationships:\n- containsRelationship(String relationshipName): Checks if a Relationship Name is already available in the current Digital Twin\u0026rsquo;s State\n- createRelationship(DigitalTwinStateRelationship\u0026lt;?\u0026gt; relationship): Creates a new Relationships (described by the class DigitalTwinStateRelationship) in the Digital Twin\u0026rsquo;s State\n- addRelationshipInstance(String name, DigitalTwinStateRelationshipInstance\u0026lt;?\u0026gt; instance): Adds a new Relationship instance described through the class DigitalTwinStateRelationshipInstance and identified through its name\n- getRelationshipList(): Loads the list of existing relationships on the Digital Twin\u0026rsquo;s State through a list of DigitalTwinStateRelationship\n- getRelationship(String name): Gets a target Relationship identified through its name and described through the class DigitalTwinStateRelationship\n- deleteRelationship(String name): Deletes a target Relationship identified through its name\n- deleteRelationshipInstance(String relationshipName, String instanceKey): Deletes the target Relationship Instance using relationship name and instance Key Digital Twin State Manager The DigitalTwinStateManager is a Java class that serves as the default implementation of the IDigitalTwinStateManager interface within the White Label Digital Twin Java Framework (whitelabel-digitaltwin). This class allows developers to manage the state of a digital twin, including properties, actions, events, and relationships.\nFeatures State Management: Handles the creation, update, and deletion of properties, actions, events, and relationships associated with the digital twin state. Transaction Support: Allows developers to start, commit, or rollback transactions to manage changes to the digital twin state. Event Notification: Notifies listeners about updates to the digital twin state through the WLDT event bus. When the Shadowing Function has to compute the new DT State it can now work with the following method to handle DT State Transition: - Start the DT State Transaction: startStateTransaction() - DT State variation methods such as: - createProperty() - updateProperty()\n- updatePropertyValue() - deleteProperty() - enableAction() - updateAction() - disableAction() - registerEvent() - updateRegisteredEvent() - unRegisterEvent() - createRelationship() - addRelationshipInstance() - deleteRelationship() - deleteRelationshipInstance()\nAt the end the transaction can be committed using the method: commitStateTransaction()\nUsage To use the DigitalTwinStateManager within your digital twin implementation:\nInitialization: Create an instance of the DigitalTwinStateManager. DigitalTwinStateManager digitalTwinStateManager = new DigitalTwinStateManager(); State Transaction:\nStart a new transaction using startStateTransaction() to manage changes. Make changes to the digital twin state. Commit the transaction using commitStateTransaction() to apply the changes. digitalTwinStateManager.startStateTransaction(); // Make changes to properties, actions, events, or relationships // [...] digitalTwinStateManager.commitStateTransaction(); Event Notification:\nDT State Updates after a commit action are automatically notified to Digital Adapter by the Manager Once an event incoming from the physical or generated by the DT itself is handled by the Shadowing Function, the developer can use notifyDigitalTwinStateUpdate to notify Digital Adapter listening about events variations. // Notify a specific event notification digitalTwinStateManager.notifyDigitalTwinStateEvent(digitalTwinStateEventNotification); Property, Action, Event, Relationship Management:\nCreate, update, or delete properties, actions, events, or relationships as needed. // Begin Digital Twin State Transaction digitalTwinStateManager.startStateTransaction(); // Create a new property digitalTwinStateManager.createProperty(dtStateProperty); // Update an existing property digitalTwinStateManager.updateProperty(dtStateProperty); // Delete a property digitalTwinStateManager.deleteProperty(propertyKey);` // Commit DT State Update to apply all the changes and notify the Digital Adapters and other listeners about the variation digitalTwinStateManager.commitStateTransaction(); Exception Handling The class throws WldtDigitalTwinStateException to indicate errors related to digital twin state management. Proper exception handling is advised to manage potential errors during state transactions. Shadowing Function Changes Now that the DT State is managed through the DigitalTwinStateManager class all the changes and variation should be applied on the DT ShadowingFunction using the previously presented transaction management and the correct call of methods startStateTransaction() and commitStateTransaction().\nHere there is an example of the change with a simple and demo shadowing function on callback onDigitalTwinBound:\n@Override protected void onDigitalTwinBound(Map\u0026lt;String, PhysicalAssetDescription\u0026gt; adaptersPhysicalAssetDescriptionMap) { try{ // NEW -\u0026gt; Start DT State Change Transaction this.digitalTwinStateManager.startStateTransaction(); for(Map.Entry\u0026lt;String, PhysicalAssetDescription\u0026gt; entry : adaptersPhysicalAssetDescriptionMap.entrySet()){ String adapterId = entry.getKey(); PhysicalAssetDescription physicalAssetDescription = entry.getValue(); //In that simple case the Digital Twin shadow all the properties and actions available in the physical asset for(PhysicalAssetProperty\u0026lt;?\u0026gt; p : physicalAssetDescription.getProperties()) this.digitalTwinStateManager.createProperty(new DigitalTwinStateProperty\u0026lt;\u0026gt;(p.getKey(), p.getInitialValue())); for(PhysicalAssetAction a : physicalAssetDescription.getActions()) this.digitalTwinStateManager.enableAction(new DigitalTwinStateAction(a.getKey(), a.getType(), a.getContentType())); for(PhysicalAssetEvent e: physicalAssetDescription.getEvents()) this.digitalTwinStateManager.registerEvent(new DigitalTwinStateEvent(e.getKey(), physicalAssetEvent.getType())); } // NEW -\u0026gt; Commit DT State Change Transaction to apply the changes on the DT State and notify about the change this.digitalTwinStateManager.commitStateTransaction(); //Observer Target Physical Properties for(Map.Entry\u0026lt;String, PhysicalAssetDescription\u0026gt; entry : adaptersPhysicalAssetDescriptionMap.entrySet()){ [...] } //Observe all the target available Physical Asset Events for each Adapter for(Map.Entry\u0026lt;String, PhysicalAssetDescription\u0026gt; entry : adaptersPhysicalAssetDescriptionMap.entrySet()){ [...] } // Observer for Incoming Digital Actions observeDigitalActionEvents(); //Notify Shadowing Completed notifyShadowingSync(); }catch (Exception e){ e.printStackTrace(); } } The same change for example should be applied in the point of the code where the Shadowing Function receive a variation from the Physical world through a target adapter and the callback method onPhysicalAssetPropertyVariation(...)\n@Override protected void onPhysicalAssetPropertyVariation(PhysicalAssetPropertyWldtEvent\u0026lt;?\u0026gt; physicalPropertyEventMessage) { try { if(physicalPropertyEventMessage != null \u0026amp;\u0026amp; getPhysicalEventsFilter().contains(physicalPropertyEventMessage.getType())){ if(physicalPropertyEventMessage.getPhysicalPropertyId().equals(TestPhysicalAdapter.SWITCH_PROPERTY_KEY) \u0026amp;\u0026amp; physicalPropertyEventMessage.getBody() instanceof String){ [...] } else{ //Update Digital Twin State //NEW -\u0026gt; Start State Transaction this.digitalTwinStateManager.startStateTransaction(); // Update State Property Value this.digitalTwinStateManager.updateProperty( new DigitalTwinStateProperty\u0026lt;\u0026gt;( physicalPropertyEventMessage.getPhysicalPropertyId(), physicalPropertyEventMessage.getBody())); //NEW -\u0026gt; Commit State Transaction this.digitalTwinStateManager.commitStateTransaction(); } } else logger.error(\u0026#34;WRONG Physical Event Message Received !\u0026#34;); }catch (Exception e){ e.printStackTrace(); } } Digital Adapter The Digital Adapter base class has been significantly extended and improved with respect to the previous version. In this new Version notifications that are received by the Adapter from the the DT core belongs to the following categories:\nDigital Twin State Update through the method onStateUpdate(...) providing information about the new state of the Digital Twin, the previous state, and a list of changes that occurred between these two states. In the previous version each variation of a property, relationships, actions or events were notified. In the new version only a committed DT\u0026rsquo;State variation is notified to listeners. Event Notifications through the method onEventNotificationReceived(...) whenever there is a notification about an event related to the Digital Twin\u0026rsquo;s state coming from the physical world, generated by the twin and processed by the Shadowing Function. For example in the DT State we can have the declaration of the over-heating-alert structured and received in the DT State while the effective occurrence of the event and the associated notification is notified through this dedicated callback The onStateUpdate method is an abstract method that must be implemented by any class extending the DigitalAdapter class. This method is called whenever there is an update to the Digital Twin\u0026rsquo;s state. It provides information about the new state of the Digital Twin, the previous state, and a list of changes that occurred between these two states.\nHere is an explanation of the parameters:\nnewDigitalTwinState: This parameter represents the updated state of the Digital Twin. It is an instance of the DigitalTwinState class, which encapsulates the current state information.\npreviousDigitalTwinState: This parameter represents the state of the Digital Twin before the update. It is also an instance of the DigitalTwinState class.\ndigitalTwinStateChangeList: This parameter is an ArrayList containing DigitalTwinStateChange objects. Each DigitalTwinStateChange object encapsulates information about a specific change that occurred between the previous and new states. It includes details such as the property or aspect of the state that changed, the previous value, and the new value.\nThe DT State is automatically monitored by each Digital Adapter while for the Events potentially generated by the DT can be observed by each adapter using:\nobserveAllDigitalTwinEventsNotifications: Enable the observation of available Digital Twin State Events Notifications. unObserveAllDigitalTwinEventsNotifications: Cancel the observation of Digital Twin State Events Notifications observeDigitalTwinEventsNotifications: Enable the observation of the notification associated to a specific list of Digital Twin State events. With respect to event a notification contains the new associated value unObserveDigitalTwinEventsNotifications: Cancel the observation of a target list of properties observeDigitalTwinEventNotification: Enable the observation of the notification associated to a single Digital Twin State event. With respect to event a notification contains the new associated value unObserveDigitalTwinEventNotification: Cancel the observation of a single target event DigitalTwinStateChange Class DigitalTwinStateChange Class\nThe DigitalTwinStateChange class is a representation of a change that occurred in the state of a Digital Twin. It encapsulates information about the type of operation, the resource type, and the affected resource within the Digital Twin.\nEnums:\nOperation: Enumerates different types of operations that can be performed on a Digital Twin state. The possible operations are: OPERATION_UPDATE: Represents an update operation on a resource. OPERATION_UPDATE_VALUE: Represents an update operation specifically on the value of a resource. OPERATION_ADD: Represents an addition operation of a new resource. OPERATION_REMOVE: Represents a removal operation of an existing resource. ResourceType: Enumerates different types of resources within a Digital Twin. The possible resource types are: PROPERTY: Represents a property of the Digital Twin. PROPERTY_VALUE: Represents the value of a property within the Digital Twin. EVENT: Represents an event associated with the Digital Twin. ACTION: Represents an action that can be performed on the Digital Twin. RELATIONSHIP: Represents a relationship between different components of the Digital Twin. RELATIONSHIP_INSTANCE: Represents an instance of a relationship. Fields:\noperation: Indicates the type of operation performed on the Digital Twin state (e.g., update, add, remove). resourceType: Represents the type of resource affected by the change (e.g., property, event, relationship). resource: The specific resource that has undergone the change, represented by an instance of the DigitalTwinStateResource class. Available type of DigitalTwinStateResource are:\nDigitalTwinStateProperty\u0026lt;T\u0026gt;: This class define a generic property associated to the Digital Twin State. Each property is associated to a Key and a Value. Furthermore, it can also be associated to a type to identify its nature and data structure. By default, it is associated to the type of the Class (e.g., java.lang.String) but it can be directly changed by the developer to associate it to a specific ontology or data type. DigitalTwinStateEvent: This class define a generic event associated to the Digital Twin State. Events enable a mechanism for asynchronous messages to be sent by the digital twin (e.g., an overheating) . They are different from Properties that can change values according to the type of Digital Twin and may be associated also to telemetry patterns. Each event is associated to a Key and a Type used to identify its nature and data structure. By default, it is associated to the type of the Class (e.g., java.lang.String) but it can be directly changed by the developer to associate it to a specific ontology or data type. DigitalTwinStateAction: This class define a generic action associated to the Digital Twin State. Each action is by a key, an action type and a content type used to identify the expected input required by the action. The type of the can be directly changed by the developer to associate it to a specific ontology or data type. DigitalTwinStateRelationship\u0026lt;T\u0026gt;: Structures and describes a Relationship in the Digital Twins\u0026rsquo;s State. This is just the description of the relationships while the effective values/instances are described through the other class DigitalTwinStateRelationshipInstance DigitalTwinStateRelationshipInstance\u0026lt;T\u0026gt;: Structures and describes a Relationship Instance in the Digital Twins\u0026rsquo;s State. This is effective description of a relationship while its generic declaration is described through the class DigitalTwinStateRelationship. When there is a change in the DT State it is possibile to cast the received resource variation to the correct one. For example in the following code we detect and manage the variation on a Property Value:\n// Get information from the state change DigitalTwinStateChange.Operation operation = stateChange.getOperation(); DigitalTwinStateChange.ResourceType resourceType = stateChange.getResourceType(); DigitalTwinStateResource resource = stateChange.getResource(); // Search for property value variation if(resourceType.equals(DigitalTwinStateChange.ResourceType.PROPERTY_VALUE) \u0026amp;\u0026amp; operation.equals(DigitalTwinStateChange.Operation.OPERATION_UPDATE) \u0026amp;\u0026amp; resource instanceof DigitalTwinStateProperty){ DigitalTwinStateProperty\u0026lt;?\u0026gt; digitalTwinStateProperty = (DigitalTwinStateProperty\u0026lt;?\u0026gt;) resource; if(getConfiguration().getPropertyUpdateTopics().containsKey(digitalTwinStateProperty.getKey())){ //Handle property value variation } } Constructors:\nDigitalTwinStateChange(): An empty constructor that allows creating an instance of the class. DigitalTwinStateChange(Operation operation, ResourceType resourceType, DigitalTwinStateResource resource): Constructs a DigitalTwinStateChange object with specified operation, resource type, and resource. Throws a WldtDigitalTwinStateException if any of the parameters is missing or null. Methods:\nAccessor methods (getOperation(), getResourceType(), getResource()) to retrieve the values of the fields. Mutator methods (setOperation(), setResourceType(), setResource()) to update the values of the fields. Usage Examples Developers extending the DigitalAdapter class should implement the onStateUpdate method to define custom logic that needs to be executed whenever the state of the Digital Twin is updated. This could include tasks such as processing state changes, updating internal variables, triggering specific actions, or notifying other components about the state update.\nHere\u0026rsquo;s an example of how the method might be implemented in a concrete subclass of DigitalAdapter:\n@Override protected void onStateUpdate(DigitalTwinState newDigitalTwinState, DigitalTwinState previousDigitalTwinState, ArrayList\u0026lt;DigitalTwinStateChange\u0026gt; digitalTwinStateChangeList) { // In newDigitalTwinState we have the new DT State System.out.println(\u0026#34;New DT State is: \u0026#34; + newDigitalTwinState); // The previous DT State is available through the variable previousDigitalTwinState System.out.println(\u0026#34;Previous DT State is: \u0026#34; + previousDigitalTwinState); // We can also check each DT\u0026#39;s state change potentially differentiating the behaviour for each change if (digitalTwinStateChangeList != null \u0026amp;\u0026amp; !digitalTwinStateChangeList.isEmpty()) { // Iterate through each state change in the list for (DigitalTwinStateChange stateChange : digitalTwinStateChangeList) { // Get information from the state change DigitalTwinStateChange.Operation operation = stateChange.getOperation(); DigitalTwinStateChange.ResourceType resourceType = stateChange.getResourceType(); DigitalTwinStateResource resource = stateChange.getResource(); // Perform different actions based on the type of operation switch (operation) { case OPERATION_UPDATE: // Handle an update operation System.out.println(\u0026#34;Update operation on \u0026#34; + resourceType + \u0026#34;: \u0026#34; + resource); break; case OPERATION_UPDATE_VALUE: // Handle an update value operation System.out.println(\u0026#34;Update value operation on \u0026#34; + resourceType + \u0026#34;: \u0026#34; + resource); break; case OPERATION_ADD: // Handle an add operation System.out.println(\u0026#34;Add operation on \u0026#34; + resourceType + \u0026#34;: \u0026#34; + resource); break; case OPERATION_REMOVE: // Handle a remove operation System.out.println(\u0026#34;Remove operation on \u0026#34; + resourceType + \u0026#34;: \u0026#34; + resource); break; default: // Handle unknown operation (optional) System.out.println(\u0026#34;Unknown operation on \u0026#34; + resourceType + \u0026#34;: \u0026#34; + resource); break; } } } else { // No state changes System.out.println(\u0026#34;No state changes detected.\u0026#34;); } } In this example, the method iterates over the list of state changes, extracts information about each change, and performs custom actions based on the changes. Developers can adapt this method to suit the specific requirements of their Digital Twin application.\n","date":"February 9, 2024","id":19,"permalink":"/docs/change-logs/change-log-0.3.0/","summary":"Digital Adapters The following methods have been discontinued and removed from the DigitalAdapter class: onStateChangePropertyCreated onStateChangePropertyUpdated onStateChangePropertyDeleted onStatePropertyUpdated onStatePropertyDeleted onStateChangeActionEnabled onStateChangeActionUpdated onStateChangeActionDisabled onStateChangeEventRegistered onStateChangeEventRegistrationUpdated onStateChangeEventUnregistered onStateChangeRelationshipInstanceDeleted onStateChangeRelationshipDeleted onStateChangeRelationshipInstanceCreated onStateChangeRelationshipCreated onDigitalTwinStateEventNotificationReceived The Signature of the following methods have been changed: onDigitalTwinSync(IDigitalTwinState currentDigitalTwinState) -\u0026gt; onDigitalTwinSync(DigitalTwinState currentDigitalTwinState) onDigitalTwinUnSync(IDigitalTwinState currentDigitalTwinState) -\u0026gt; onDigitalTwinUnSync(DigitalTwinState currentDigitalTwinState) New methods that have been added are: onStateUpdate(DigitalTwinState newDigitalTwinState, DigitalTwinState previousDigitalTwinState, ArrayList\u0026lt;DigitalTwinStateChange\u0026gt; digitalTwinStateChangeList) onEventNotificationReceived(DigitalTwinStateEventNotification\u0026lt;?","tags":"","title":"Change Log 0.3.0"},{"content":"The HttpDigitalAdapter is a powerful component designed to facilitate the integration of Digital Twins into HTTP-based systems. It serves as a bridge between a Digital Twin and HTTP-based applications, allowing developers to easily expose and interact with Digital Twin data and functionalities over HTTP.\nKey Features:\nHTTP Integration: Seamlessly integrates Digital Twins into HTTP environments, enabling communication with web applications and services. Dynamic Configuration: Offers a flexible configuration mechanism through the HttpDigitalAdapterConfiguration, allowing developers to customize the adapter\u0026rsquo;s behavior based on specific requirements. State Monitoring: Monitors changes in the Digital Twin state and provides HTTP endpoints to query the state of the Digital Twin (properties, events, actions and relationships). Event Notifications: Allows developers to retrieve event notifications triggered by changes in the Digital Twin state. Storage \u0026amp; Query: Since version 0.2 the HTTP Digital Adapter is able to retrieve Storage Statistics and execute query on the target DT A complete example is provided in the test folder with a complete DT Creation in the TestMain class together with a demo DT with and emulated Physical Adapter and the HTTP Digital Adapter.\nWLDT-Core Version Compatibility The correct mapping and compatibility between versions is reported in the following table\nhttp-digital-adapter wldt-core 0.2.1 wldt-core 0.3.0 wldt-core 0.4.0 0.1.1 âŒ âœ… âœ… 0.2 âŒ âŒ âœ… Installation To use HttpDigitalAdapter in your Java project, you can include it as a dependency using Maven or Gradle.\nMaven \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.github.wldt\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;http-digital-adapter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Gradle implementation \u0026#39;io.github.wldt:http-digital-adapter:0.2\u0026#39; Class Structure \u0026amp; Functionalities HttpDigitalAdapterConfiguration The HttpDigitalAdapterConfiguration is a crucial part of the HttpDigitalAdapter, providing the necessary settings to tailor the adapter\u0026rsquo;s behavior to meet specific needs.\nRepresents the configuration for an HTTP Digital Adapter, specifying the host, port, and filters for properties, actions, events, and relationships.\nThe filters are used to selectively include or exclude specific properties, actions, events, and relationships when interacting with the HTTP Digital Adapter. Filters are meant to be white list filters, if they are empty, it means that ALL fields are considered\nThis class provides methods to add filters for each type and getters to retrieve the configured values.\nKey functionalities and exposed capabilities:\nBasic Configuration Adapter ID: A unique identifier for the HttpDigitalAdapter instance. Host: The hostname or IP address on which the adapter will listen for incoming HTTP requests. Port: The port number on which the adapter will listen for incoming HTTP requests. Filters (Optional) addPropertyFilter(String propertyKey): Adds a single property key to the property filter. addPropertiesFilter(Collection\u0026lt;String\u0026gt; propertiesKey): Adds a collection of property keys to the property filter. addActionFilter(String actionKey): Adds a single action key to the action filter. addActionsFilter(Collection\u0026lt;String\u0026gt; actionsKey): Adds a collection of action keys to the action filter. addEventFilter(String eventKey): Adds a single event key to the event filter. addEventsFilter(Collection\u0026lt;String\u0026gt; eventsKey): Adds a collection of event keys to the event filter. addRelationshipFilter(String relationshipName): Adds a single relationship name to the relationship filter. addRelationshipsFilter(Collection\u0026lt;String\u0026gt; relationshipNames): Adds a collection of relationship names to the relationship filter. Configured Filter can be accessed using: getPropertyFilter() getActionFilter() getEventFilter() getRelationshipFilter() A basic example without any filter that accesses and uses the entire DT State is:\nHttpDigitalAdapterConfiguration config = new HttpDigitalAdapterConfiguration(\u0026#34;my-http-adapter\u0026#34;, \u0026#34;localhost\u0026#34;, 8080); An example of using filter to select specific field of interest can be structured ad follows:\nHttpDigitalAdapterConfiguration config = new HttpDigitalAdapterConfiguration(\u0026#34;my-http-adapter\u0026#34;, \u0026#34;localhost\u0026#34;, 8080); // Add property filter config.addPropertyFilter(\u0026#34;temperature\u0026#34;); config.addPropertiesFilter(Arrays.asList(\u0026#34;humidity\u0026#34;, \u0026#34;pressure\u0026#34;)); // Add action filter config.addActionFilter(\u0026#34;start\u0026#34;); config.addActionsFilter(Arrays.asList(\u0026#34;stop\u0026#34;, \u0026#34;reset\u0026#34;)); // Add event filter config.addEventFilter(\u0026#34;temperatureChange\u0026#34;); config.addEventsFilter(Collections.singletonList(\u0026#34;pressureChange\u0026#34;)); // Add relationship filter config.addRelationshipFilter(\u0026#34;connectedTo\u0026#34;); config.addRelationshipsFilter(Arrays.asList(\u0026#34;parentOf\u0026#34;, \u0026#34;siblingOf\u0026#34;)); // Retrieve and display filters List\u0026lt;String\u0026gt; propertyFilter = config.getPropertyFilter(); List\u0026lt;String\u0026gt; actionFilter = config.getActionFilter(); List\u0026lt;String\u0026gt; eventFilter = config.getEventFilter(); List\u0026lt;String\u0026gt; relationshipFilter = config.getRelationshipFilter(); System.out.println(\u0026#34;Property Filter: \u0026#34; + propertyFilter); System.out.println(\u0026#34;Action Filter: \u0026#34; + actionFilter); System.out.println(\u0026#34;Event Filter: \u0026#34; + eventFilter); System.out.println(\u0026#34;Relationship Filter: \u0026#34; + relationshipFilter); HttpDigitalAdapter The HttpDigitalAdapter itself is the core component responsible for handling HTTP requests and interacting with the underlying Digital Twin. It extends the capabilities of the base DigitalAdapter to specifically cater to HTTP-based scenarios.\nKey Functionalities:\nRESTful Endpoints: Provides RESTful endpoints for reading properties, invoking actions, querying events, and managing relationships. State Updates: Automatically reflects changes in the Digital Twin state to the HTTP endpoints, ensuring real-time information. Event Handling: Listens for Digital Twin events and provides events notifications to HTTP clients. Here\u0026rsquo;s a basic example illustrating how to use MqttDigitalAdapter:\nGetting Started: Create HttpDigitalAdapterConfiguration:\nHttpDigitalAdapterConfiguration config = new HttpDigitalAdapterConfiguration(\u0026#34;my-http-adapter\u0026#34;, \u0026#34;localhost\u0026#34;, 8080); Instantiate HttpDigitalAdapter:\nDigitalTwin digitalTwin = new DigitalTwin(\u0026#34;my-digital-twin\u0026#34;, new DefaultShadowingFunction()); HttpDigitalAdapter httpDigitalAdapter = new HttpDigitalAdapter(config, digitalTwin); // Add a Physical Adapter to the DT [...] Add HttpDigitalAdapter to DigitalTwin:\ndigitalTwin.addDigitalAdapter(httpDigitalAdapter); Start the Digital Twin Engine:\nDigitalTwinEngine digitalTwinEngine = new DigitalTwinEngine(); digitalTwinEngine.addDigitalTwin(digitalTwin); digitalTwinEngine.startAll(); HTTP RESTful API This section of the documentation provides detailed information about the RESTful API exposed by the WLDT - HTTP Digital Adapter. The API allows you to interact with the Digital Twin (DT) instance, retrieve its state, read properties, actions, event and relationships description, and trigger actions.\nAvailable endpoints with the associated methods are:\nGET /instance: Retrieves information about the Digital Twin instance. GET /state: Retrieves the current state of the Digital Twin. GET /state/changes: Retrieves the list of state changes in the Digital Twin. GET /state/previous: Retrieves the previous state of the Digital Twin. GET /state/properties: Retrieves the list of properties in the Digital Twin state. GET /properties/{propertyKey}: Retrieves the value of a specific property (e.g., /properties/color) from the Digital Twin state. GET /state/events: Retrieves the list of events in the Digital Twin state. GET /state/actions: Retrieves the list of actions in the Digital Twin state. POST /state/actions/{actionKey}: Triggers the specified action (e.g., /state/actions/switch_on) in the Digital Twin state. The raw body contains the action request payload. GET /state/relationships: Retrieves the list of relationships in the Digital Twin state. GET /state/relationships/{relationshipName}/instances: Retrieves the instances of the specified relationship (e.g., /state/relationships/insideIn/instances) in the Digital Twin state. GET /storage: Retrieves Storage Statistics from the target Digital Twin POST /storage/query: Allows the execution of a query, where the query structure is specified through a JSON Message in the request Body. For additional information about the Query System see Query System Page Note: Replace {propertyKey}, {actionKey}, and {relationshipName} with the actual values you want to retrieve or trigger. Make sure to use the appropriate HTTP method (GET, POST) and include any required parameters or payload as described in each endpoint\u0026rsquo;s description. For more detailed information, refer to the Postman Collection for this API available in the folder api: http_adapter_api_postman.json\nExample of Storage Query Requests are the following:\nRetrieve the first 4 Digital Twin State Variations\n{ \u0026#34;resourceType\u0026#34;: \u0026#34;DIGITAL_TWIN_STATE\u0026#34;, \u0026#34;queryType\u0026#34;: \u0026#34;SAMPLE_RANGE\u0026#34;, \u0026#34;startIndex\u0026#34;: 0, \u0026#34;endIndex\u0026#34;: 3 } Retrieve Digital Twin State Variations in a Time Range\n{ \u0026#34;resourceType\u0026#34;: \u0026#34;DIGITAL_TWIN_STATE\u0026#34;, \u0026#34;queryType\u0026#34;: \u0026#34;TIME_RANGE\u0026#34;, \u0026#34;startIndex\u0026#34;: 161989898, \u0026#34;endIndex\u0026#34;: 162989898 } Retrieve the last Digital Twin State\n{ \u0026#34;resourceType\u0026#34;: \u0026#34;DIGITAL_TWIN_STATE\u0026#34;, \u0026#34;queryType\u0026#34;: \u0026#34;LAST_VALUE\u0026#34; } Available keywords for Query Resource Type and Query Type are the following (as explained in the dedicated Query System Page):\n- PHYSICAL_ASSET_PROPERTY_VARIATION - TIME_RANGE - SAMPLE_RANGE - COUNT - PHYSICAL_ASSET_EVENT_NOTIFICATION - TIME_RANGE - SAMPLE_RANGE - COUNT - PHYSICAL_ACTION_REQUEST - TIME_RANGE - SAMPLE_RANGE - COUNT - DIGITAL_ACTION_REQUEST - TIME_RANGE - SAMPLE_RANGE - COUNT - DIGITAL_TWIN_STATE - TIME_RANGE - SAMPLE_RANGE - COUNT - LAST_VALUE - NEW_PAD_NOTIFICATION - TIME_RANGE - SAMPLE_RANGE - COUNT - UPDATED_PAD_NOTIFICATION - TIME_RANGE - SAMPLE_RANGE - COUNT - PHYSICAL_RELATIONSHIP_INSTANCE_CREATED_NOTIFICATION - TIME_RANGE - SAMPLE_RANGE - COUNT - PHYSICAL_RELATIONSHIP_INSTANCE_DELETED_NOTIFICATION - TIME_RANGE - SAMPLE_RANGE - COUNT - LIFE_CYCLE_EVENT - TIME_RANGE - SAMPLE_RANGE - COUNT - LAST_VALUE - STORAGE_STATS - LAST_VALUE ","date":"February 9, 2024","id":20,"permalink":"/docs/adapters/http-digital-adapter/","summary":"The HttpDigitalAdapter is a powerful component designed to facilitate the integration of Digital Twins into HTTP-based systems. It serves as a bridge between a Digital Twin and HTTP-based applications, allowing developers to easily expose and interact with Digital Twin data and functionalities over HTTP.","tags":"","title":"HTTP Digital Adapter"},{"content":"The CoapPhysicalAdapter acts as a bridge between the Digital Twin and the Physical Assets, leveraging the CoAP protocol for communication. It implements various features, which can be enabled or disabled via the usage of a builder-based configuration, which also allows the implementation of custom behavior where needed.\nKey features:\nConfiguration builder: The Adapter configuration is managed via the builder provided by the CoapPhysicalAdapterConfiguration.build() method, which enables users to effortlessly configure the CoAP server parameters and each Adapter\u0026rsquo;s feature. Standard \u0026amp; custom resource discovery support: The Adapter configuration makes it possible to enable/disable the Resource Discovery process at the start of the Adapter, and to provide the Adapter with a custom Resource Discovery method in case the default (standard) one is not suited for the Digital Twin integration in the system. Observation \u0026amp; polling support: It\u0026rsquo;s possible to configure the Adapter to use both Observation or Polling to keep the Adapter synced with the Physical Asset. Customizable behavior: Users can extend and customize the Adapter\u0026rsquo;s behavior to meet specific requirements, such as implementing custom message processing or custom request handlers to better integrate with proprietary systems. In the WLDT library, Physical Adapters have the responsibility to generate and publish the PhysicalAssetDescription (PAD) to describe the capabilities and the characteristics of the Object, allowing the Shadowing Function to decide how to digitalize its Physical counterpart.\nIn the CoapPhysicalAdapter the generation of the PAD (Physical Asset Description) is automatically and internally executed by the adapter itself accordingly to its configuration.\nWLDT-Core Version Compatibility coap-physical-adapter wldt-core 0.2.1 wldt-core 0.3.0 wldt-core 0.4.0 0.1.1 âŒ âŒ âœ… 0.1.2 âŒ âŒ âœ… Installation To use the adapter in your Java project, you can include it as a dependency using Maven or Gradle.\nMaven \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.github.wldt\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;coap-physical-adapter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Gradle implementation(\u0026#34;io.github.wldt:coap-physical-adapter:0.1.2\u0026#34;) Class Structure \u0026amp; Functionalities CoapPhysicalAdapter The CoapPhysicalAdapter class is the core component for interacting with physical assets. Instantiate it with a unique ID and the configuration. It extends the default WLDT Library PhysicalAdapter implementing all the functionalities to automatically interact with a CoAP physical device following the specifications and details provided in the CoapPhysicalAdapterConfiguration and built using CoapPhysicalAdapterConfigurationBuilder.\nA CoapPhysicalAdapter instance can be created as follows:\nCoapPhysicalAdapter coapPhysicalAdapter = new CoapPhysicalAdapter(\u0026#34;uniqueId\u0026#34;, configuration); CoapPhysicalAdapterConfigurationBuilder The CoapPhysicalAdapterConfigurationBuilder is the class used to build the configuration used by the CoapPhysicalAdapter and described and implemented through the class CoapPhysicalAdapterConfiguration.\nIn order to create a configuration builder we can use the builder() static method implemented by the CoapPhysicalAdapterConfiguration class:\nCoapPhysicalAdapterConfiguration.builder() Creates a new instance of the CoAP Physical Adapter configuration builder.\nParameters:\nip: The IP address of the CoAP server. port: The port of the CoAP server. Returns: A new instance of the CoAP Physical Adapter configuration builder.\nIn the builder there\u0026rsquo;s plenty of methods that can be used to configure the Adapter\u0026rsquo;s behavior:\nA builder can also be retrieved from a YAML file, by calling the fromYaml(File yamlConfig) static method contained in CoapDigitalAdapterConfiguration:\nCoapPhysicalAdapterConfiguration.fromYaml(File yamlConfig) Creates a new instance of the CoAP Physical Adapter configuration builder from a YAML file.\nParameters:\nyamlConfig: The file containing the configuration. Returns: A new instance of the CoAP Physical Adapter configuration builder.\nThrows: IOException If an error occurs while reading the YAML file.\nResource discovery enableResourceDiscoverySupport CoapPhysicalAdapterConfigurationBuilder enableResourceDiscoverySupport(boolean enable) Enables/disables the resource discovery process.\nParameters:\nenable: A flag indicating whether to enable or disable the resource discovery process. Returns: The builder instance.\nsetIgnoredResources CoapPhysicalAdapterConfigurationBuilder setIgnoredResources(List\u0026lt;String\u0026gt; ignoredResources) Sets a list of resources which will be ignored by the default resource discovery.\nThis list will be ignored if a custom resource discovery is used.\nParameters:\nignoredResources: A list containing the names of the resources to ignore. Returns: The builder instance.\nignoreResources CoapPhysicalAdapterConfigurationBuilder ignoreResource(String name) Adds a resource to the list of resources ignored by the default resource discovery.\nParameters:\nname: The name of the resource to ignore. Returns: The builder instance.\nsetCustomResourceDiscoveryFunction CoapPhysicalAdapterConfigurationBuilder setCustomResourceDiscoveryFunction(Supplier\u0026lt;Set\u0026lt;PhysicalAssetResource\u0026gt;\u0026gt; customResourceDiscoveryFunction) Sets a custom resource discovery function that will be used instead of the default standard one.\nParameters:\ncustomResourceDiscoveryFunction: A supplier returning a set of PhysicalAssetResource instances. Returns: The builder instance.\nManual resource addition setResources CoapPhysicalAdapterConfigurationBuilder setResources(Set\u0026lt;PhysicalAssetResource\u0026gt; resources) Sets the list of already processed resources to the provided instance.\nParameters:\nresources: A set containing all the resources. Returns: The builder instance.\naddResource CoapPhysicalAdapterConfigurationBuilder addResource(String name, String resourceType, int contentType, boolean hasPostSupport, boolean hasPutSupport, boolean observable) Adds a new physical asset resource to the list of manually added resources.\nEach resource added this way will be processed by the build() method invoked at the end of the configuration.\nParameters:\nname: The resource name. resourceType: The resource type. contentType: The resource preferred content type. hasPostSupport: A flag indicating if the resource supports POST requests. hasPutSupport: A flag indicating if the resource supports PUT requests. observable: A flag indicating if the resource supports observation. Returns: The builder instance.\nResource communication setPreferredContentFormat public CoapPhysicalAdapterConfigurationBuilder setPreferredContentFormat(int preferredContentFormat) Sets the preferred content format used during the communication in the case of the server supporting it.\nParameters:\npreferredContentFormat: The preferred CoAP content format. Returns: The builder instance.\nsetDefaultActuatorActionContentType CoapPhysicalAdapterConfigurationBuilder setDefaultActuatorActionContentType(String actuatorActionContentType) Sets the default WLDT action content type for CoAP resources supporting both POST \u0026amp; PUT requests.\nParameters:\nactuatorActionContentType: The WLDT action type Returns: The builder instance.\nCoapPhysicalAdapterConfigurationBuilder setDefaultPostActionContentType(String postActionContentType) Sets the default WLDT action content type for CoAP resources supporting only POST requests.\nParameters:\npostActionContentType: The WLDT action type Returns: The builder instance.\nsetDefaultPutActionContentType CoapPhysicalAdapterConfigurationBuilder setDefaultPutActionContentType(String putActionContentType) Sets the default WLDT action content type for CoAP resources supporting only PUT requests.\nParameters:\nputActionContentType: The WLDT action type Returns: The builder instance.\naddCustomActionContentType CoapPhysicalAdapterConfigurationBuilder addCustomActionContentType(String resourceName, String actionContentType) Adds a WLDT action content type only to the specified resource.\nParameters:\nresourceName: The resource name. actionContentType: The WLDT action content type. Returns: The builder instance.\nsetCustomPropertyRequestFunction CoapPhysicalAdapterConfigurationBuilder setCustomPropertyRequestFunction(Function\u0026lt;Request, CoapResponse\u0026gt; customPropertyRequestFunction) Sets the function which sends CoAP GET request to the Physical Asset.\nParameters:\ncustomPropertyRequestFunction: A function which receives a CoAP request as input and returns the CoAP response. Returns: The builder instance.\nsetCustomActionRequestFunction CoapPhysicalAdapterConfigurationBuilder setCustomActionRequestFunction(Function\u0026lt;Request, CoapResponse\u0026gt; customActionRequestFunction) Sets the function which sends CoAP POST \u0026amp; PUT request to the Physical Asset.\nParameters:\ncustomActionRequestFunction: A function which receives a CoAP request as input and returns the CoAP response. Returns: The builder instance.\nUsage and examples The custom request functions can be useful in case of the Physical Asset not being compatible with the default requests or the requests needing extra configuration, and they will be automatically called by the Adapter instead of the default Californiun CoAP client\u0026rsquo;s advanced() method.\nThey can be set by passing a lambda function to the previously shown methods, as shown in the following example setting a custom property request function:\nbuilder.setCustomPropertyRequestFunction(request -\u0026gt; { // Add proxy setting to the request request.getOptions().setProxyUri(proxyUri); request.getOptions().setProxyScheme(proxyScheme); // Set OSCORE options request.getOptions().setOscore(oscore); // Send request and return response return client.advanced(request); }) Observability \u0026amp; polling enableObservability CoapPhysicalAdapterConfigurationBuilder enableObservability(boolean enable) Enables/disables the automatic observation process of the Physical Adapter.\nParameters:\nenable: A flag indicating whether to enable or disable the observation. Returns: The builder instance.\nenableAutoUpdateTimer CoapPhysicalAdapterConfigurationBuilder enableAutoUpdateTimer(boolean enable) Enables/disables the automatic polling process of the Physical Adapter.\nParameters:\nenable: A flag indicating whether to enable or disable the polling. Returns: The builder instance.\nsetAutoUpdateInterval CoapPhysicalAdapterConfigurationBuilder setAutoUpdateInterval(long autoUpdateIntervalMs) Sets the polling interval.\nParameters:\nautoUpdateIntervalMs: The polling interval (in milliseconds). Returns: The builder instance.\nCoAP responses to WLDT properties translation setDefaultPropertyBodyTranslator CoapPhysicalAdapterConfigurationBuilder setDefaultPropertyBodyTranslator(BiFunction\u0026lt;String, byte[], List\u0026lt;? extends WldtEvent\u0026lt;?\u0026gt;\u0026gt;\u0026gt; defaultPropertyBodyTranslator) Sets the default function to convert a resource\u0026rsquo;s payload into a WLDT property event.\nParameters:\ndefaultPropertyBodyTranslator: A function which receives as inputs the resource\u0026rsquo;s key and payload, and returns a list of WldtEvent instances. Returns: The builder instance.\nsetCustomPropertyBodyTranslators CoapPhysicalAdapterConfigurationBuilder setCustomPropertyBodyTranslators(Map\u0026lt;String, BiFunction\u0026lt;String, byte[], List\u0026lt;? extends WldtEvent\u0026lt;?\u0026gt;\u0026gt;\u0026gt;\u0026gt; customPropertyBodyTranslators) Sets a map containing the property translation functions of specific resources.\nParameters:\ncustomPropertyBodyTranslators: A map containing the resource names as keys and the translation functions as values. Returns: The builder instance.\nUsage and examples The property translators are used to process the incoming data before updating the Digital Twin State.\nThey can be set by passing a lambda function to the previously shown methods, as shown in the following example, which de-serializes a JSON-serialized class instance and returns the list of corresponding property events:\nbuilder.setDefaultPropertyBodyTranslator((key, payload) -\u0026gt; { // Instantiate events list List\u0026lt;WldtEvent\u0026lt;String\u0026gt;\u0026gt; events = new ArrayList\u0026lt;\u0026gt;(); // Instantiate de-serializer Gson gson = new Gson(); // De-serialize incoming data into class instance IncomingDataModel processedData = gson.fromJson(new String(payload), IncomingDataModel.class); // Create propety event associated with the de-serialized instance and add it to the events list try { events.add(new PhysicalAssetPropertyWldtEvent\u0026lt;\u0026gt;( String.format(\u0026#34;%s.%s.%s\u0026#34;, KEY_PA1, KEY_PA_PROPERTY, processedData.getName().replace(\u0026#34; \u0026#34;, \u0026#34;-\u0026#34;).toLowerCase()), processedData.getValue() ); } catch (EventBusException e) { e.printStackTrace(); } // Return list of events return events; }) CoAP communication events to WLDT event notifications setDefaultEventTranslator CoapPhysicalAdapterConfigurationBuilder setDefaultEventTranslator(BiFunction\u0026lt;String, String, List\u0026lt;? extends WldtEvent\u0026lt;?\u0026gt;\u0026gt;\u0026gt; defaultEventTranslator) Sets the default function to convert a resource\u0026rsquo;s event into a WLDT event notification.\nParameters:\ndefaultEventTranslator: A function which receives as inputs the resource\u0026rsquo;s key and event message, and returns a list of WldtEvent instances. Returns: The builder instance.\nsetCustomEventTranslators CoapPhysicalAdapterConfigurationBuilder setCustomEventTranslators(Map\u0026lt;String, BiFunction\u0026lt;String, String, List\u0026lt;? extends WldtEvent\u0026lt;?\u0026gt;\u0026gt;\u0026gt;\u0026gt; customEventTranslators) Sets a map containing the event translation functions of specific resources.\nParameters:\ncustomEventTranslators: A map containing the resource names as keys and the translation functions as values. Returns: The builder instance.\nUsage and examples As with property translators, event translators are used to process the incoming event messages before updating the Digital Twin State.\nThey can be set by passing a lambda function to the previously shown methods, as shown in the following example:\nbuilder.setDefaultEventTranslator((key, message) -\u0026gt; { // Instantiate events list List\u0026lt;WldtEvent\u0026lt;String\u0026gt;\u0026gt; events = new ArrayList\u0026lt;\u0026gt;(); try { // Add received event to the list events.add(new PhysicalAssetEventWldtEvent\u0026lt;\u0026gt;(key, message)); } catch (EventBusException e) { e.printStackTrace(); } // Return list of events return events; }) WLDT actions to CoAP requests setDefaultActionEventTranslator CoapPhysicalAdapterConfigurationBuilder setDefaultActionEventTranslator(Function\u0026lt;PhysicalAssetActionWldtEvent\u0026lt;?\u0026gt;, Request\u0026gt; defaultActionEventTranslator) Sets the default function to convert a WLDT action event into the request to send to the Physical Asset.\nParameters:\ndefaultActionEventTranslator: A function which receives as input the action event and returns a CoAP request. Returns: The builder instance.\nsetCustomActionEventTranslators CoapPhysicalAdapterConfigurationBuilder setCustomActionEventTranslators(Map\u0026lt;String, Function\u0026lt;PhysicalAssetActionWldtEvent\u0026lt;?\u0026gt;, Request\u0026gt;\u0026gt; customActionEventTranslators) Sets a map containing the action translation functions of specific resources.\nParameters:\ncustomActionEventTranslators: A map containing the resource names as keys and the translation functions as values Returns: The builder instance.\nUsage and examples Action translators are used to process an incoming physical action and create an associated request which will be sent to the Physical Asset.\nThey can be set by passing a lambda function to the previously shown methods, as shown in the following example:\n.setDefaultActionEventTranslator(event -\u0026gt; { // Create request with method based on event body presence Request request = new Request(event.getBody().equals(\u0026#34;\u0026#34;) ? CoAP.Code.POST : CoAP.Code.PUT); // Set request confirmability request.setConfirmable(true); // Set request payload request.setPayload((String) event.getBody()); // Return created request return request; }) Resource updates listening setAutomaticResourceListening CoapPhysicalAdapterConfigurationBuilder setAutomaticResourceListening(boolean enable) Enables/disables the automatic resource listening process of the Physical Adapter. If enabled the Adapter will listen to every resource for both property updates and events.\nParameters:\nenable: A flag indicating whether to enable or disable automatic resource listening. Returns: The builder instance.\nsetCustomResourceListeningMap CoapPhysicalAdapterConfigurationBuilder setCustomResourceListeningMap(Map\u0026lt;String, PhysicalAssetResourceListener.ListenerType\u0026gt; customResourceListeningMap) Adds a map of resources that the Physical Adapter will listen to, specifying if it has to listen to property updates, events, or both.\nIf automatic resource listening is enabled this map will be ignored since the Adapter will automatically listen to everything.\nParameters:\ncustomResourceListeningMap: A map having the name of the resource as key and what to listen to as a value (instance of PhysicalAssetResourceListener.ListenerType). Returns: The builder instance.\nWLDT events management setDefaultEventType CoapPhysicalAdapterConfigurationBuilder setDefaultEventType(String eventType) Sets the default WLDT event notification type.\nParameters:\neventType: The WLDT event notification type Returns: The builder instance.\naddCustomEventType CoapPhysicalAdapterConfigurationBuilder addCustomEventType(String resourceName, String eventType) Adds a WLDT event notification type only to the specified resource.\nParameters:\nresourceName: The resource to apply the type to. eventType: The WLDT event notification type. Returns: The builder instance.\nWLDT actions management setDefaultActuatorActionType CoapPhysicalAdapterConfigurationBuilder setDefaultActuatorActionType(String actionType) Sets the default WLDT action type for CoAP resources supporting both POST \u0026amp; PUT requests.\nParameters:\nactionType: The WLDT action type Returns: The builder instance.\nsetDefaultPostActionType CoapPhysicalAdapterConfigurationBuilder setDefaultPostActionType(String actionType) Sets the default WLDT action type for CoAP resources supporting only POST requests.\nParameters:\nactionType: The WLDT action type Returns: The builder instance.\nsetDefaultPutActionType CoapPhysicalAdapterConfigurationBuilder setDefaultPutActionType(String actionType) Sets the default WLDT action type for CoAP resources supporting only PUT requests.\nParameters:\nactionType: The WLDT action type Returns: The builder instance.\naddCustomActionType CoapPhysicalAdapterConfigurationBuilder addCustomActionType(String resourceName, String actionType) Adds a WLDT action type only to the specified resource supporting both POST \u0026amp; PUT requests.\nParameters:\nresourceName: The resource to apply the type to. actionType: The WLDT action type. Returns: The builder instance.\nBuild After all the configuration is completed, the CoapPhysicalAdapterConfiguration instance can be retreived by using the build() method:\nCoapPhysicalAdapterConfiguration build() throws CoapPhysicalAdapterConfigurationException This method checks that everything needed is provided correctly and, if so, processes the manually added resources adding them to the configuration.\nReturns: The configuration instance\nThrows: CoapPhysicalAdapterConfigurationException - In the case of the configuration being invalid.\nYAML Configuration The CoapPhysicalAdapter can be configured using a YAML file, which allows for easy configuration management and sharing.\nThe YAML file should follow the structure defined of the CoapPhysicalAdapterConfigurationData class, which contains all the deserialized data. The YAML configuration can be loaded into a CoapPhysicalAdapterConfigurationBuilder using the static fromYaml(File yamlConfig) method contained in the CoapPhysicalAdapterConfiguration class.\nBelow are an example of how to load a YAML configuration file and which parameters it can contain:\nCoapPhysicalAdapterConfiguration configuration = CoapPhysicalAdapterConfiguration.fromYaml(new File( CoapPhysicalAdapterYamlTest.class .getClassLoader() .getResource(\u0026#34;paconfig.yaml\u0026#34;) .toURI())) [...] .build(); ip: \u0026lt;string\u0026gt; # Physical Asset\u0026#39;s IP address port: \u0026lt;int\u0026gt; # Physical Asset\u0026#39;s CoAP server port preferredContentFormat: \u0026lt;int\u0026gt; # CoAP content format value, e.g.: text/plain=0, application/json = 50, ... observabilitySupport: \u0026lt;boolean\u0026gt; # Enables/disables the observability autoUpdateTimerSupport: \u0026lt;boolean\u0026gt; # Enables/disables the polling autoUpdateInterval: \u0026lt;int\u0026gt; # Polling interval in milliseconds resourceDiscoverySupport: \u0026lt;boolean\u0026gt; # Enables/disables the resource discovery ignoredResources: # List of resources to ignore during the resource discovery - \u0026lt;string\u0026gt; - \u0026lt;string\u0026gt; defaultWldtEventType: \u0026lt;string\u0026gt; # Default WLDT event notification type customWldtEventTypes: # Map of custom WLDT event notification types \u0026lt;event_name_1\u0026gt;: \u0026lt;string\u0026gt; \u0026lt;event_name_2\u0026gt;: \u0026lt;string\u0026gt; defaultWldtActionType: \u0026lt;string\u0026gt; # Default WLDT action type for resources supporting both POST \u0026amp; PUT requests defaultWldtPostActionType: \u0026lt;string\u0026gt; # Default WLDT action type for resources supporting only POST requests defaultWldtPutActionType: \u0026lt;string\u0026gt; # Default WLDT action type for resources supporting only PUT requests customWldtActionTypesMap: # Map of custom WLDT action types \u0026lt;action_name_1\u0026gt;: \u0026lt;string\u0026gt; \u0026lt;action_name_2\u0026gt;: \u0026lt;string\u0026gt; defaultActuatorWldtActionContentType: \u0026lt;string\u0026gt; # Default WLDT action content type for resources supporting both POST \u0026amp; PUT requests defaultPostWldtActionContentType: \u0026lt;string\u0026gt; # Default WLDT action content type for resources supporting only POST requests defaultPutWldtActionContentType: \u0026lt;string\u0026gt; # Default WLDT action content type for resources supporting only PUT requests customWldtActionContentTypesMap: # Map of custom WLDT action content types \u0026lt;action_name_1\u0026gt;: \u0026lt;string\u0026gt; \u0026lt;action_name_2\u0026gt;: \u0026lt;string\u0026gt; resourceNotificationSupport: \u0026lt;boolean\u0026gt; # Enables/disables the automatic resource listening customResourceListeningMap: # Map of resources to listen to, specifying if it has to listen to property updates, events, or both \u0026lt;resource_name_1\u0026gt;: \u0026lt;listener_type\u0026gt; # listener_type can be \u0026#34;BOTH\u0026#34;, \u0026#34;PROPERTY\u0026#34; or \u0026#34;EVENT\u0026#34; \u0026lt;resource_name_2\u0026gt;: \u0026lt;listener_type\u0026gt; Integrated example This example demonstrates the integration of a CoapPhysicalAdapter within a Digital Twin setup, where multiple adapters (including a console adapter) are added to a Digital Twin, and the overall system is managed by a DigitalTwinEngine.\n// Create the Digital Twin Engine DigitalTwinEngine engine = new DigitalTwinEngine(); //[...] // Create a Digital Twin with a default shadowing function DigitalTwin dt = new DigitalTwin(\u0026#34;coap-digital-twin\u0026#34;, new DefaultShadowingFunction()); // Create an instance of ConsoleDigitalAdapter ConsoleDigitalAdapter digitalAdapter = new ConsoleDigitalAdapter(); // Create an instance of CoapPhysicalAdapterConfiguration, enabling resource discovery, observability and polling, and setting simple property, event, and action translators CoapPhysicalAdapterConfiguration configuration = CoapPhysicalAdapterConfiguration.builder(serverAddress, serverPort) .enableResourceDiscoverySupport(true) .enableObservability(true) .enableAutoUpdateTimer(true) .setAutoUpdateInterval(5000) .setPreferredContentFormat(MediaTypeRegistry.APPLICATION_JSON) .setDefaultPropertyBodyTranslator((key, payload) -\u0026gt; { List\u0026lt;WldtEvent\u0026lt;String\u0026gt;\u0026gt; events = new ArrayList\u0026lt;\u0026gt;(); try { events.add(new PhysicalAssetPropertyWldtEvent\u0026lt;\u0026gt;(key, new String(payload))); } catch (EventBusException e) { e.printStackTrace(); } return events; }) .setDefaultEventTranslator((key, message) -\u0026gt; { List\u0026lt;WldtEvent\u0026lt;String\u0026gt;\u0026gt; events = new ArrayList\u0026lt;\u0026gt;(); try { events.add(new PhysicalAssetEventWldtEvent\u0026lt;\u0026gt;(key, message)); } catch (EventBusException e) { e.printStackTrace(); } return events; }) .setDefaultActionEventTranslator(event -\u0026gt; { Request request; request = new Request(event.getBody().equals(\u0026#34;\u0026#34;) ? CoAP.Code.POST : CoAP.Code.PUT); request.setConfirmable(true); request.setPayload((String) event.getBody()); return request; }) .build(); CoapPhysicalAdapter physicalAdapter = new CoapPhysicalAdapter(\u0026#34;coap-test-physical-adapter\u0026#34;, configuration); dt.addPhysicalAdapter(physicalAdapter); // [...] engine.addDigitalTwin(dt); engine.startAll(); Since the resource discovery is enabled, the PAD gets automatically generated based on it, but in case it\u0026rsquo;s needed it\u0026rsquo;s possible to manually add resources using the addResource method\n","date":"January 8, 2026","id":21,"permalink":"/docs/adapters/coap-physical-adapter/","summary":"The CoapPhysicalAdapter acts as a bridge between the Digital Twin and the Physical Assets, leveraging the CoAP protocol for communication. It implements various features, which can be enabled or disabled via the usage of a builder-based configuration, which also allows the implementation of custom behavior where needed.","tags":"","title":"CoAP Physical Adapter"},{"content":"The CoapDigitalAdapter acts as a bridge between a Digital Twin and CoAP-based applications, allowing developers to easily expose and interact with Digital Twin data and functionalities over CoAP.\nKey features:\nConfiguration builder: The Adapter configuration is managed via the builder provided by the CoapDigitalAdapterConfiguration.build() method, which enables users to effortlessly configure the CoAP server parameters and each Adapter\u0026rsquo;s feature. Resource discovery: The server exposes resource discovery on the default /.well-known/core resource, making it possible for applications to implement automations based on the discovered resources list. Default resources tree: The adapter is set to make the server expose a default resources tree, so that the resources can be queried even without discovering resources beforehand. Observability: Each resource exposing a dynamic value supports CoAP observability, making it possible for applications to stay updated with the latest DT State updates. Storage \u0026amp; Query: Starting from version 0.1.1 the CoAP Digital Adapter is able to retrieve Storage Statistics and run queries on the target DT. WLDT-Core Version Compatibility coap-physical-adapter wldt-core 0.2.1 wldt-core 0.3.0 wldt-core 0.4.0 0.1.1 âŒ âŒ âœ… Installation To use the adapter in your Java project, you can include it as a dependency using Maven or Gradle.\nMaven \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.github.wldt\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;coap-digital-adapter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.1.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Gradle implementation(\u0026#34;io.github.wldt:coap-digital-adapter:0.1.1\u0026#34;) Class Structure \u0026amp; Functionalities CoapDigitalAdapter The CoapDigitalAdapter class is the core component responsible for handling CoAP requests and interacting with the underlying Digital Twin.\nKey-Functionalities:\nCoAP endpoints: Provides a set of CoAP endpoints to interact with the Digital Twin State updates: Automatically reflects changes in the Digital Twin state to the CoAP endpoints, ensuring real-time information. Event handling: Listens for Digital Twin events and provides events notifications to CoAP clients. Here is a basic example illustrating how to use the CoAP Digital Adapter:\nGetting started Create the Digital Twin:\nDigitalTwin digitalTwin = new DigitalTwin(\u0026#34;my-digital-twin\u0026#34;, new DefaultShadowingFunction()); Build the configuration:\nCoapDigitalAdapterConfiguration config = CoapDigitalAdapterConfiguration.builder(5683) // Configure the adapter [...] .build(); Instantiate a CoAP Digital Adapter:\nCoapDigitalAdapter coapDigitalAdapter = new CoapDigitalAdapter(config); // Add a Physical Adapter to the DT [...] Add the CoAP Digital Adapter to the Digital Twin:\ndigitalTwin.addDigitalAdapter(coapDigitalAdapter); Start the Digital Twin Engine:\nDigitalTwinEngine digitalTwinEngine = new DigitalTwinEngine(); digitalTwinEngine.addDigitalTwin(digitalTwin); digitalTwinEngine.startAll(); Note: to make the Adapter able to retrieve data regarding the Digital Twin instance it\u0026rsquo;s necessary to specifically add the Digital Twin instance in the configuration:\nCoapDigitalAdapterConfiguration config = CoapDigitalAdapterConfiguration.builder() .setDigitalTwinInstance(digitalTwin) // Configure the adapter [...] .build(); CoapDigitalAdapterConfiguration The CoapDigitalAdapterConfiguration class is a crucial part of the CoAP Digital Adapter, allowing developers to configure the behaviour of the Adapter to meet their needs.\nAn instance of this class is required by the CoapDigitalAdapter constructor, and can be generated by building it via the CoapDigitalAdapterConfigurationBuilder class.\nCoapDigitalAdapterConfigurationBuilder The CoapDigitalAdapterConfigurationBuilder class makes it possible to create a CoapDigitalAdapterConfiguration instance, by calling the apposite build() method at the end of the configuration process.\nThe builder can be retrieved by calling the builder() static method contained in CoapDigitalAdapterConfiguration.\nA builder can also be retrieved from a YAML file, by calling the fromYaml(File yamlConfig) static method contained in CoapDigitalAdapterConfiguration.\nFollowing there is an overview of each method which can be called on the builder to create the configuration instance. Each of these methods is optional, but makes it possible to use different capabilities of the Adapter or to customize their behaviour based on the specific needs:\nDigital Twin instance setDigitalTwinInstance(DigitalTwin digitalTwin): Sets the Digital Twin instance for which the CoAP server will be configured. This instance will be used to expose a /instance CoAP endpoint that provides information about the Digital Twin. CoRE setCoreRT(CoreRT coreRT): Sets the CoRE resource types which will be assigned to each resource based on its scope. If no resource types are set, the default resource types will be used.\nsetCoreIF(CoreIF coreIF): Sets the CoRE interfaces which will be assigned to each resource based on its scope. If no interfaces are set, the default interfaces will be used.\nsetCoreCT(CoreCT coreCT): Sets the CoRE content types which will be assigned to each resource based on its scope. If no content types are set, the default content types will be used.\nRequest handlers If for any reason there\u0026rsquo;s the necessity to change the behaviour of the responses, each request handler can be modified to better suit the use cases via the following methods:\nsetGetRequestHandlers(GetRequestHandlers getRequestHandlers): Sets the handlers for GET requests. These handlers will be invoked when the CoAP server receives GET requests on the resources. If no handlers are set, the default handlers will be used. setPostRequestHandlers(PostRequestHandlers postRequestHandlers): Sets the handlers for POST requests. These handlers will be invoked when the CoAP server receives POST requests on the resources. If no handlers are set, the default handlers will be used. setPutRequestHandlers(PutRequestHandlers putRequestHandlers): Sets the handlers for PUT requests. These handlers will be invoked when the CoAP server receives PUT requests on the resources. If no handlers are set, the default handlers will be used. Filters Filters allow to make so that only a specified set of Digital Twin state events are accessible from the client. If no filter is added, the Adapter will automatically create a CoAP endpoint for each state event. To add a filter for a specified state event the following methods can be used:\naddPropertyFilter(String propertyKey): Adds a property to the filter. addEventFilter(String eventKey): Adds an event to the filter. addActionFilter(String actionKey): Adds an action to the filter. addRelationshipFilter(String relationshipName): Adds a relationship to the filter. Note: For each method to add a filter exists a method with the same name which, instead of a String, accepts as a parameter a Collection\u0026lt;String\u0026gt; containing all the state events of that type to add to the filter.\nCoAP Server Endpoints The Adapter\u0026rsquo;s CoAP server exposes a set of resources which allow the users to interact with the DT instance, retrieve its state, read properties, actions, events and relationships description, and trigger actions.\nThe available endpoints, each with its associated methods and default behaviour, are the following:\n/instance GET: Retrieves information about the Digital Twin instance. /state GET: Retrieves the current state of the Digital Twin. /state/previous GET: Retrieves the previous state of the Digital Twin. /state/changes GET: Retrieves the list of state changes in the Digital Twin. /state/properties GET: Retrieves the list of properties in the Digital Twin state. /state/properties/{propertyKey} GET: Retrieves the specified property in the Digital Twin state. /state/properties/{propertyKey}/value GET: Retrieves the value of a property in the Digital Twin state. /state/events GET: Retrieves the list of events in the Digital Twin state. /state/events/notifications GET: Retrieves the list of event notifications received by the Digital Twin. /state/events/{eventKey} GET: Retrieves the specified event in the Digital Twin state. /state/actions GET: Retrieves the list of actions in the Digital Twin state. /state/actions/{actionKey} GET: Retrieves a specific action in the Digital Twin state. POST: Triggers the specified action in the Digital Twin state. By default it does not expect a payload. PUT: Triggers the specified action in the Digital Twin state. By default it does expect a payload. /state/relationships GET: Retrieves the list of relationships in the Digital Twin state. /state/relationships/{relationshipName} GET: Retrieves the specified relationship in the Digital Twin state. /state/relationships/{relationshipName}/instances GET: Retrieves the instances of the specified relationship in the Digital Twin state. /storage GET: Retrieves Storage Statistics from the target Digital Twin. PUT: Allows the execution of a query, where the query structure is specified through a JSON Message in the request body. For additional information about the Query System see Query System Page. Note: Replace {propertyKey}, {eventKey}, {actionKey}, and {relationshipName} with the actual values you want to retrieve or trigger. Make sure to use the appropriate CoAP method (GET, POST, PUT) and include any required parameters or payload.\nYAML Configuration As specified in the CoapDigitalAdapterConfigurationBuilder section, it is possible to create a configuration from a YAML file.\nThe YAML configuration file should follow the structure of the CoapDigitalAdapterConfigurationData class, which is the class the file is deserialized into.\nFollowing is an overview of the YAML configuration file structure:\nport: \u0026lt;port_number\u0026gt; propertyFilter: - \u0026#34;\u0026lt;property_key_1\u0026gt;\u0026#34; - \u0026#34;\u0026lt;property_key_2\u0026gt;\u0026#34; actionFilter: - \u0026#34;\u0026lt;action_key_1\u0026gt;\u0026#34; - \u0026#34;\u0026lt;action_key_2\u0026gt;\u0026#34; eventFilter: - \u0026#34;\u0026lt;event_key_1\u0026gt;\u0026#34; - \u0026#34;\u0026lt;event_key_2\u0026gt;\u0026#34; relationshipFilter: - \u0026#34;\u0026lt;relationship_name_1\u0026gt;\u0026#34; - \u0026#34;\u0026lt;relationship_name_2\u0026gt;\u0026#34; coreRT: \u0026lt;resource_scope_1\u0026gt;: \u0026#34;\u0026lt;core_rt_value_1\u0026gt;\u0026#34; \u0026lt;resource_scope_2\u0026gt;: \u0026#34;\u0026lt;core_rt_value_2\u0026gt;\u0026#34; coreIF: \u0026lt;resource_scope_1\u0026gt;: \u0026#34;\u0026lt;core_if_value_1\u0026gt;\u0026#34; \u0026lt;resource_scope_2\u0026gt;: \u0026#34;\u0026lt;core_if_value_2\u0026gt;\u0026#34; coreCT: \u0026lt;resource_scope_1\u0026gt;: \u0026#34;\u0026lt;core_ct_value_1\u0026gt;\u0026#34; \u0026lt;resource_scope_2\u0026gt;: \u0026#34;\u0026lt;core_ct_value_2\u0026gt;\u0026#34; Examples YAML Configuration Example To load a YAML configuration file, you can use the fromYaml(File yamlConfig) method of the CoapDigitalAdapterConfiguration class. Below is an example of how to load a YAML configuration file called daconfig.yaml, followed by a configuration example:\n[...] CoapDigitalAdapterConfiguration configuration = CoapDigitalAdapterConfiguration.fromYaml(new File( TestMain.class .getClassLoader() .getResource(\u0026#34;daconfig.yaml\u0026#34;) .toURI())); [...] port: 5683 coreRT: dtInstance: \u0026#34;digitaltwin.instance\u0026#34; state: \u0026#34;digitaltwin.state\u0026#34; previousState: \u0026#34;digitaltwin.state.previous\u0026#34; coreIF: dtInstance: \u0026#34;core.p\u0026#34; state: \u0026#34;core.p\u0026#34; propertyFilter: - \u0026#34;energy\u0026#34; eventFilter: - \u0026#34;overheating\u0026#34; Integrated example This example demonstrates the integration of a CoapDigitalAdapter within a Digital Twin setup, where multiple adapters are added to a Digital Twin, and the overall system is managed by a DigitalTwinEngine.\n// Create Digital Twin instance DigitalTwin dt = new DigitalTwin(\u0026#34;coap-digital-twin\u0026#34;, new DefaultShadowingFunction()); // Add Physical Adapters dt.addPhysicalAdapter(new DummyPhysicalAdapter(\u0026#34;test-pa\u0026#34;)); dt.addPhysicalAdapter(createPhysicalAdapter(\u0026#34;test-pa-2\u0026#34;, Arrays.asList(\u0026#34;temperature\u0026#34;, \u0026#34;volume\u0026#34;))); dt.addPhysicalAdapter(createPhysicalAdapter(\u0026#34;test-pa-3\u0026#34;, Arrays.asList(\u0026#34;intensity\u0026#34;, \u0026#34;color\u0026#34;))); // Build CoAP Digital Adapter configuration, setting only the port and the DT instance CoapDigitalAdapterConfiguration coapDigitalAdapterConfiguration = CoapDigitalAdapterConfiguration.builder(5683) .setDigitalTwinInstance(dt) .build(); // Instantiate a CoAP Digital Adapter and add it to the Digital Twin coapDigitalAdapter = new CoapDigitalAdapter(\u0026#34;coap-da\u0026#34;, coapDigitalAdapterConfiguration); dt.addDigitalAdapter(coapDigitalAdapter); // Instantiate WLDT Storage and add it to the DT wldtStorage = new DefaultWldtStorage(\u0026#34;test-storage\u0026#34;, true); dt.getStorageManager().putStorage(wldtStorage); // Create DT engine engine = new DigitalTwinEngine(); // Add DT to the engine and start it engine.addDigitalTwin(dt); engine.startAll(); Using custom request handlers The following example demonstrates the creation of a configuration with a custom request handler to manage a POST request different from the default one:\nCoapDigitalAdapterConfiguration coapDigitalAdapterConfiguration = CoapDigitalAdapterConfiguration.builder(5683) .setDigitalTwinInstance(dt) .setPostRequestHandlers(new PostRequestHandlers() {{ setStateActionHandler((exchange, configuration, optional) -\u0026gt; { // Check that the request does not have a payload if (exchange.getRequestPayload().length != 0) { exchange.respond(CoAP.ResponseCode.BAD_REQUEST, \u0026#34;Payload not allowed\u0026#34;); return Optional.empty(); } // Check that the action optional is present if (!optional.isPresent()) { exchange.respond(CoAP.ResponseCode.NOT_FOUND); return Optional.empty(); } // Get the action from the optional DigitalTwinStateAction action = optional.get(); try { // Create a new action event DigitalActionWldtEvent\u0026lt;?\u0026gt; event = new DigitalActionWldtEvent\u0026lt;\u0026gt;(action.getKey()); event.setType(DummyPhysicalAdapter.TYPE_ACTION_TOGGLE); // Respond to the client exchange.respond(CoAP.ResponseCode.CHANGED); // Return the event to be invoked return Optional.of(event); } catch (EventBusException e) { // If the event creation goes wrong respond with an internal server error code exchange.respond(CoAP.ResponseCode.INTERNAL_SERVER_ERROR); return Optional.empty(); } }); }}) .build(); Storage query request payloads Example of Storage Query Requests are the following:\nRetrieve the first 4 Digital Twin State Variations { \u0026#34;resourceType\u0026#34;: \u0026#34;DIGITAL_TWIN_STATE\u0026#34;, \u0026#34;queryType\u0026#34;: \u0026#34;SAMPLE_RANGE\u0026#34;, \u0026#34;startIndex\u0026#34;: 0, \u0026#34;endIndex\u0026#34;: 3 } Retrieve Digital Twin State Variations in a Time Range { \u0026#34;resourceType\u0026#34;: \u0026#34;DIGITAL_TWIN_STATE\u0026#34;, \u0026#34;queryType\u0026#34;: \u0026#34;TIME_RANGE\u0026#34;, \u0026#34;startIndex\u0026#34;: 161989898, \u0026#34;endIndex\u0026#34;: 162989898 } Retrieve the last Digital Twin State { \u0026#34;resourceType\u0026#34;: \u0026#34;DIGITAL_TWIN_STATE\u0026#34;, \u0026#34;queryType\u0026#34;: \u0026#34;LAST_VALUE\u0026#34; } ","date":"January 8, 2026","id":22,"permalink":"/docs/adapters/coap-digital-adapter/","summary":"The CoapDigitalAdapter acts as a bridge between a Digital Twin and CoAP-based applications, allowing developers to easily expose and interact with Digital Twin data and functionalities over CoAP.","tags":"","title":"CoAP Digital Adapter"},{"content":"The version 0.5.0 of the Digital Twin library introduced the concept of Digital Twin Resources and a Management Interface for runtime configuration and management. These features have the aim to empower developers to create more dynamic, adaptable, and interactive Digital Twins that can be tailored to specific application needs.\nðŸ§© Digital Twin Resources \u0026amp; Management Interface New classes have been introduced to enable a flexible, runtime-manageable resource model within each instance of a Digital Twin. These abstractions are designed to support extensibility, configurability, and interoperability across both internal DT logic and external applications.\nâœ¨ Key Features Unified Resource Model: Resources represent configurable parameters or entities that influence DT behavior. Internal and External Access: Resources can be used by DT logic, and accessed or modified externally via a dedicated Management Interface. Runtime Management: Values can be configured at startup and dynamically updated at runtime. ðŸ—ï¸ Design Principles Resources are user-defined and customizable. They are integrated into various parts of the DT (e.g., shadowing functions). DT behavior adapts dynamically based on resource states. âš ï¸ Developer Notice: The core of the Digital Twin library only provides an abstract interface for the Management Interface. It is the responsibility of the developer to implement the actual logic for exposing and interacting with resources through this interface (e.g., via REST, MQTT, gRPC, etc.). This design ensures modularity and flexibility, allowing integration with various protocols and platforms tailored to specific application requirements, without increasing the size or complexity of the core library or introducing strong dependencies on external libraries.\nðŸ“š Example 1: Temperature Threshold Event Triggering A Digital Twin that monitors a physical asset with temperature sensors may need to detect thermal anomalies based on configurable thresholds.\nðŸ› ï¸ Resources Used Resource Name Type Purpose target_value double Maximum allowed temperature before triggering an alert n int Number of consecutive samples required for anomaly detection time_window long Time duration (e.g., in seconds) over which n samples are evaluated ðŸ” Shadowing Function Usage DT receives periodic temperature samples from the physical device. If n samples in the last time_window exceed target_value, a temperature-alert-event is generated. The DT Resource Manager holds and manages these three parameters. External applications can read or update the threshold values at: Startup time: for initialization. Runtime: via the DT Management Interface that the developer can implement supporting for example RESTful or Pub/Sub interaction pattern. ðŸ“š Example 2: Motor Speed Regulation with Safety Limit In a Digital Twin for an industrial motor, speed regulation may depend on a maximum speed constraint that can vary based on maintenance schedules or environmental conditions.\nðŸ› ï¸ Resources Used Resource Name Type Purpose max_speed_rpm int Maximum allowed speed in RPM emergency_stop_delay long Delay before activating safety shutdown after a violation speed_adjust_factor double Modifier applied to current speed under certain conditions ðŸ” Shadowing Function Usage DT continuously mirrors the motorâ€™s operational speed. If max_speed_rpm is exceeded, and speed is not reduced within emergency_stop_delay, the DT issues a safety-shutdown-command. speed_adjust_factor is used during load balancing or environmental compensation. All parameters are exposed via the DTâ€™s Resource Manager and can be tuned in real-time by an operator or maintenance AI. ðŸ§± Resources \u0026amp; Management Interface Main Classes The following classes define the foundation of the Digital Twin resource management framework. They support runtime configuration, monitoring, and control of internal and external components through a consistent and extensible model. These abstractions are designed to support both the internal logic of the Digital Twin and external applications interacting through a Management Interface.\nThe schematic description of the new introduced classes is structured as follows:\nManagedResource: The ManagedResource class represents an abstract, generic resource that can be configured and managed at runtime. Each resource is uniquely identified and carries a type and name. It encapsulates the actual resource object, such as a configuration parameter or operational constraint. This class provides a standard interface for Create, Read, Update, and Delete (CRUD) operations. Additionally, it supports the registration of observers, allowing other components or systems to receive notifications when the resource is modified. Designed to be extended, ManagedResource allows developers to implement specific resource types suited to their application. It can be used directly by the Digital Twin\u0026rsquo;s internal logic or accessed externally via the Management Interface. The developer can internally define sub-resource of the original resource (e.g., a specific key-value mapping in a dictionary) and the access of sub-resources can be handled by the ResourceRequest and the associated ResourceResponse. ResourceManager: The ResourceManager serves as the central registry and orchestrator for all managed resources in a Digital Twin instance. It is responsible for managing the entire resource lifecycle, including creation, lookup, update, and removal. This class provides an API through which both the internal logic of the Digital Twin and external clients (via the Management Interface) can consistently interact with resources. It ensures that resource access is coordinated and properly controlled, supporting integrity and safe concurrent operations. The ResourceManager plays a key role in decoupling the internal components from external systems, simplifying integration and improving maintainability. The ResourceManager has been added to the core DigitalTwin and DigitalTwinModel classes in order to be properly initialized and the make is usable through the DT instance and in particular in the shadowingFunction and it is accessible on a DigitalTwin instance through the method digitalTwin.getResourceManager(). ResourceRequest: The ResourceRequest class encapsulates the details required to perform an operation on a managed resource. It typically includes a target resource identifier, optional sub-resource identifiers (useful for hierarchical or composite resources), and a payload carrying the specific data for the operation. By abstracting the invocation of resource operations from their implementation, this class enables flexible and extensible workflows that support different transport or protocol layers, such as REST or Pub/Sub. The library currently supports requests targeting a specific resource and one level of sub-resources. To handle deeper hierarchies of sub-resources, developers will need to extend the existing library functionalities with custom implementations. ResourceResponse: The ResourceResponse class represents the result of a resource operation. It contains the outcome of the requested action, including any output data and status information. If an error occurred during the operation, relevant error details are also included. This class ensures a consistent way to communicate results, whether the request originates from internal Digital Twin components or external systems. ManagementInterface: The ManagementInterface defines the external API through which runtime resource operations can be performed by remote applications or tools. It exposes methods or endpoints for creating, reading, updating, and deleting resources, as well as querying their current status and subscribing to events. This interface acts as a bridge between the Digital Twinâ€™s internal resource model and external systems, enabling dynamic and secure interaction with configurable parameters and operational data. The core library only defines the abstract contract for this interface. Developers must provide a concrete implementation, which can be based on any desired communication protocol such as REST, MQTT, or gRPC, depending on system requirements. The ManagementInterface can be set on the DT through the method setManagementInterface(managementInterface) on the DigitalTwin instance. These core classes establish a robust and extensible architecture for runtime resource management. They provide a unified model that supports internal orchestration and external integration. By promoting clear separation of concerns, consistency in interactions, and modular design, they make the Digital Twin framework more adaptable, maintainable, and suitable for a wide range of IoT and IIoT applications.\nðŸ”§ Using the Management Interface in Your Digital Twin This section demonstrates how to set up a DigitalTwin with ResourceManager custom ManagedResource(s) and a dedicated testing ManagementInterface to register a resource, and perform read operations using ResourceRequest and ResourceResponse.\n1. Create a Custom Managed Resource Start by creating a Custom ManagedResource called as DictionaryManagedResource to handle DT\u0026rsquo;s configuration as a basic key-value dictionary:\nimport java.util.HashMap; import java.util.Map; public class DictionaryManagedResource extends ManagedResource\u0026lt;Map\u0026lt;String, Object\u0026gt;, Object, Object\u0026gt; { public DictionaryManagedResource(String id, String type, String name, Map\u0026lt;String, Object\u0026gt; dictionary) { super(id, type, name, dictionary); } public DictionaryManagedResource(String id, String type, String name) { super(id, type, name, new HashMap\u0026lt;\u0026gt;()); } @Override protected ResourceResponse\u0026lt;Object\u0026gt; onCreate(ResourceRequest\u0026lt;Object\u0026gt; resourceRequest) { // In this case the creation means adding a new key-value pair to the dictionary // so we have to take the sub-resource ID as the key and the content as the value since // the resource ID is the ID of the dictionary itself. if (resourceRequest == null || resourceRequest.getResourceId() == null || resourceRequest.getContent() == null || resourceRequest.getSubResourceId().isEmpty()) return new ResourceResponse\u0026lt;Object\u0026gt;(400, \u0026#34;Invalid Resource Request!\u0026#34;); String key = resourceRequest.getSubResourceId(); Object value = resourceRequest.getContent(); resource.put(key, value); return new ResourceResponse\u0026lt;Object\u0026gt;(resourceRequest.getResourceId(), key, value, null); } @Override protected ResourceResponse\u0026lt;Object\u0026gt; onRead(ResourceRequest\u0026lt;Object\u0026gt; resourceRequest) { // Validate the resource request if(resourceRequest == null || resourceRequest.getResourceId() == null) return new ResourceResponse\u0026lt;Object\u0026gt;(400, \u0026#34;Invalid Resource Request!\u0026#34;); // Validate resource id to ensure it is not empty and matches the managed resource ID if(resourceRequest.getResourceId().isEmpty() || !resourceRequest.getResourceId().equals(this.getId())) return new ResourceResponse\u0026lt;Object\u0026gt;(400, \u0026#34;Resource ID cannot be empty or does not match the managed resource ID!\u0026#34;); // Check if the request is for a sub-resource associated to a key in the dictionary if (resourceRequest.getSubResourceId() != null \u0026amp;\u0026amp; !resourceRequest.getSubResourceId().isEmpty()) { String subResourceKey = resourceRequest.getSubResourceId(); Object subResourceValue = resource.get(subResourceKey); return new ResourceResponse\u0026lt;Object\u0026gt;(this.getId(), subResourceKey, subResourceValue, null); } // If no sub-resource is specified, return the entire dictionary else { return new ResourceResponse\u0026lt;Object\u0026gt;(this.getId(), resource, null); } } @Override protected ResourceResponse\u0026lt;Object\u0026gt; onUpdate(ResourceRequest\u0026lt;Object\u0026gt; resourceRequest) { // The key is the sub-resource ID and the value is the content of the request. String key = resourceRequest.getSubResourceId(); Object value = resourceRequest.getContent(); resource.put(key, value); return new ResourceResponse\u0026lt;Object\u0026gt;(resourceRequest.getResourceId(), value, null); } @Override protected ResourceResponse\u0026lt;Object\u0026gt; onDelete(ResourceRequest\u0026lt;Object\u0026gt; resourceRequest) { // The key is the sub-resource ID and the value is the content of the request. String key = resourceRequest.getSubResourceId(); Object value = resource.remove(key); return new ResourceResponse\u0026lt;Object\u0026gt;(resourceRequest.getResourceId(), value, null); } } In this case, the resource is represented by a dictionary implemented using a HashMap. The main resource corresponds to the map itself, while sub-resources refer to the individual first-level entries within the map. Each sub-resource can be accessed using a ResourceRequest by specifying the appropriate string key. The library currently supports requests for a specific resource and a single level of sub-resources. To manage deeper hierarchical structures, developers will need to extend the library with custom implementations.\n2. Create and Configure the Digital Twin Create the DigitalTwinEngine and your DigitalTwin. You also need to register physical and digital adapters, and configure your custom DictionaryManagedResource instance previously created.\nâš ï¸ The following code is just an example to make the overall example readable but it should be customized according to your Digital Twin implementation and available physical and digital adapters.\n// Create the Digital Twin Engine DigitalTwinEngine digitalTwinEngine = new DigitalTwinEngine(); // Create the new Digital Twin with our Shadowing Function DigitalTwin digitalTwin = new DigitalTwin(TEST_DIGITAL_TWIN_ID, new DemoShadowingFunction()); // Physical Adapter with Configuration digitalTwin.addPhysicalAdapter( new DemoPhysicalAdapter( \u0026#34;test-physical-adapter\u0026#34;, new DemoPhysicalAdapterConfiguration() )); // Digital Adapter with Configuration digitalTwin.addDigitalAdapter( new DemoDigitalAdapter( \u0026#34;test-digital-adapter\u0026#34;, new DemoDigitalAdapterConfiguration()) ); Now we can initialize our custom ManagedResource called as DictionaryManagedResource to handle DT\u0026rsquo;s configuration as a basic key-value dictionary:\n// Create our test resource as a Map with configuration properties Map\u0026lt;String, Object\u0026gt; configurationProperties = new HashMap\u0026lt;\u0026gt;(); configurationProperties.put(PROPERTY_NAME_1, PROPERTY_VALUE_1); configurationProperties.put(PROPERTY_NAME_2, PROPERTY_VALUE_2); configurationProperties.put(PROPERTY_NAME_3, PROPERTY_VALUE_3); // Create a new Managed Resource to be used by the Digital Twin and managed by the Management Interface DictionaryManagedResource dictionaryManagedResource = new DictionaryManagedResource( RESOURCE_ID, RESOURCE_TYPE, RESOURCE_NAME, configurationProperties); Once we have a resource we can the following methods provided by the ResourceManager:\nvoid addResource(ManagedResource\u0026lt;?, ?, ?\u0026gt; resource): Adds a resource to the manager and notifies observers. void removeResource(ManagedResource\u0026lt;?, ?, ?\u0026gt; resource): Removes a resource by instance and notifies observers. void removeResource(String resourceId): Removes a resource by its ID and notifies observers. void updateResource(ManagedResource\u0026lt;?, ?, ?\u0026gt; resource): Updates an existing resource and notifies observers. void clearResourceList(): Removes all resources and notifies observers. Optional\u0026lt;ManagedResource\u0026lt;?, ?, ?\u0026gt;\u0026gt; getResourceById(String resourceId): Retrieves a resource by its ID. List\u0026lt;ManagedResource\u0026lt;?, ?, ?\u0026gt;\u0026gt; getResourceList(): Returns a list of all managed resources. boolean containsResource(String resourceId): Checks if a resource with the given ID exists To add a new resource to the we can use the following code:\n// Add a Managed Resource to the Digital Twin digitalTwin.getResourceManager().addResource(dictionaryManagedResource); When the resource has been added to the ResourceManager it can be accessed for example from the ShadowingFunctionto be used within the digitalization processes of the Digital Twin:\n// Check if the ResourceManager is initialized and contains the expected resource if (this.resourceManager != null \u0026amp;\u0026amp; this.resourceManager.containsResource(RESOURCE_ID)) { // Retrieve the resource by ID Optional\u0026lt;ManagedResource\u0026lt;?, ?, ?\u0026gt;\u0026gt; optionalResource = this.resourceManager.getResourceById(RESOURCE_ID); // Check if the resource is present and is an instance of DictionaryManagedResource if (optionalResource.isPresent() \u0026amp;\u0026amp; optionalResource.get() instanceof DictionaryManagedResource) { // Cast the resource to DictionaryManagedResource DictionaryManagedResource dictionaryResource = (DictionaryManagedResource) optionalResource.get(); // Access the value of the \u0026#39;test\u0026#39; property in the resource Object testPropertyValue = dictionaryResource.getResource().get(\u0026#34;test\u0026#34;); // Log the retrieved value System.out.println(\u0026#34;ShadowingFunction - Resource Property \u0026#39;test\u0026#39; Value: \u0026#34; + testPropertyValue); } } else logger.error(\u0026#34;ResourceManager is null or empty. Cannot read the Resource {}.\u0026#34;, ManagementInterfaceTester.RESOURCE_ID); At this stage the resource will be available within the DT instance (e.g., in the Shadowing function) but not to external application since no ManagementInterface has been adde to the DT instance.\n3. Create the Management Interface To expose the configurable resource managed by the Digital Twin (DT), we define a custom implementation of the ManagementInterfaceâ€”called DemoManagementInterface. This implementation is designed for demonstration and explanation purposes, and deliberately avoids dependencies on specific networking libraries. Instead, it emulates the behavior of a network interface, allowing developers to test the logic behind ResourceRequest and ResourceResponse.\nIn a real deployment, it is up to the developer to create a concrete implementation of the ManagementInterface, using the preferred communication protocolâ€”such as HTTP for RESTful APIs, or publish/subscribe mechanisms like MQTT.\nThe demo interface will be as following:\nimport it.wldt.exception.WldtManagedResourceException; import it.wldt.exception.WldtManagementInterfaceException; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.util.List; import java.util.Optional; public class DemoManagementInterface extends ManagementInterface { private static final Logger logger = LoggerFactory.getLogger(DemoManagementInterface.class); // Flag to indicate if the management interface has been started private boolean isStarted = false; // Constants for request types public static final String READ_REQUEST = \u0026#34;READ\u0026#34;; public static final String CREATE_REQUEST = \u0026#34;CREATE\u0026#34;; public static final String UPDATE_REQUEST = \u0026#34;UPDATE\u0026#34;; public static final String DELETE_REQUEST = \u0026#34;DELETE\u0026#34;; @Override protected void onStart(List\u0026lt;ManagedResource\u0026lt;?, ?, ?\u0026gt;\u0026gt; resources) { // Set the started flag to true this.isStarted = true; logger.info(\u0026#34;DemoManagementInterface started with {} resources:\u0026#34;, resources.size()); for (ManagedResource\u0026lt;?, ?, ?\u0026gt; resource : resources) { logger.info(\u0026#34;Managed Resource: {}\u0026#34;, resource.getId()); } } @Override protected void onStop() { logger.info(\u0026#34;DemoManagementInterface stopped.\u0026#34;); } @Override protected void onResourceAdded(ManagedResource\u0026lt;?, ?, ?\u0026gt; resource) { logger.info(\u0026#34;Resource added: {}\u0026#34;, resource.getId()); } @Override protected void onResourceUpdated(ManagedResource\u0026lt;?, ?, ?\u0026gt; resource) { logger.info(\u0026#34;Resource updated: {}\u0026#34;, resource.getId()); } @Override protected void onResourceRemoved(ManagedResource\u0026lt;?, ?, ?\u0026gt; resource) { logger.info(\u0026#34;Resource removed: {}\u0026#34;, resource.getId()); } /** * Validates the ResourceRequest and retrieves the associated ManagedResource * form the ResourceManager. * * @param resourceRequest the resource request * @return an Optional containing the ManagedResource if found, or empty if not found * @throws WldtManagementInterfaceException if the management interface is not started or the request is invalid * @throws WldtManagedResourceException if the resource is not found */ private Optional\u0026lt;DictionaryManagedResource\u0026gt; validateAndLoadRequest(ResourceRequest\u0026lt;?\u0026gt; resourceRequest) throws WldtManagementInterfaceException, WldtManagedResourceException { if (!this.isStarted) { logger.error(\u0026#34;DemoManagementInterface is not started. Cannot access resource.\u0026#34;); throw new WldtManagementInterfaceException(\u0026#34;Management interface not started.\u0026#34;); } if (resourceRequest == null || resourceRequest.getResourceId() == null || resourceRequest.getResourceId().isEmpty()) { logger.error(\u0026#34;Error handling Null Request! Received request: {}\u0026#34;, resourceRequest); throw new WldtManagedResourceException(\u0026#34;Invalid resource request.\u0026#34;); } // Get the resource ID from the ResourceRequest String resourceId = resourceRequest.getResourceId(); logger.info(\u0026#34;Accessing resource with ID: {}\u0026#34;, resourceId); // Retrieve the ManagedResource from the ResourceManager using the resource ID Optional\u0026lt;ManagedResource\u0026lt;?, ?, ?\u0026gt;\u0026gt; resourceOpt = this.resourceManager.getResourceById(resourceId); // Check if the ManagedResource is present if(resourceOpt.isPresent()) { // Retrieve the ManagedResource from the Optional ManagedResource\u0026lt;?, ?, ?\u0026gt; retrievedManagedResource = resourceOpt.get(); // Check the instance of ManagedResource to ensure it is compatible with the request if (!(retrievedManagedResource instanceof DictionaryManagedResource)) throw new WldtManagedResourceException(\u0026#34;Loaded resource has a wrong type: \u0026#34; + retrievedManagedResource.getClass().getName()); // Cast and return the ManagedResource to DictionaryManagedResource return Optional.of((DictionaryManagedResource) retrievedManagedResource); } else // Resource not found, return an empty Optional return Optional.empty(); } /** * Emulates an incoming request to the management interface. * This method validates the request, retrieves the ManagedResource, and performs the requested operation (read, create, update, delete). * It returns an Optional containing the ResourceResponse if successful, or an error response if the request fails or the resource is not found. * @param requestType the type of request (READ, CREATE, UPDATE, DELETE) * @param resourceRequest the resource request containing the resource ID and sub-resource ID * @return an Optional containing the ResourceResponse if successful, or an error response if the request fails or the resource is not found */ public Optional\u0026lt;ResourceResponse\u0026lt;?\u0026gt;\u0026gt; emulateIncomingRequest(String requestType, ResourceRequest\u0026lt;?\u0026gt; resourceRequest) { try{ // Validate the ResourceRequest and retrieve the ManagedResource Optional\u0026lt;DictionaryManagedResource\u0026gt; optionalManagedResource = validateAndLoadRequest(resourceRequest); // Check if the ManagedResource is present if(optionalManagedResource.isPresent()) { // Cast the ManagedResource to DictionaryManagedResource DictionaryManagedResource managedResource = optionalManagedResource.get(); // Prepare the request ResourceRequest\u0026lt;Object\u0026gt; newRequest = new ResourceRequest\u0026lt;\u0026gt;( resourceRequest.getResourceId(), resourceRequest.getSubResourceId(), resourceRequest.getContent(), resourceRequest.getMetadata()); if(requestType.equals(READ_REQUEST)) // Read the resource using the ManagedResource\u0026#39;s read method and return the response return Optional.ofNullable(managedResource.read(newRequest)); else if(requestType.equals(CREATE_REQUEST)) // Create the resource using the ManagedResource\u0026#39;s create method and return the response return Optional.ofNullable(managedResource.create(newRequest)); // Assuming getData() returns the resource data else if(requestType.equals(UPDATE_REQUEST)) // Update the resource using the ManagedResource\u0026#39;s update method and return the response return Optional.ofNullable(managedResource.update(newRequest)); else if(requestType.equals(DELETE_REQUEST)) // Delete the resource using the ManagedResource\u0026#39;s delete method and return the response return Optional.ofNullable(managedResource.delete(newRequest)); else { logger.error(\u0026#34;Unknown request type: {}\u0026#34;, requestType); return Optional.of(new ResourceResponse\u0026lt;\u0026gt;(400, \u0026#34;Unknown request type: \u0026#34; + requestType)); } } else { // Resource not found, return a 404 response return Optional.of(new ResourceResponse\u0026lt;\u0026gt;(404, \u0026#34;Resource not found with ID: \u0026#34; + resourceRequest.getResourceId())); } }catch (Exception e){ e.printStackTrace(); logger.error(\u0026#34;Error reading resource: {}\u0026#34;, e.getMessage()); return Optional.of(new ResourceResponse\u0026lt;\u0026gt;(400, \u0026#34;Error Managing the Resource Request: \u0026#34; + e.getMessage())); } } } At this point, only the read resource method has been implemented. However, we can define and add additional methods to the interface later. In the meantime, we can integrate the interface into the Digital Twin and test its core functionalities.\n3. Setup the Management Interface Now that weâ€™ve defined and implemented our ManagementInterfaceâ€”named DemoManagementInterfaceâ€”we can initialize it, attach it to the Digital Twin, and then start the Twin within the Digital Twin Engine.\nInitialize and attach the DemoManagementInterface:\n// Create a new Management Interface managementInterface = new DemoManagementInterface(); // Add the Management Interface to the Digital Twin digitalTwin.setManagementInterface(managementInterface); Register the Digital Twin with the engine and start it:\n// Add the Twin to the Engine digitalTwinEngine.addDigitalTwin(digitalTwin); // Start the Digital Twin digitalTwinEngine.startDigitalTwin(TEST_DIGITAL_TWIN_ID); 4. Resource Request \u0026amp; Response Now we can test the DemoManagementInterface that we have created to read a target resource (the DictionaryManagedResource instance) managed by the DT creating a ResourceRequest and accessing the ResourceResponse.\nThe ResourceRequest\u0026lt;T\u0026gt; class is a generic container used to encapsulate all the information needed to perform an operation on a managed resource within the Digital Twin framework. It is designed to be flexible and extensible, supporting a wide range of resource types and operations.\nKey Features:\nGeneric Content: The content field can hold any type of object relevant to the resource operation, making the request adaptable to different use cases. Resource Identification: The resourceId and optional subResourceId fields uniquely identify the target resource and, if needed, a sub-resource. Metadata Support: The metadata map allows attaching additional contextual information to the request, such as operation parameters or user data. On the other hand, the ResourceResponse\u0026lt;T\u0026gt; class is a generic container used to encapsulate the result of an operation performed on a managed resource in the Digital Twin framework. It standardizes how responses, including both successful results and errors, are communicated back to callers.\nKey Features:\nGeneric Content: The resource field can hold any type of object representing the result of the operation. Resource Identification: The resourceId and optional subResourceId fields identify the resource and sub-resource related to the response. Metadata Support: The metadata map allows attaching additional contextual information to the response. Error Handling: The isError, errorCode, and errorMessage fields provide a uniform way to report errors. Now we try the interaction with the defined DemoManagementInterface to access a target resource:\n// Create the Resource Request to read the Resource from the Interface ResourceRequest\u0026lt;String\u0026gt; resourceRequest = new ResourceRequest\u0026lt;\u0026gt;(RESOURCE_ID); // Test reading a resource from the Management Interface Optional\u0026lt;ResourceResponse\u0026lt;?\u0026gt;\u0026gt; resourceResponse = managementInterface.emulateReadResource(resourceRequest); // Check if the Resource Response is present if (resourceResponse.isPresent()) { ResourceResponse\u0026lt;?\u0026gt; response = resourceResponse.get(); logger.info(\u0026#34;Resource Response: {}\u0026#34;, response); logger.info(\u0026#34;Resource Content: {}\u0026#34;, response.getResource()); } else { logger.error(\u0026#34;Resource Response is not present\u0026#34;); } To access the value of an individual sub-resource within a DictionaryManagedResource, you can use the same ResourceRequest type, including an additional parameter that specifies the sub-resource\u0026rsquo;s ID.\n// Create the Resource Request to read the Resource from the Interface ResourceRequest\u0026lt;String\u0026gt; resourceRequest = new ResourceRequest\u0026lt;\u0026gt;(RESOURCE_ID, PROPERTY_NAME_1); // Test reading a resource from the Management Interface Optional\u0026lt;ResourceResponse\u0026lt;?\u0026gt;\u0026gt; resourceResponse = managementInterface.emulateReadResource(resourceRequest); // Check if the Resource Response is present if (resourceResponse.isPresent()) { ResourceResponse\u0026lt;?\u0026gt; response = resourceResponse.get(); logger.info(\u0026#34;Resource Response: {}\u0026#34;, response); logger.info(\u0026#34;Sub-Resource Content: {}\u0026#34;, response.getResource()); } else { logger.error(\u0026#34;Resource Response is not present\u0026#34;); } Considering the target demo resource DictionaryManagedResource we can also add the DemoManagementInterface to create a new resource. In this case since it is a resource mapping a Dictionary the creation will be associated to the creation of a new sub-resource to the dictionary.\nIn this configuration the associated code to emulate the create operation on the DemoManagementInterface is:\n// Create the Resource Request to create a Resource from the Interface // Since the main resource is a Map and we want to create a new property we have to set the sub-resource ID as // the new property name that we want to add or update ResourceRequest\u0026lt;String\u0026gt; resourceRequest = new ResourceRequest\u0026lt;\u0026gt;(RESOURCE_ID, PROPERTY_NAME_4); // Now we set the content of the request to the new value we want to set for the new property resourceRequest.setContent(PROPERTY_VALUE_4); // Test reading a resource from the Management Interface Optional\u0026lt;ResourceResponse\u0026lt;?\u0026gt;\u0026gt; resourceResponseOptional = managementInterface.emulateIncomingRequest(DemoManagementInterface.CREATE_REQUEST, resourceRequest); // Check if the Resource Response is present if (resourceResponseOptional.isPresent()) { ResourceResponse\u0026lt;?\u0026gt; response = resourceResponseOptional.get(); logger.info(\u0026#34;Resource Response: {}\u0026#34;, response); logger.info(\u0026#34;Resource Content: {}\u0026#34;, response.getResource()); } else { logger.error(\u0026#34;Resource Response is not present\u0026#34;); } The same approach can be applied to Update and Delete operations through the DemoManagementInterface. However, it\u0026rsquo;s important to note that these actions only affect the dictionary values (i.e., the sub-resources), not the main resource (the dictionary) itself. This behavior reflects a design choice where the main resource is considered non-deletable via the management interface, representing a resource managed directly by the Digital Twin. Developers can implement alternative behaviors based on their specific requirements.\n4. Resource Manager Observation The ResourceManager supports an observation mechanism that allows external components to be notified about changes in the managed resources. This is achieved through the IResourceManagerObserver interface and the observer management methods in the ResourceManager class.\nThe IResourceManagerObserver interface defines the contract for observers that wish to receive notifications about resource events in the ResourceManager. Implementers of this interface can react to resource additions, removals, updates, and when the resource list is cleared through the following methods:\nonManagerResourceAdded(String resourceId): This method is called when a new resource is added to the management interface. onManagerResourceRemoved(String resourceId): This method is called when a resource is removed from the management interface. onManagerResourceUpdated(String resourceId): This method is called when a resource is updated on the resource manager onManagerResourceListCleared(): This method is called when the resource list is cleared. By implementing this interface, external modules can subscribe to resource lifecycle events and synchronize their state or trigger custom logic accordingly. The ResourceManager class provides methods to manage observers:\naddObserver(IResourceManagerObserver observer): Registers an observer to receive notifications about resource changes. Observers are stored in an internal list and will be notified on relevant events. removeObserver(IResourceManagerObserver observer): Unregisters an observer, stopping further notifications to it. Usage Example:\n// Add an Observer to the Resource Manager digitalTwin.getResourceManager().addObserver(new IResourceManagerObserver() { @Override public void onManagerResourceAdded(String resourceId) { System.out.println(\u0026#34;Resource added: \u0026#34; + resourceId); } @Override public void onManagerResourceRemoved(String resourceId) { System.out.println(\u0026#34;Resource removed: \u0026#34; + resourceId); } @Override public void onManagerResourceUpdated(String resourceId) { System.out.println(\u0026#34;Resource updated: \u0026#34; + resourceId); } @Override public void onManagerResourceListCleared() { System.out.println(\u0026#34;Resource list cleared ...\u0026#34;); } }); Note: This observation mechanism is internal to the Digital Twin and operates at the ResourceManager level, not on individual resource changes. Observations and callbacks for actions originating from the ManagementInterface directly on single ManagedResource are handled separately, as described in the next section.\n5. Single Managed Resource Observation To monitor changes or actions on a specific ManagedResource, you can implement the IResourceObserver interface and use the addObserver() and removeObserver() methods available in the ManagedResource class. This enables you to receive notifications for create, read, update, and delete operations performed on that resource.\nMethod provided by the interface IResourceObserver are:\nvoid onCreate(String resourceId, String subResourceId): Called when a resource or subresource is created. resourceId: The unique identifier of the main resource. subResourceId: The unique identifier of the subresource created under the main resource. Can be null or empty if the event refers to the main resource itself. void onUpdate(String resourceId, String subResourceId): Called when a resource or subresource is updated. resourceId: The unique identifier of the main resource. subResourceId: The unique identifier of the subresource updated. Can be null or empty if the event refers to the main resource itself. void onDelete(String resourceId, String subResourceId): Called when a resource or subresource is deleted. resourceId: The unique identifier of the main resource. subResourceId: The unique identifier of the subresource deleted. Can be null or empty if the event refers to the main resource itself. Note: The resourceId always refers to the main or parent resource while the subResourceId refers to a nested subresource inside the main resource. If the operation targets the main resource directly, subResourceId may be null or an empty string.\nThe example below demonstrates how to register an observer for a target resource and handle callbacks triggered by changes initiated through the ManagementInterface. This mechanism allows Digital Twin developers to react to resource updates and synchronize behavior accordingly.\n// Read the resource from the Resource Manager Optional\u0026lt;ManagedResource\u0026lt;?, ?, ?\u0026gt;\u0026gt; resourceOptional = digitalTwin.getResourceManager().getResourceById(RESOURCE_ID); // Check with instance of if the Resource is of type DictionaryManagedResource if (resourceOptional.isPresent() \u0026amp;\u0026amp; resourceOptional.get() instanceof DictionaryManagedResource) { // Cast the Resource to DictionaryManagedResource DictionaryManagedResource dictionaryManagedResource = (DictionaryManagedResource) resourceOptional.get(); // Add a callback to the Managed Resource dictionaryManagedResource.addObserver(new IResourceObserver() { @Override public void onCreate(String resourceId, String subResourceId) { System.out.println(\u0026#34;Create Callback on Resource: \u0026#34; + resourceId + \u0026#34;, SubResource: \u0026#34; + subResourceId); } @Override public void onUpdate(String resourceId, String subResourceId) { System.out.println(\u0026#34;Update Callback on Resource: \u0026#34; + resourceId + \u0026#34;, SubResource: \u0026#34; + subResourceId); } @Override public void onDelete(String resourceId, String subResourceId) { System.out.println(\u0026#34;Delete Callback on Resource: \u0026#34; + resourceId + \u0026#34;, SubResource: \u0026#34; + subResourceId); } }); } else logger.error(\u0026#34;Resource is not of type DictionaryManagedResource\u0026#34;); ","date":"January 8, 2026","id":23,"permalink":"/docs/guides/management-interface/","summary":"The version 0.5.0 of the Digital Twin library introduced the concept of Digital Twin Resources and a Management Interface for runtime configuration and management.","tags":"","title":"Management Interface"},{"content":"In order to keep the core of the library independent from external dependencies, WLDT introduces a flexible and configurable logging layer. This design allows developers to extend and integrate the logging system according to the specific requirements of their projects,\nwithout being tied to any particular logging framework. The logging API interfaces and methods are inspired by popular libraries such as Log4j\nand Logback, making it easier for developers to integrate WLDT logging with their preferred solutions.\nFurthermore, the library provides a default implementation that uses classic Java System.out.* output, ensuring basic logging\nfunctionality is available out-of-the-box for immediate usability. This approach enables both quick adoption and\nadvanced customization as needed.\nðŸ“ Logging in WLDT The WLDT logging layer provides a flexible and extensible way to handle logging within your digital twin applications.\nIt\u0026rsquo;s designed to allow developers to easily switch between different logging implementations without modifying core application code.\nThe core components of the WLDT logging layer are:\nWldtLogger: An interface defining the standard logging methods (e.g., info, debug, error). WldtLoggerFactory: An interface for creating WldtLogger instances. WldtLoggerProvider: A utility class that provides a static method to get WldtLogger instances and allows setting a custom WldtLoggerFactory. WldtDefaultLogger: A default implementation of WldtLogger that prints log messages to the console. WldtDefaultLoggerFactory: A default implementation of WldtLoggerFactory that creates WldtDefaultLogger instances. WldtLogger Interface The WldtLogger interface defines a set of methods for logging messages at different levels of severity.\nMethods:\ngetName(): Returns the name of the logger, typically the fully qualified class name. trace(String msg), trace(String format, Object arg), trace(String format, Object arg1, Object arg2), trace(String format, Object... arguments), trace(String msg, Throwable t): Methods for logging trace level messages. These are typically fine-grained informational events that are most useful for debugging an application. isTraceEnabled(): Checks if the trace level is enabled. debug(String msg), debug(String format, Object arg), debug(String format, Object arg1, Object arg2), debug(String format, Object... arguments), debug(String msg, Throwable t): Methods for logging debug level messages. These are typically used for debugging purposes during development. isDebugEnabled(): Checks if the debug level is enabled. info(String msg), info(String format, Object arg), info(String format, Object arg1, Object arg2), info(String format, Object... arguments), info(String msg, Throwable t): Methods for logging info level messages. These provide general information about the application\u0026rsquo;s progress. isInfoEnabled(): Checks if the info level is enabled. warn(String msg), warn(String format, Object arg), warn(String format, Object arg1, Object arg2), warn(String format, Object... arguments), warn(String msg, Throwable t): Methods for logging warn level messages. These indicate potential issues or unexpected events that do not prevent the application from continuing. isWarnEnabled(): Checks if the warn level is enabled. error(String msg), error(String format, Object arg), error(String format, Object arg1, Object arg2), error(String format, Object... arguments), error(String msg, Throwable t): Methods for logging error level messages. These indicate serious problems that prevent the application from functioning correctly. isErrorEnabled(): Checks if the error level is enabled. WldtLoggerFactory Interface The WldtLoggerFactory interface is responsible for creating instances of WldtLogger.\nMethod:\ngetLogger(Class\u0026lt;?\u0026gt; clazz): This method takes a Class\u0026lt;?\u0026gt; object as input and returns a WldtLogger instance associated with that class. This allows logs to be categorized by their source class. WldtLoggerProvider Class The WldtLoggerProvider acts as the entry point for obtaining logger instances.\nKey Features:\nDefault Factory: By default, it uses WldtDefaultLoggerFactory to create WldtDefaultLogger instances. Custom Factory Support: It allows you to set a custom WldtLoggerFactory to integrate with different logging frameworks or implement custom logging behavior. Methods:\npublic static void setFactory(WldtLoggerFactory customFactory): Use this method to replace the default logger factory with your own custom implementation. This should typically be called once at the application\u0026rsquo;s startup. public static WldtLogger getLogger(Class\u0026lt;?\u0026gt; clazz): This static method is used to obtain a logger instance for a specific class. It delegates the logger creation to the currently set WldtLoggerFactory. WldtDefaultLogger Class The WldtDefaultLogger is a basic, console-based implementation of the WldtLogger interface.\nFeatures:\nConsole Output: Logs messages to the standard output (System.out). Timestamping: Each log message is prefixed with a timestamp in the format \u0026ldquo;yyyy-MM-dd HH:mm:ss.SSS\u0026rdquo;. Log Level Indication: Includes the log level (TRACE, DEBUG, INFO, WARN, ERROR) in each message. Class Name: Shows the simple name of the class that requested the logger. WldtDefaultLoggerFactory Class The WldtDefaultLoggerFactory is the default factory implementation that creates WldtDefaultLogger instances.\nMethod:\npublic WldtLogger getLogger(Class\u0026lt;?\u0026gt; clazz): This method simply returns a new WldtDefaultLogger instance, initialized with the provided class. âš™ï¸ How to Create a Custom Logger and Custom Logger Factory The WLDT logging layer is designed to be extensible, allowing developers to integrate their preferred logging frameworks (e.g., Log4j, SLF4j, Logback) or implement entirely custom logging logic.\n1. Create a Custom Logger To create a custom logger, you need to implement the WldtLogger interface. This allows you to define how log messages are handled (e.g., written to a file, sent to a remote server, or integrated with an existing logging framework).\nHere\u0026rsquo;s an example of a MyCustomLogger that could integrate with a third-party logging framework:\npackage it.wldt.log; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class MyCustomLogger implements WldtLogger { private final Logger slf4jLogger; public MyCustomLogger(Class\u0026lt;?\u0026gt; clazz) { this.slf4jLogger = LoggerFactory.getLogger(clazz); } @Override public String getName() { return slf4jLogger.getName(); } @Override public void trace(String msg) { slf4jLogger.trace(msg); } @Override public void trace(String format, Object arg) { slf4jLogger.trace(format, arg); } @Override public void trace(String format, Object arg1, Object arg2) { slf4jLogger.trace(format, arg1, arg2); } @Override public void trace(String format, Object... arguments) { slf4jLogger.trace(format, arguments); } @Override public void trace(String msg, Throwable t) { slf4jLogger.trace(msg, t); } @Override public boolean isTraceEnabled() { return slf4jLogger.isTraceEnabled(); } @Override public void debug(String msg) { slf4jLogger.debug(msg); } @Override public void debug(String format, Object arg) { slf4jLogger.debug(format, arg); } @Override public void debug(String format, Object arg1, Object arg2) { slf4jLogger.debug(format, arg1, arg2); } @Override public void debug(String format, Object... arguments) { slf4jLogger.debug(format, arguments); } @Override public void debug(String msg, Throwable t) { slf4jLogger.debug(msg, t); } @Override public boolean isDebugEnabled() { return slf4jLogger.isDebugEnabled(); } @Override public void info(String msg) { slf4jLogger.info(msg); } @Override public void info(String format, Object arg) { slf4jLogger.info(format, arg); } @Override public void info(String format, Object arg1, Object arg2) { slf4jLogger.info(format, arg1, arg2); } @Override public void info(String format, Object... arguments) { slf4jLogger.info(format, arguments); } @Override public void info(String msg, Throwable t) { slf4jLogger.info(msg, t); } @Override public boolean isInfoEnabled() { return slf4jLogger.isInfoEnabled(); } @Override public void warn(String msg) { slf4jLogger.warn(msg); } @Override public void warn(String format, Object arg) { slf4jLogger.warn(format, arg); } @Override public void warn(String format, Object arg1, Object arg2) { slf4jLogger.warn(format, arg1, arg2); } @Override public void warn(String format, Object... arguments) { slf4jLogger.warn(format, arguments); } @Override public void warn(String msg, Throwable t) { slf4jLogger.warn(msg, t); } @Override public boolean isWarnEnabled() { return slf4jLogger.isWarnEnabled(); } @Override public void error(String msg) { slf4jLogger.error(msg); } @Override public void error(String format, Object arg) { slf4jLogger.error(format, arg); } @Override public void error(String format, Object arg1, Object arg2) { slf4jLogger.error(format, arg1, arg2); } @Override public void error(String format, Object... arguments) { slf4jLogger.error(format, arguments); } @Override public void error(String msg, Throwable t) { slf4jLogger.error(msg, t); } @Override public boolean isErrorEnabled() { return slf4jLogger.isErrorEnabled(); }} 2. Create a Custom Logger Factory Once you have your custom logger, you need a custom logger factory to provide instances of it.\nThis factory will implement the WldtLoggerFactory interface.\nHere\u0026rsquo;s an example of a MyCustomLoggerFactory that produces MyCustomLogger instances:\npackage it.wldt.log; public class MyCustomLoggerFactory implements WldtLoggerFactory { @Override public WldtLogger getLogger(Class\u0026lt;?\u0026gt; clazz) { return new MyCustomLogger(clazz); }} 3. Set the Custom Logger Factory Finally, to use your custom logger and factory, you need to instruct the WldtLoggerProvider to use your MyCustomLoggerFactory.\nThis should be done once at the beginning of your application\u0026rsquo;s lifecycle, before any loggers are requested.\nimport it.wldt.log.WldtLoggerProvider; import it.wldt.log.MyCustomLoggerFactory; // Your custom factory import it.wldt.log.WldtLogger; public class MyApplication { public static void main(String[] args) { // Set the custom logger factory WldtLoggerProvider.setFactory(new MyCustomLoggerFactory()); // Now, any logger obtained will be an instance of MyCustomLogger WldtLogger logger = WldtLoggerProvider.getLogger(MyApplication.class); logger.info(\u0026#34;This message will be logged using MyCustomLogger!\u0026#34;); logger.error(\u0026#34;An error occurred!\u0026#34;, new RuntimeException(\u0026#34;Something went wrong\u0026#34;)); }} By following these steps, you can seamlessly integrate custom logging solutions into your WLDT digital twin applications,\nensuring that your logging infrastructure meets your specific project requirements.\n","date":"January 8, 2026","id":24,"permalink":"/docs/guides/logging/","summary":"In order to keep the core of the library independent from external dependencies, WLDT introduces a flexible and configurable logging layer.","tags":"","title":"Logging"},{"content":"New Features WldtEventObserver A new class called WldtEventObserver has been introduced to allow a simplified observation of target specific events generated by the Digital Twin and its components such as adapters and the model. Main mapped events and filters are:\nState Events: State Update and State Event Notifications Physical Asset Events: Physical Property Variation, Physical Event Notification, Physical Relationship Instance Creation and Deletion Physical Asset Action Events: Physical Action Trigger Digital Action Events: Digital Action Event Physical Asset Description Events: Physical Asset Description Available and Updated Life Cycle Events: Digital Twin Life Cycle Events Query Request Events: Storage Query Request Events (See next sections for additional information) For each event type dedicated observation and un-observation methods (e.g., observePhysicalAssetEvents() and unObservePhysicalAssetEvents()) are available in order to create an instance of the observer and decide which events to receive.\nTo build a WldtEventObserver a dedicated listener IWldtEventObserverListener should be implemented by the developer to receive the callbacks related to the incoming events. All the events are of the generic type WldtEvent and it is up to the developer the validate and check the received object and if it match with the expected one.\nAn example of usage for the event observer is the following:\nWldtEventObserver eventObserver = new WldtEventObserver( \u0026#34;DT_TEST_ID_1\u0026#34;, \u0026#34;test-observer\u0026#34;, myObserverListener); // Start all the available observation eventObserver.observePhysicalAssetEvents(); eventObserver.observePhysicalAssetActionEvents(); eventObserver.observeStateEvents(); eventObserver.observeDigitalActionEvents(); eventObserver.observePhysicalAssetDescriptionEvents(); eventObserver.observeLifeCycleEvents(); The WldtEventObserver has been currently used internally within the library to simplify the implementation and usage of the Storage Layer and the associated Storage Query System as described in the dedicated sections.\nStorage Layer A new storage layer has been integrated into the core WLDT library, enabling Digital Twins (DTs) to store data related to the evolution of their state, generated events, and any variations involving properties, events, actions, relationships, and life cycle. The Storage Layer consists of two main components:\nStorage Manager: This is the central component of the storage system, facilitating the structured and modular storage and retrieval of information. It allows developers to create and utilize various storage systems (e.g., in-memory, file-based, or DBMS) simultaneously. The Storage Layer is accessible in both read and write modes internally by the DT\u0026rsquo;s Model, and in read-only mode via the Query System by Digital Adapters. Query System: To delegate and encapsulate the responsibility of data storage within the DT\u0026rsquo;s model, a query system has been integrated. This system enables Digital Adapters to retrieve stored data and expose it according to their specific logic and implementation. The storage layer is designed for easy extension, allowing developers to create and share new storage layers (e.g., using Redis, MySQL, or MongoDB). The provided in-memory implementation serves only for basic development and testing purposes. Similarly, the Query Manager can be extended and customized by developers to implement additional query management features or to enhance the default functionalities provided by the library.\nStorage Manager The main module of the Storage Layer is the one associated to Storage Capabilities and it is composed by two main classes: StorageManager and WldStorage with the following characteristics and main methods:\nStorageManager: The StorageManager class is a class that represents the storage manager for a DigitalTwin. It is responsible for managing the storage of the data related to the DigitalTwin. It is an observer of the WldtEventBus, and it is able to save the data in the available storages. The class extends a DigitalTwinWorker, in order to allow the component to work in a structure and integrated way on a different thread that the core of a DT can coordinate starting and stopping it when required. The manager allow the usage of different storage systems at the same time in order to allow the developers to memorize the information accordingly to their need in the right storage system at the same time (e.g., REDIS for quick cached information and MongDB for historical data). Main associated methods are: putStorage(WldtStorage storage): Add a new WldtStorage to the StorageManager getStorageIdList(): Returns the list of id of the WldtStorage in the StorageManager isStorageAvailable(String storageId): Checks if a target Storage Id is available in the Storage Manager getStorage(String storageId): Get the target WldtStorage by id from the Storage Manager removeStorage(String storageId): Remove an existing WldtStorage by id from the StorageManager WldtStorage: Defines an abstract class allowing the Digital Twin developer to implement its internal storage system for the Digital Twin instance. The class defines methods for the management of: Digital Twin State storage and retrieval with the associated change list; Generated State Digital Events; Life Cycle State storage and retrieval; Physical Asset Description storage and retrieval; Physical Asset Property Variation storage and retrieval; Physical Asset Relationship Instance storage and retrieval; Digital Action Request storage and retrieval; Physical Asset Action Request storage and retrieval; Physical Asset Event Notification storage and retrieval; Each WldtStorage instance can be configured (using the right constructor method) to: Observe all Wldt events (stateEvents, physicalAssetEvents, physicalAssetActionEvents, physicalAssetDescriptionEvents, digitalActionEvents, lifeCycleEvents) Filter only for specific class of events Once the WldtStorage has been properly configured to receive target events the StorageManager automatically save information of interest for that specific storage. For example we can have a StorageA (e.g, REDIS) configured to receive all the generated events and a StorageB (e.g., MongoDB) in charge of saving only DT\u0026rsquo;s state variation over time. The default implementation of the WldtStorage is the class DefaultWldtStorage. This class provides a simple storage solution for digital twin states, digital twin state changes, physical asset events, and digital twin events. The class provides ONLY a memory based approach for storage using ArrayLists and HashMaps and more advanced solution should be implemented for production oriented Digital Twins for examples using external storage and memorization solutions. Methods available and implemented by WldtStorage implementations are the following grouped by categories: Digital Twin State: saveDigitalTwinState(DigitalTwinState digitalTwinState, List\u0026lt;DigitalTwinStateChange\u0026gt; digitalTwinStateChangeList): Save a new computed instance of the DT State in the Storage together with the list of the changes with respect to the previous state getLastDigitalTwinState(): Returns the latest computed Digital Twin State of the target Digital Twin instance getDigitalTwinStateCount(): Returns the number of computed and stored Digital Twin States getDigitalTwinStateInTimeRange(long startTimestampMs, long endTimestampMs): Retrieves a list of DigitalTwinState objects within the specified time range getDigitalTwinStateInRange(int startIndex, int endIndex): Retrieves a list of Digital Twin states within the specified range of indices Digital Twin State Event Notification: saveDigitalTwinStateEventNotification(DigitalTwinStateEventNotification\u0026lt;?\u0026gt; digitalTwinStateEventNotification): Save the Digital Twin State Event Notification getDigitalTwinStateEventNotificationCount(): Get the number of Digital Twin State Event Notification getDigitalTwinStateEventNotificationInTimeRange(long startTimestampMs, long endTimestampMs): Get the Digital Twin State Event Notification in the specified time range getDigitalTwinStateEventNotificationInRange(int startIndex, int endIndex): Get the Digital Twin State Event Notification in the specified range of indices Life Cycle State Variation: saveLifeCycleState(LifeCycleStateVariation lifeCycleStateVariation): Save the LifeCycleState of the Digital Twin getLastLifeCycleState(): Get the last LifeCycleState of the Digital Twin getLifeCycleStateCount(): Get the number of LifeCycleState of the Digital Twin getLifeCycleStateInTimeRange(long startTimestampMs, long endTimestampMs): Get the last LifeCycleState of the Digital Twin getLifeCycleStateInRange(int startIndex, int endIndex): Get the LifeCycleState of the Digital Twin in the specified range of indices Physical Asset Event Notification: savePhysicalAssetEventNotification(PhysicalAssetEventNotification physicalAssetEventNotification): Save the Physical Asset Event Notification getPhysicalAssetEventNotificationCount(): Get the number of Physical Asset Event Notification getPhysicalAssetEventNotificationInTimeRange(long startTimestampMs, long endTimestampMs): Get the Physical Asset Event Notification in the specified time range getPhysicalAssetEventNotificationInRange(int startIndex, int endIndex): Get the Physical Asset Event Notification in the specified range of indices Physical Action Request: savePhysicalAssetActionRequest(PhysicalAssetActionRequest physicalAssetActionRequest): Save Physical Asset Action Request getPhysicalAssetActionRequestCount(): Get the number of Physical Asset Action Request getPhysicalAssetActionRequestInTimeRange(long startTimestampMs, long endTimestampMs): Get the Physical Asset Action Request in the specified time range getPhysicalAssetActionRequestInRange(int startIndex, int endIndex): Get the Physical Asset Action Request in the specified range of indices Digital Action Request: saveDigitalActionRequest(DigitalActionRequest digitalActionRequest): Save a Digital Action Request getDigitalActionRequestCount(): Get the number of Digital Action Request Stored getDigitalActionRequestInTimeRange(long startTimestampMs, long endTimestampMs): Get the Digital Action Request in the specified time range getDigitalActionRequestInRange(int startIndex, int endIndex): Get the Digital Action Request in the specified range of indices Physical Asset Description (PAD) Notification New PAD Notification saveNewPhysicalAssetDescriptionNotification(PhysicalAssetDescriptionNotification physicalAssetDescriptionNotification): Save a new Physical Asset Description Available getNewPhysicalAssetDescriptionNotificationCount(): Get the number of New Physical Asset Description Notifications available getNewPhysicalAssetDescriptionNotificationInTimeRange(long startTimestampMs, long endTimestampMs): Get the New Physical Asset Description Available in the specified time range getNewPhysicalAssetDescriptionNotificationInRange(int startIndex, int endIndex): Get the New Physical Asset Description Available in the specified range of indices Updated PAD Notification saveUpdatedPhysicalAssetDescriptionNotification(PhysicalAssetDescriptionNotification physicalAssetDescriptionNotification): Save the updated Physical Asset Description Notification getUpdatedPhysicalAssetDescriptionNotificationCount(): Get the number of Updated Physical Asset Description getUpdatedPhysicalAssetDescriptionNotificationInTimeRange(long startTimestampMs, long endTimestampMs): Get the Updated Physical Asset Description in the specified time range getUpdatedPhysicalAssetDescriptionNotificationInRange(int startIndex, int endIndex): Get the Updated Physical Asset Description in the specified range of indices Physical Asset Property Variation: savePhysicalAssetPropertyVariation(PhysicalAssetPropertyVariation physicalAssetPropertyVariation): Save the Physical Asset Property Variation getPhysicalAssetPropertyVariationCount(): Get the number of Physical Asset Property Variation getPhysicalAssetPropertyVariationInTimeRange(long startTimestampMs, long endTimestampMs): Get the Physical Asset Property Variation in the specified time range getPhysicalAssetPropertyVariationInRange(int startIndex, int endIndex): Get the Physical Asset Property Variation in the specified range of indices Physical Asset Relationship Instance Notification Created Relationship Instance savePhysicalAssetRelationshipInstanceCreatedNotification(PhysicalRelationshipInstanceVariation physicalRelationshipInstanceVariation): Save the Physical Asset Relationship Instance Created Event getPhysicalAssetRelationshipInstanceCreatedNotificationCount(): Get the number of Physical Asset Relationship Instance Created Event getPhysicalAssetRelationshipInstanceCreatedNotificationInTimeRange(long startTimestampMs, long endTimestampMs): Get the Physical Asset Relationship Instance Created Event in the specified time range getPhysicalAssetRelationshipInstanceCreatedNotificationInRange(int startIndex, int endIndex): Get the Physical Asset Relationship Instance Created Event in the specified range of indices Deleted Relationship Instance savePhysicalAssetRelationshipInstanceDeletedNotification(PhysicalRelationshipInstanceVariation physicalRelationshipInstanceVariation): Save the Physical Asset Relationship Instance Updated Event getPhysicalAssetRelationshipInstanceDeletedNotificationCount(): Get the number of Physical Asset Relationship Instance Updated Event getPhysicalAssetRelationshipInstanceDeletedNotificationInTimeRange(long startTimestampMs, long endTimestampMs): Get the Physical Asset Relationship Instance Updated Event in the specified time range getPhysicalAssetRelationshipInstanceDeletedNotificationInRange(int startIndex, int endIndex): Get the Physical Asset Relationship Instance Updated Event in the specified range of indices Some examples of usage for the Storage Layer are the following:\nLets\u0026rsquo; create a new Digital Twin with a single Storage in charge of automatically observe and store all the event generated and going through the target DT instance\n// Create the Digital Twin Engine DigitalTwinEngine digitalTwinEngine = new DigitalTwinEngine(); // Create a new Digital Twin with a Demo Shadowing Function DigitalTwin digitalTwin = new DigitalTwin(TEST_DIGITAL_TWIN_ID, new DemoShadowingFunction()); // Physical Adapter Configuration DemoPhysicalAdapter physicalAdapter = new DemoPhysicalAdapter(...); digitalTwin.addPhysicalAdapter(physicalAdapter); // Digital Adapter Configuration digitalAdapter = new DemoDigitalAdapter(...); digitalTwin.addDigitalAdapter(digitalAdapter); // Create a new WldtStorage instance using the default implementation and observing all the events DefaultWldtStorage myStorage = new DefaultWldtStorage(\u0026#34;test_storage\u0026#34;, true) // Add the new Default Storage Instance to the Digital Twin Storage Manager digitalTwin.getStorageManager().putStorage(myStorage); // Add the Twin to the Engine digitalTwinEngine.addDigitalTwin(digitalTwin); // Start the Digital Twin digitalTwinEngine.startDigitalTwin(TEST_DIGITAL_TWIN_ID); Now let\u0026rsquo;s suppose to have two additional implementation of the WldtStorage class supporting Redis and MongDB and called RedisWldtStorage and MongoDbWldtStorage. We would like to use Redis to automatically observe all the events and MongoDb only to store DT\u0026rsquo;s state and life cycle variations.\n[...] // Create a new RedisWldtStorage instance using the default implementation and observing all the events RedisWldtStorage myRedisStorage = new RedisWldtStorage(\u0026#34;redis_storage\u0026#34;, true); myRedisStorage.setRedisConfiguration(myRedisConfiguration); // Add the new Redis Storage Instance to the Digital Twin Storage Manager digitalTwin.getStorageManager().putStorage(myRedisStorage); // Create a new MongoDbWldtStorage instance using the default implementation and observing only State and LifeCycle Events MongoDbWldtStorage myMongoDbStorage = new MongoDbWldtStorage(\u0026#34;mongo_db_storage\u0026#34;, true, false, false, false, false, true); myMongoDbStorage.setMongoDbConfiguration(myMongoDbConfiguration); // Add the new MongoDb Storage Instance to the Digital Twin Storage Manager digitalTwin.getStorageManager().putStorage(myRedisStorage); [...] Within the ShadowingFunction it is possible to have the reference to the StorageManager in order to access available Storage in both reading and writing mode. This is an example of how to retrieve an available WldtStorage through its id and the use it to read Properties values in a time range of the last 5 minutes:\nString TARGET_STORAGE_ID = \u0026#34;test_storage\u0026#34;; if(this.storageManager.isStorageAvailable(TARGET_STORAGE_ID)){ // Access the Storage Manager to store the last value of the property WldtStorage targetStorage = this.storageManager.getStorage(TARGET_STORAGE_ID); // Get the current time in milliseconds long endTime = System.currentTimeMillis(); // Get the Time in the last 5 minutes long startTime = endTime - (5 * 60 * 1000); // Get the last Physical Asset Action Request in the last 5 minutes List\u0026lt;PhysicalAssetPropertyVariationRecord\u0026gt; propertyVariationRecords = targetStorage.getPhysicalAssetPropertyVariationInTimeRange(startTime, endTime); for(PhysicalAssetPropertyVariationRecord propertyVariationRecord : propertyVariationRecords){ logger.info(\u0026#34;Property Variation Record: {}\u0026#34;, propertyVariationRecord); [...] } } Note: The StorageManager, as previously described, can automatically store DT-related events based on the configuration and setup of each WldtStorage instance added to the manager. However, since the ShadowingFunction has direct access to the StorageManager in both read and write modes, manual handling of data storage is also possible. To achieve this, you can disable automatic storage by setting it to false for specific event types or for all event types. This allows you to manually manage the storage of information within the ShadowingFunction.\nQuery System Given the library\u0026rsquo;s goal of maximizing modularity and decoupling responsibilities among the available components, the Query System has been introduced. This system allows components external to the core responsibilities of the Digital Twin (e.g., Digital Adapters and Augmentation Functions) to retrieve stored data and use or expose it according to their specific logic and implementation. For instance, an HTTP Digital Adapter could expose stored information about a DT\u0026rsquo;s state variations over time, or a Monitoring Adapter could use available storage instances to retrieve events for a deeper understanding of the target DT instance\u0026rsquo;s behavior. The query system has been implemented entirely through dedicated events in order to maximize the decoupling of the solution and and supports at the same time both synchronous and asynchronous queries.\nThe main classes associated to the Query System are the following:\nQueryManager: This class represents the Query Manager responsible to handle the query request and manage the query execution and has been designed to be extended by the user to implement the desired query management logic (e.g., as with the DefaultQueryManager). QueryRequest: The class contains all the information needed to perform a query on the storage system QueryRequestType: This Enum represents the Query Request Type used to specify the type of query to be performed on the storage system supporting: TIME_RANGE SAMPLE_RANGE LAST_VALUE COUNT QueryResourceType: This Enum represents the Query Resource Type used to specify the type of resource to be queried on the storage system supporting the following resource types mapping those available and managed by the storage manager: PHYSICAL_ASSET_PROPERTY_VARIATION PHYSICAL_ASSET_EVENT_NOTIFICATION PHYSICAL_ACTION_REQUEST DIGITAL_ACTION_REQUEST DIGITAL_TWIN_STATE NEW_PAD_NOTIFICATION UPDATED_PAD_NOTIFICATION PHYSICAL_RELATIONSHIP_INSTANCE_CREATED_NOTIFICATION PHYSICAL_RELATIONSHIP_INSTANCE_DELETED_NOTIFICATION LIFE_CYCLE_EVENT QueryExecutor: This class represents the Query Executor used to execute queries on the storage system supporting both synchronous and asynchronous query execution. Internally is implemented through an event-based mechanism to handle the query request and response QueryResult: This class represents the Query Result returned by the Query Executor containing the query results and the query status (successful or not) and error message (if any) together with also the original request IQueryResultListener: This interface represents the Query Result Listener used to receive the query results An example of Synchronous query is:\nQueryExecutor queryExecutor = new QueryExecutor(TEST_DIGITAL_TWIN_ID, \u0026#34;query-executor\u0026#34;); // Create Query Request to the Storage Manager for the Last Digital Twin State QueryRequest queryRequest = new QueryRequest(); queryRequest.setResourceType(QueryResourceType.DIGITAL_TWIN_STATE); queryRequest.setRequestType(QueryRequestType.LAST_VALUE); // Send the Query Request to the Storage Manager for the target DT QueryResult\u0026lt;?\u0026gt; queryResult = queryExecutor.syncQueryExecute(queryRequest); Following the same approach an Asynchrounouse query can be executed as follows:\nQueryExecutor queryExecutor = new QueryExecutor(TEST_DIGITAL_TWIN_ID, \u0026#34;query-executor\u0026#34;); // Create Query Request to the Storage Manager for the Last Digital Twin State QueryRequest queryRequest = new QueryRequest(); queryRequest.setResourceType(QueryResourceType.DIGITAL_TWIN_STATE); queryRequest.setRequestType(QueryRequestType.LAST_VALUE); // Send the Query Request to the Storage Manager for the target DT queryExecutor.asyncQueryExecute(queryRequest, new IQueryResultListener() { @Override public void onQueryResult(QueryResult\u0026lt;?\u0026gt; queryResult) { [...] } }); The class DigitalAdapter has been updated adding also an internal reference to a QueryExecutor in order to simplify the interaction with the query system directly from an adapter like in the following example where we use the query Executor of the Digital Adapter invokeAction callback through its internal variable accessible through this.queryExecutor without creating a new executor:\npublic \u0026lt;T\u0026gt; void invokeAction(String actionKey, T body){ try { // Create Query Request to the Storage Manager for the Last Digital Twin State QueryRequest queryRequest = new QueryRequest(); queryRequest.setResourceType(QueryResourceType.DIGITAL_TWIN_STATE); queryRequest.setRequestType(QueryRequestType.LAST_VALUE); // Send the Query Request to the Storage Manager for the target DT QueryResult\u0026lt;?\u0026gt; queryResult = this.queryExecutor.syncQueryExecute(queryRequest); // Do Something with the Query Result for(Object result : queryResult.getResults()){ // Check the type of the Resulting class accordingly to the query if(result instanceof DigitalTwinState) logger.info(\u0026#34;LAST DT STATE: {}\u0026#34;, result); else logger.error(\u0026#34;INVALID RESULT TYPE: {}\u0026#34;, result.getClass().getName()); } logger.info(\u0026#34;INVOKING ACTION: {} BODY: {}\u0026#34;, actionKey, body); publishDigitalActionWldtEvent(actionKey, body); } catch (EventBusException e) { e.printStackTrace(); } } Migration Info: 0.3.0 - 0.4.0 Now PhysicalAssetRelationship constructor has also the type in order to match the DigitalTwinStateRelationship and simplify its management The method notifyDigitalTwinStateEvent throws only the Exception WldtDigitalTwinStateEventNotificationException while EventBusException has been removed Additional Improvements \u0026amp; Fixed Bugs Synchronized the update of the current DT Life Cycle State in order to avoid wrong data The WldtEventBus now supports the use of topics Wildcard (at the moment only multi-level with the character *). For example with this approach is possible to subscribe to all the events associated to property variations (topic: dt.physical.event.property.*). New methods added to WldtEventBus are: matchWildCardType(String eventType, String filterType): Check if the provided event type match the WildCard Type isWildCardType(String filterEventType): Check if the provided event type is a WildCard Type The class WldtEventTypes has been introduced to contain all the event types in the WLDT Framework and support internal message exchange. Includes types for events associated and adopted by: i) Physical Adapters; ii) Model and Shadowing Function; and iii) Digital Adapters. The EventManager class has been added to centralize and simplify the event management in the WLDT Framework providing a set of static methods to publish events associated to a target digital twin and publisher (e.g., the physical adapter of the twin). Now PhysicalAssetRelationship class has also the type in order to match the DigitalTwinStateRelationship and simplify its management The internal class ModelEngine has been renamed into DigitalTwinModel as an initial update for further development of the next version 0.5.0 where the structure of the DT\u0026rsquo;s Model and the associated classes will be improved ","date":"August 29, 2024","id":25,"permalink":"/docs/change-logs/change-log-0.4.0/","summary":"New Features WldtEventObserver A new class called WldtEventObserver has been introduced to allow a simplified observation of target specific events generated by the Digital Twin and its components such as adapters and the model.","tags":"","title":"Change Log 0.4.0"},{"content":"The WLDT framework intends to maximize modularity, re-usability and flexibility in order to effectively mirror physical smart objects in their digital counterparts. The proposed library focuses on the simplification of twins design and development aiming to provide a set of core features and functionalities for the widespread adoption of Internet of Things DTs applications.\nA WLDT instance is a general purpose software entity implementing all the features and functionalities of a Digital Twin running in cloud or on the edge. It has the peculiar characteristic to be generic and ``attachable\u0026rsquo;\u0026rsquo; to any physical thing in order to impersonate and maintain its digital replica and extend the provided functionalities for example through the support of additional protocols or a specific translation or normalization for data and formats.\nHereafter, the requirements that led the design and development of the WLDT framework are:\ni) Simplicity - with WLDT developers must have the possibility to easily create a new instance by using existing modules or customizing the behavior according the need of their application scenario; ii) Extensibility - while WLDT must be as simple and light as possible, the API should be also easily extendible in order to let programmers to personalize the configuration and/or to add new features loading and executing multiple modules at the same times; iii) Portability \u0026amp; Micorservice Readiness - a digital twin implemented through WLDT must be able to run on any platform without changes and customization. Our goal is to have a simple and light core engine with a strategic set of IoT-oriented features allowing the developer to easily create DT applications modeled as independent software agents and packed as microservices. In the following Figure, the main components that make up the architecture of WLDT are represented, and thus through which the individual Digital Twin is implemented. Specifically, from the image it is possible to identify the three levels on which the architecture is developed: the one related to the core of the library, the one that models the DT, and finally, that of the adapters.\nEach of this core components has the following main characteristics:\nMetrics Manager: Provides the functionalities for managing and tracking various metrics within DT instances combining both internal and custom metrics through a flexible and extensible approach. Logger: Is designed to facilitate efficient and customizable logging within implemented and deployed DTs with configurable log levels and versatile output options. Utils \u0026amp; Commons: Hold a collection of utility classes and common functionalities that can be readily employed across DT implementations ranging from handling common data structures to providing helpful tools for string manipulation. Event Communication Bus: Represents the internal Event Bus, designed to support communication between the different components of the DT\u0026rsquo;s instance. It allows defining customized events to model both physical and digital input and outputs. Each WLDT\u0026rsquo;s component can publish on the shared Event Bus and define an Event Filter to specify which types of events it is interested in managing, associating a specific callback to each one to process the different messages. Digital Twin Engine: Defines the multi-thread engine of the library allowing the execution and monitoring of multiple DTs (and their core components) simultaneously. Therefore, it is also responsible for orchestrating the different internal modules of the architecture while keeping track of each one, and it can be considered the core of the platform itself allowing the execution and control of the deployed DTs. Currently, it supports the execution of twins on the same Java process, however the same engine abstraction might be used to extend the framework to support distributed execution for example through different processes or microservices. Digital Twin: Models a modular DT structure built through the combination of core functionalities together with physical and digital adapter capabilities. This Layer includes the Digital Twin State responsible to structure the state of the DT by defining the list of properties, events, and actions. The different instances included in the lists can correspond directly to elements of the physical asset or can derive from their combination, in any case, it is the Shadowing Function (SF) that defines the mapping, following the model defined by the designer. This component also exposes a set of methods to allow SF manipulation. Every time the Digital Twin State is modified, the latter generates the corresponding DT\u0026rsquo;s event to notify all the components about the variation. Shadowing Function: It is the library component responsible for defining the behavior of the Digital Twin by interacting with the Digital Twin State. Specifically, it implements the shadowing process that allows keeping the DT synchronized with its physical entity. This component is based on a specific implementation of a WLDT Worker called Model Engine, in order to be executed by the WLDT Engine. The Shadowing Model Function is the fundamental component that must be extended by the DT designer to concretize its model. The shadowing function observes the life cycle of the Digital Twin to be notified of the different state changes. For example, it is informed when the DT enters the Bound state, i.e. when its Physical Adapters have completed the binding procedure with the physical asset. This component also allows the designer to define the behavior of the DT in case a property is modified, an event is triggered, or an action is invoked. Physical Adapter: It defines the essential functionalities that the individual extensions, related to specific protocols, must implement. As provided by the DT definition, a DT can be equipped with multiple Physical Adapters in order to manage communication with the corresponding physical entity. Each will produce a Physical Asset Description (PAD), i.e., a description of the properties, events, actions, and relationships that the physical asset exposes through the specific protocol. The DT transitions from the Unbound to the Bound state when all its Physical Adapters have produced their respective PADs. The Shadowing Function, following the DT model, selects the components of the various PADs that it is interested in managing. Digital Adapter: It provides the set of callbacks that each specific implementation can use to be notified of changes in the DT state. Symmetrically to what happens with Physical Adapters, a Digital Twin can define multiple Digital Adapters to expose its state and functionality through different protocols. Storage Layer: The storage layer has been integrated into the core library with the aim to enable a manual or automatic storage of data related to the evolution of Digital Twins state, the associated generated and processed events, and any variations involving properties, events, actions, relationships, and life cycle. Therefore, to create a Digital Twin using WLDT, it is necessary to define and instantiate a DT with its Shadowing Function and at least one Physical Adapter and one Digital Adapter, in order to enable connection with the physical entity and allow the DT to be used by external applications. Once the 3 components are defined, it is possible to instantiate the WLDT Engine and, subsequently, start the lifecycle of the DT. In the following sections we will go through the fundamental steps to start working with the library and creating all the basic modules to design, develop and execute our first Java Digital Twin.\n","date":"February 9, 2024","id":26,"permalink":"/docs/introduction/library-structure-basic-concepts/","summary":"The WLDT framework intends to maximize modularity, re-usability and flexibility in order to effectively mirror physical smart objects in their digital counterparts.","tags":"","title":"Library Structure \u0026 Basic Concepts"},{"content":" With respect to the element present in the real world, it is defined as a Physical Asset (PA) with the intention of referring to any entity that has a manifestation or relevance in the physical world and a well-defined lifespan.\nThe previous Figure schematically illustrates the main component of an abstract Digital Twin and clarifies its responsibility to be a bridge between the cyber and the physical world. The blueprint components (then mapped into the WLDT Library) are:\nPhysical Interface The entity in charge of both the initial digitalization o shadowing process and the perpetual responsibility to keep the DT and PA in synch during its life cycle. It can execute multiple Physical Asset Adapters to interact with the PA and detect and digitalize the physical event coming from the physical entity according to its nature and the supported protocols and data formats (e.g., through HTTP and JSON). Digital Interface The component complementary to the Physical Interface and in charge of handling DT\u0026rsquo;s internal variations and events towards external digital entities and consumers. It executes multiple and reusable Digital Adapters in charge of handling digital interactions and events and responsible for making the DT interoperable with external applications. DT\u0026rsquo;s Model The module defining the DT\u0026rsquo;s behaviour and its augmented functionalities. It supports the execution of different configurable and reusable modules and functionalities handling both physical and digial events according to the implemented behaviour. Furthermore, the Model is the component responsible to handle and keep updated the Digital Twin State as described in the following sections. The Digital Twin Model(M) allows capturing and representing the PA at an appropriate level of abstraction, i.e., avoiding irrelevant aspects for its purpose and modeling only domain-level information rather than technological ones. Finally, the link between the physical and digital copy is defined as shadowing. Specifically, the term defines the process that enables continuous and (almost) real-time updating of the internal state of the DT in relation to changes that occur in the PA.\nEach DT is thus equipped with an internal model, which defines how the PA is represented in the digital level. The DT\u0026rsquo;s representation denoted as Digital Twin State supported and defined through M is defined in terms of:\nProperties: represent the observable attributes of the corresponding PA as labeled data whose values can dynamically change over time, in accordance with the evolution of the PA\u0026rsquo;s state. Events: represent the domain-level events that can be observed in the PA. Relationships: represent the links that exist between the modeled PA and other physical assets of the organizations through links to their corresponding Digital Twins. Like properties, relationships can be observed, dynamically created, and change over time, but unlike properties, they are not properly part of the PA\u0026rsquo;s state but of its operational context (e.g., a DT of a robot within a production line). Actions: represent the actions that can be invoked on the PA through interaction with the DT or directly on the DT if they are not directly available on the PA (the DT is augmenting the physical capabilities). Once the model M is defined, the dynamic state of the DT (SDT) can be defined by through the combination of its properties, events, relationships and actions associated to the DT timestamp that represents the current time of synchronization between the physical and digital counterparts.\nThe Shadowing Process The shadowing process (also known as replication of digitalization) allows to keep the Digital Twin State synchronized with that of the corresponding physical resource according to what is defined by the model M. Specifically, each relevant update of the PA state (SPA) is translated into a sequence of 3 main steps:\neach relevant change in physical asset state is modeled by a physical_event (e_pa); the event is propagated to the DT; given the new physical_event, the DT\u0026rsquo;s is updated through the application of a shadowing function, which depends on the model M The shadowing process allows also the DT to reflect and invoke possible actions of the PA. The DT receives an action request (denoted as digital_action) on its digital interface, applies the shadowing function to validate it and then propagates the request through its physical interface. An important aspect to emphasize is that the request for a digital_action does not directly change the state of the DT since any changes can only occur as a result of the shadowing function from the PA to the DT, as described earlier.\n","date":"February 9, 2024","id":27,"permalink":"/docs/introduction/dt-model/","summary":"With respect to the element present in the real world, it is defined as a Physical Asset (PA) with the intention of referring to any entity that has a manifestation or relevance in the physical world and a well-defined lifespan.","tags":"","title":"DT Model"},{"content":"\rThe modeling of the concept of DT includes also the definition and characterization of its life cycle. Based on the scientific literature, we model (and then map into the library) a life cycle with 5 states through which the DT goes from when it is executed to when it is stopped. The previous Figure shows a graphical representation of the life cycle with the following steps:\nOperating \u0026amp; Not Bound: this is the state in which the DT is located following the initialization phase, indicating that all internal modules of the DT are active but there is no association yet with the corresponding PA. Bound: this is the state in which the DT transitions following the correct execution of the binding procedure. The binding procedure allows to connect the two parts and enables bidirectional flow of events. Shadowed: this is the state reached by the DT when the shadowing process begins and its state is correctly synchronized with that of the PA. Out of Sync: this is the state that determines the presence of errors in the shadowing process. When in this state, the DT is not able to handle either state alignment events or those generated by the application layer. Done: this is the state that the DT reaches when the shadowing process is stopped, but the DT continues to be active to handle requests coming from external applications. From Unbound to Bound Taking into account the target reference Life Cycle the first point to address is how we can move from an UnBound state to a Bound condition with respect to the relationship with the Physical Layer.\nThe previous Figure illustrates a simple scenario where a Physical Asset uses two protocols (P1 and P2) to communicate and it is connected to the Digital Twin through a DT\u0026rsquo;s Physical Interface enabled with two dedicated Adapters for protocol P1 and P2. In order to move from the Unbound to Bound state the DT should be aware of the description of the target asset with respect to the two protocols. For example through P1 the asset exposes telemetry data (e.g., light bulb status and energy consumption) while on P2 allows incoming action requests (e.g., turn on/off the light). The Digital Twin can start the shadowing process only when it is bound and has a description of the properties and capabilities of the associated physical counterpart. The schematic procedure is illustrated in the following Figure:\nInvolved steps are:\nThe Adapter P1 communicates with the PA through Protocol 1 and provides a Physical Asset Description from its perspective The Adapter P2 communicates with the PA through Protocol 2 and provides a Physical Asset Description from its perspective Only when all Physical Adapters have been correctly bound (it may require time) to the Physical Asset and the associated Physical Asset Descriptions have been generated, the DT can move from UnBound to Bound Main core aspects associated to the concept of Physical Asset Description (PAD) are the following:\nIt is used to describe the list of properties, actions and relationships of a Physical Asset Each Physical Adapter generates a dedicated PAD associated to its perspective on the Physical Assets and its capabilities to read data and execute actions It is a responsibility of the DT to handle multiple descriptions in order to build the digital replica It will be used by the DT to handle the shadowing process and keep the digital replica synchronized with the physical counterpart From Bound to Shadowed Following the same approach described in the previous step we need to define a procedure to allow the DT to move from a Bound state to a Shadowed condition where the twin identified the interesting capabilities of the Physical Asset that has to be digitalized and according to the received Physical Asset Descriptions start the shadowing procedure to be synchronized with the physical world.\nAs schematically illustrated in the previous Figure, involved steps are:\nThe Model defines which properties should be monitored on the Physical Asset and start observing them through the target adapters Involved Physical Adapters communicate with the Physical Asset, receive data and generate Events (ePA) to notify about physical property changes Received ePA will be used by the Digital Twin Model in order to run the Shadowing function and compute the new DT State The DT can move from the Bound to Shadowed phase until it is able to maintain a proper synchronization with the physical asset over time through its shadowing process and the generation and maintenance of the DT\u0026rsquo;s State The Digital Twin State is structured and characterized by the following elements:\nA list of properties A list of actions A list of relationships Listed elements can be directly associated to the corresponding element of the Physical Asset or generated by DT Model combining multiple physical properties, actions or relationships at the same time. The Digital Twin State can be managed through the Shadowing Function and exposes a set of methods for its manipulated. When there is a change in the DT State an event (eDT) will be generated\nThe manipulation of DT\u0026rsquo;s State generates a set of DT\u0026rsquo;s events (eDT) associated to each specific variation and evolution of the twin during its life cyle. These events are used by the Digital Interface and in particular by its Digital Adapters to expose the DT\u0026rsquo;s State, its properties and capabilities to the external digital world. At the same time, eDT can be used by Digital Adapters to trigger action on the DT and consequently to propagate (if acceptable and/or needed) the incoming request to the physical assets bound with the target DT. Supported events are illustrated in the following schema.\n","date":"February 9, 2024","id":28,"permalink":"/docs/introduction/dt-life-cycle/","summary":"The modeling of the concept of DT includes also the definition and characterization of its life cycle. Based on the scientific literature, we model (and then map into the library) a life cycle with 5 states through which the DT goes from when it is executed to when it is stopped.","tags":"","title":"DT Life Cycle"},{"content":"The version 0.5.0 of the Digital Twin library introduces significant enhancements focused on Digital Twin Resources and a Management Interface for runtime configuration and management. These new features empower developers to create more dynamic, adaptable, and interactive Digital Twins that can be tailored to specific application needs.\nIn addition, in order to keep the core of the library independent from external dependencies, WLDT introduces a flexible and configurable logging layer. This design allows developers to extend and integrate the logging system according to the specific requirements of their projects, without being tied to any particular logging framework. The logging API interfaces and methods are inspired by popular libraries such as Log4j and Logback, making it easier for developers to integrate WLDT logging with their preferred solutions.\nFurthermore, this release includes various bug fixes, performance improvements, and documentation updates to enhance the overall user experience and reliability of the library.\nðŸ§© Digital Twin Resources \u0026amp; Management Interface New classes have been introduced to enable a flexible, runtime-manageable resource model within each instance of a Digital Twin. These abstractions are designed to support extensibility, configurability, and interoperability across both internal DT logic and external applications.\nâœ¨ Key Features Unified Resource Model: Resources represent configurable parameters or entities that influence DT behavior. Internal and External Access: Resources can be used by DT logic, and accessed or modified externally via a dedicated Management Interface. Runtime Management: Values can be configured at startup and dynamically updated at runtime. ðŸ—ï¸ Design Principles Resources are user-defined and customizable. They are integrated into various parts of the DT (e.g., shadowing functions). DT behavior adapts dynamically based on resource states. âš ï¸ Developer Notice: The core of the Digital Twin library only provides an abstract interface for the Management Interface. It is the responsibility of the developer to implement the actual logic for exposing and interacting with resources through this interface (e.g., via REST, MQTT, gRPC, etc.). This design ensures modularity and flexibility, allowing integration with various protocols and platforms tailored to specific application requirements, without increasing the size or complexity of the core library or introducing strong dependencies on external libraries.\nðŸ“š Example 1: Temperature Threshold Event Triggering A Digital Twin that monitors a physical asset with temperature sensors may need to detect thermal anomalies based on configurable thresholds.\nðŸ› ï¸ Resources Used Resource Name Type Purpose target_value double Maximum allowed temperature before triggering an alert n int Number of consecutive samples required for anomaly detection time_window long Time duration (e.g., in seconds) over which n samples are evaluated ðŸ” Shadowing Function Usage DT receives periodic temperature samples from the physical device. If n samples in the last time_window exceed target_value, a temperature-alert-event is generated. The DT Resource Manager holds and manages these three parameters. External applications can read or update the threshold values at: Startup time: for initialization. Runtime: via the DT Management Interface that the developer can implement supporting for example RESTful or Pub/Sub interaction pattern. ðŸ“š Example 2: Motor Speed Regulation with Safety Limit In a Digital Twin for an industrial motor, speed regulation may depend on a maximum speed constraint that can vary based on maintenance schedules or environmental conditions.\nðŸ› ï¸ Resources Used Resource Name Type Purpose max_speed_rpm int Maximum allowed speed in RPM emergency_stop_delay long Delay before activating safety shutdown after a violation speed_adjust_factor double Modifier applied to current speed under certain conditions ðŸ” Shadowing Function Usage DT continuously mirrors the motorâ€™s operational speed. If max_speed_rpm is exceeded, and speed is not reduced within emergency_stop_delay, the DT issues a safety-shutdown-command. speed_adjust_factor is used during load balancing or environmental compensation. All parameters are exposed via the DTâ€™s Resource Manager and can be tuned in real-time by an operator or maintenance AI. ðŸ§± Resources \u0026amp; Management Interface Main Classes The following classes define the foundation of the Digital Twin resource management framework. They support runtime configuration, monitoring, and control of internal and external components through a consistent and extensible model. These abstractions are designed to support both the internal logic of the Digital Twin and external applications interacting through a Management Interface.\nThe schematic description of the new introduced classes is structured as follows:\nManagedResource: The ManagedResource class represents an abstract, generic resource that can be configured and managed at runtime. Each resource is uniquely identified and carries a type and name. It encapsulates the actual resource object, such as a configuration parameter or operational constraint. This class provides a standard interface for Create, Read, Update, and Delete (CRUD) operations. Additionally, it supports the registration of observers, allowing other components or systems to receive notifications when the resource is modified. Designed to be extended, ManagedResource allows developers to implement specific resource types suited to their application. It can be used directly by the Digital Twin\u0026rsquo;s internal logic or accessed externally via the Management Interface. The developer can internally define sub-resource of the original resource (e.g., a specific key-value mapping in a dictionary) and the access of sub-resources can be handled by the ResourceRequest and the associated ResourceResponse. ResourceManager: The ResourceManager serves as the central registry and orchestrator for all managed resources in a Digital Twin instance. It is responsible for managing the entire resource lifecycle, including creation, lookup, update, and removal. This class provides an API through which both the internal logic of the Digital Twin and external clients (via the Management Interface) can consistently interact with resources. It ensures that resource access is coordinated and properly controlled, supporting integrity and safe concurrent operations. The ResourceManager plays a key role in decoupling the internal components from external systems, simplifying integration and improving maintainability. The ResourceManager has been added to the core DigitalTwin and DigitalTwinModel classes in order to be properly initialized and the make is usable through the DT instance and in particular in the shadowingFunction and it is accessible on a DigitalTwin instance through the method digitalTwin.getResourceManager(). ResourceRequest: The ResourceRequest class encapsulates the details required to perform an operation on a managed resource. It typically includes a target resource identifier, optional sub-resource identifiers (useful for hierarchical or composite resources), and a payload carrying the specific data for the operation. By abstracting the invocation of resource operations from their implementation, this class enables flexible and extensible workflows that support different transport or protocol layers, such as REST or Pub/Sub. The library currently supports requests targeting a specific resource and one level of sub-resources. To handle deeper hierarchies of sub-resources, developers will need to extend the existing library functionalities with custom implementations. ResourceResponse: The ResourceResponse class represents the result of a resource operation. It contains the outcome of the requested action, including any output data and status information. If an error occurred during the operation, relevant error details are also included. This class ensures a consistent way to communicate results, whether the request originates from internal Digital Twin components or external systems. ManagementInterface: The ManagementInterface defines the external API through which runtime resource operations can be performed by remote applications or tools. It exposes methods or endpoints for creating, reading, updating, and deleting resources, as well as querying their current status and subscribing to events. This interface acts as a bridge between the Digital Twinâ€™s internal resource model and external systems, enabling dynamic and secure interaction with configurable parameters and operational data. The core library only defines the abstract contract for this interface. Developers must provide a concrete implementation, which can be based on any desired communication protocol such as REST, MQTT, or gRPC, depending on system requirements. The ManagementInterface can be set on the DT through the method setManagementInterface(managementInterface) on the DigitalTwin instance. These core classes establish a robust and extensible architecture for runtime resource management. They provide a unified model that supports internal orchestration and external integration. By promoting clear separation of concerns, consistency in interactions, and modular design, they make the Digital Twin framework more adaptable, maintainable, and suitable for a wide range of IoT and IIoT applications.\nðŸ”§ Using the Management Interface in Your Digital Twin This section demonstrates how to set up a DigitalTwin with ResourceManager custom ManagedResource(s) and a dedicated testing ManagementInterface to register a resource, and perform read operations using ResourceRequest and ResourceResponse.\n1. Create a Custom Managed Resource Start by creating a Custom ManagedResource called as DictionaryManagedResource to handle DT\u0026rsquo;s configuration as a basic key-value dictionary:\nimport java.util.HashMap; import java.util.Map; public class DictionaryManagedResource extends ManagedResource\u0026lt;Map\u0026lt;String, Object\u0026gt;, Object, Object\u0026gt; { public DictionaryManagedResource(String id, String type, String name, Map\u0026lt;String, Object\u0026gt; dictionary) { super(id, type, name, dictionary); } public DictionaryManagedResource(String id, String type, String name) { super(id, type, name, new HashMap\u0026lt;\u0026gt;()); } @Override protected ResourceResponse\u0026lt;Object\u0026gt; onCreate(ResourceRequest\u0026lt;Object\u0026gt; resourceRequest) { // In this case the creation means adding a new key-value pair to the dictionary // so we have to take the sub-resource ID as the key and the content as the value since // the resource ID is the ID of the dictionary itself. if (resourceRequest == null || resourceRequest.getResourceId() == null || resourceRequest.getContent() == null || resourceRequest.getSubResourceId().isEmpty()) return new ResourceResponse\u0026lt;Object\u0026gt;(400, \u0026#34;Invalid Resource Request!\u0026#34;); String key = resourceRequest.getSubResourceId(); Object value = resourceRequest.getContent(); resource.put(key, value); return new ResourceResponse\u0026lt;Object\u0026gt;(resourceRequest.getResourceId(), key, value, null); } @Override protected ResourceResponse\u0026lt;Object\u0026gt; onRead(ResourceRequest\u0026lt;Object\u0026gt; resourceRequest) { // Validate the resource request if(resourceRequest == null || resourceRequest.getResourceId() == null) return new ResourceResponse\u0026lt;Object\u0026gt;(400, \u0026#34;Invalid Resource Request!\u0026#34;); // Validate resource id to ensure it is not empty and matches the managed resource ID if(resourceRequest.getResourceId().isEmpty() || !resourceRequest.getResourceId().equals(this.getId())) return new ResourceResponse\u0026lt;Object\u0026gt;(400, \u0026#34;Resource ID cannot be empty or does not match the managed resource ID!\u0026#34;); // Check if the request is for a sub-resource associated to a key in the dictionary if (resourceRequest.getSubResourceId() != null \u0026amp;\u0026amp; !resourceRequest.getSubResourceId().isEmpty()) { String subResourceKey = resourceRequest.getSubResourceId(); Object subResourceValue = resource.get(subResourceKey); return new ResourceResponse\u0026lt;Object\u0026gt;(this.getId(), subResourceKey, subResourceValue, null); } // If no sub-resource is specified, return the entire dictionary else { return new ResourceResponse\u0026lt;Object\u0026gt;(this.getId(), resource, null); } } @Override protected ResourceResponse\u0026lt;Object\u0026gt; onUpdate(ResourceRequest\u0026lt;Object\u0026gt; resourceRequest) { // The key is the sub-resource ID and the value is the content of the request. String key = resourceRequest.getSubResourceId(); Object value = resourceRequest.getContent(); resource.put(key, value); return new ResourceResponse\u0026lt;Object\u0026gt;(resourceRequest.getResourceId(), value, null); } @Override protected ResourceResponse\u0026lt;Object\u0026gt; onDelete(ResourceRequest\u0026lt;Object\u0026gt; resourceRequest) { // The key is the sub-resource ID and the value is the content of the request. String key = resourceRequest.getSubResourceId(); Object value = resource.remove(key); return new ResourceResponse\u0026lt;Object\u0026gt;(resourceRequest.getResourceId(), value, null); } } In this case, the resource is represented by a dictionary implemented using a HashMap. The main resource corresponds to the map itself, while sub-resources refer to the individual first-level entries within the map. Each sub-resource can be accessed using a ResourceRequest by specifying the appropriate string key. The library currently supports requests for a specific resource and a single level of sub-resources. To manage deeper hierarchical structures, developers will need to extend the library with custom implementations.\n2. Create and Configure the Digital Twin Create the DigitalTwinEngine and your DigitalTwin. You also need to register physical and digital adapters, and configure your custom DictionaryManagedResource instance previously created.\nâš ï¸ The following code is just an example to make the overall example readable but it should be customized according to your Digital Twin implementation and available physical and digital adapters.\n// Create the Digital Twin Engine DigitalTwinEngine digitalTwinEngine = new DigitalTwinEngine(); // Create the new Digital Twin with our Shadowing Function DigitalTwin digitalTwin = new DigitalTwin(TEST_DIGITAL_TWIN_ID, new DemoShadowingFunction()); // Physical Adapter with Configuration digitalTwin.addPhysicalAdapter( new DemoPhysicalAdapter( \u0026#34;test-physical-adapter\u0026#34;, new DemoPhysicalAdapterConfiguration() )); // Digital Adapter with Configuration digitalTwin.addDigitalAdapter( new DemoDigitalAdapter( \u0026#34;test-digital-adapter\u0026#34;, new DemoDigitalAdapterConfiguration()) ); Now we can initialize our custom ManagedResource called as DictionaryManagedResource to handle DT\u0026rsquo;s configuration as a basic key-value dictionary:\n// Create our test resource as a Map with configuration properties Map\u0026lt;String, Object\u0026gt; configurationProperties = new HashMap\u0026lt;\u0026gt;(); configurationProperties.put(PROPERTY_NAME_1, PROPERTY_VALUE_1); configurationProperties.put(PROPERTY_NAME_2, PROPERTY_VALUE_2); configurationProperties.put(PROPERTY_NAME_3, PROPERTY_VALUE_3); // Create a new Managed Resource to be used by the Digital Twin and managed by the Management Interface DictionaryManagedResource dictionaryManagedResource = new DictionaryManagedResource( RESOURCE_ID, RESOURCE_TYPE, RESOURCE_NAME, configurationProperties); Once we have a resource we can the following methods provided by the ResourceManager:\nvoid addResource(ManagedResource\u0026lt;?, ?, ?\u0026gt; resource): Adds a resource to the manager and notifies observers. void removeResource(ManagedResource\u0026lt;?, ?, ?\u0026gt; resource): Removes a resource by instance and notifies observers. void removeResource(String resourceId): Removes a resource by its ID and notifies observers. void updateResource(ManagedResource\u0026lt;?, ?, ?\u0026gt; resource): Updates an existing resource and notifies observers. void clearResourceList(): Removes all resources and notifies observers. Optional\u0026lt;ManagedResource\u0026lt;?, ?, ?\u0026gt;\u0026gt; getResourceById(String resourceId): Retrieves a resource by its ID. List\u0026lt;ManagedResource\u0026lt;?, ?, ?\u0026gt;\u0026gt; getResourceList(): Returns a list of all managed resources. boolean containsResource(String resourceId): Checks if a resource with the given ID exists To add a new resource to the we can use the following code:\n// Add a Managed Resource to the Digital Twin digitalTwin.getResourceManager().addResource(dictionaryManagedResource); When the resource has been added to the ResourceManager it can be accessed for example from the ShadowingFunctionto be used within the digitalization processes of the Digital Twin:\n// Check if the ResourceManager is initialized and contains the expected resource if (this.resourceManager != null \u0026amp;\u0026amp; this.resourceManager.containsResource(RESOURCE_ID)) { // Retrieve the resource by ID Optional\u0026lt;ManagedResource\u0026lt;?, ?, ?\u0026gt;\u0026gt; optionalResource = this.resourceManager.getResourceById(RESOURCE_ID); // Check if the resource is present and is an instance of DictionaryManagedResource if (optionalResource.isPresent() \u0026amp;\u0026amp; optionalResource.get() instanceof DictionaryManagedResource) { // Cast the resource to DictionaryManagedResource DictionaryManagedResource dictionaryResource = (DictionaryManagedResource) optionalResource.get(); // Access the value of the \u0026#39;test\u0026#39; property in the resource Object testPropertyValue = dictionaryResource.getResource().get(\u0026#34;test\u0026#34;); // Log the retrieved value System.out.println(\u0026#34;ShadowingFunction - Resource Property \u0026#39;test\u0026#39; Value: \u0026#34; + testPropertyValue); } } else logger.error(\u0026#34;ResourceManager is null or empty. Cannot read the Resource {}.\u0026#34;, ManagementInterfaceTester.RESOURCE_ID); At this stage the resource will be available within the DT instance (e.g., in the Shadowing function) but not to external application since no ManagementInterface has been adde to the DT instance.\n3. Create the Management Interface To expose the configurable resource managed by the Digital Twin (DT), we define a custom implementation of the ManagementInterfaceâ€”called DemoManagementInterface. This implementation is designed for demonstration and explanation purposes, and deliberately avoids dependencies on specific networking libraries. Instead, it emulates the behavior of a network interface, allowing developers to test the logic behind ResourceRequest and ResourceResponse.\nIn a real deployment, it is up to the developer to create a concrete implementation of the ManagementInterface, using the preferred communication protocolâ€”such as HTTP for RESTful APIs, or publish/subscribe mechanisms like MQTT.\nThe demo interface will be as following:\nimport it.wldt.exception.WldtManagedResourceException; import it.wldt.exception.WldtManagementInterfaceException; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.util.List; import java.util.Optional; public class DemoManagementInterface extends ManagementInterface { private static final Logger logger = LoggerFactory.getLogger(DemoManagementInterface.class); // Flag to indicate if the management interface has been started private boolean isStarted = false; // Constants for request types public static final String READ_REQUEST = \u0026#34;READ\u0026#34;; public static final String CREATE_REQUEST = \u0026#34;CREATE\u0026#34;; public static final String UPDATE_REQUEST = \u0026#34;UPDATE\u0026#34;; public static final String DELETE_REQUEST = \u0026#34;DELETE\u0026#34;; @Override protected void onStart(List\u0026lt;ManagedResource\u0026lt;?, ?, ?\u0026gt;\u0026gt; resources) { // Set the started flag to true this.isStarted = true; logger.info(\u0026#34;DemoManagementInterface started with {} resources:\u0026#34;, resources.size()); for (ManagedResource\u0026lt;?, ?, ?\u0026gt; resource : resources) { logger.info(\u0026#34;Managed Resource: {}\u0026#34;, resource.getId()); } } @Override protected void onStop() { logger.info(\u0026#34;DemoManagementInterface stopped.\u0026#34;); } @Override protected void onResourceAdded(ManagedResource\u0026lt;?, ?, ?\u0026gt; resource) { logger.info(\u0026#34;Resource added: {}\u0026#34;, resource.getId()); } @Override protected void onResourceUpdated(ManagedResource\u0026lt;?, ?, ?\u0026gt; resource) { logger.info(\u0026#34;Resource updated: {}\u0026#34;, resource.getId()); } @Override protected void onResourceRemoved(ManagedResource\u0026lt;?, ?, ?\u0026gt; resource) { logger.info(\u0026#34;Resource removed: {}\u0026#34;, resource.getId()); } /** * Validates the ResourceRequest and retrieves the associated ManagedResource * form the ResourceManager. * * @param resourceRequest the resource request * @return an Optional containing the ManagedResource if found, or empty if not found * @throws WldtManagementInterfaceException if the management interface is not started or the request is invalid * @throws WldtManagedResourceException if the resource is not found */ private Optional\u0026lt;DictionaryManagedResource\u0026gt; validateAndLoadRequest(ResourceRequest\u0026lt;?\u0026gt; resourceRequest) throws WldtManagementInterfaceException, WldtManagedResourceException { if (!this.isStarted) { logger.error(\u0026#34;DemoManagementInterface is not started. Cannot access resource.\u0026#34;); throw new WldtManagementInterfaceException(\u0026#34;Management interface not started.\u0026#34;); } if (resourceRequest == null || resourceRequest.getResourceId() == null || resourceRequest.getResourceId().isEmpty()) { logger.error(\u0026#34;Error handling Null Request! Received request: {}\u0026#34;, resourceRequest); throw new WldtManagedResourceException(\u0026#34;Invalid resource request.\u0026#34;); } // Get the resource ID from the ResourceRequest String resourceId = resourceRequest.getResourceId(); logger.info(\u0026#34;Accessing resource with ID: {}\u0026#34;, resourceId); // Retrieve the ManagedResource from the ResourceManager using the resource ID Optional\u0026lt;ManagedResource\u0026lt;?, ?, ?\u0026gt;\u0026gt; resourceOpt = this.resourceManager.getResourceById(resourceId); // Check if the ManagedResource is present if(resourceOpt.isPresent()) { // Retrieve the ManagedResource from the Optional ManagedResource\u0026lt;?, ?, ?\u0026gt; retrievedManagedResource = resourceOpt.get(); // Check the instance of ManagedResource to ensure it is compatible with the request if (!(retrievedManagedResource instanceof DictionaryManagedResource)) throw new WldtManagedResourceException(\u0026#34;Loaded resource has a wrong type: \u0026#34; + retrievedManagedResource.getClass().getName()); // Cast and return the ManagedResource to DictionaryManagedResource return Optional.of((DictionaryManagedResource) retrievedManagedResource); } else // Resource not found, return an empty Optional return Optional.empty(); } /** * Emulates an incoming request to the management interface. * This method validates the request, retrieves the ManagedResource, and performs the requested operation (read, create, update, delete). * It returns an Optional containing the ResourceResponse if successful, or an error response if the request fails or the resource is not found. * @param requestType the type of request (READ, CREATE, UPDATE, DELETE) * @param resourceRequest the resource request containing the resource ID and sub-resource ID * @return an Optional containing the ResourceResponse if successful, or an error response if the request fails or the resource is not found */ public Optional\u0026lt;ResourceResponse\u0026lt;?\u0026gt;\u0026gt; emulateIncomingRequest(String requestType, ResourceRequest\u0026lt;?\u0026gt; resourceRequest) { try{ // Validate the ResourceRequest and retrieve the ManagedResource Optional\u0026lt;DictionaryManagedResource\u0026gt; optionalManagedResource = validateAndLoadRequest(resourceRequest); // Check if the ManagedResource is present if(optionalManagedResource.isPresent()) { // Cast the ManagedResource to DictionaryManagedResource DictionaryManagedResource managedResource = optionalManagedResource.get(); // Prepare the request ResourceRequest\u0026lt;Object\u0026gt; newRequest = new ResourceRequest\u0026lt;\u0026gt;( resourceRequest.getResourceId(), resourceRequest.getSubResourceId(), resourceRequest.getContent(), resourceRequest.getMetadata()); if(requestType.equals(READ_REQUEST)) // Read the resource using the ManagedResource\u0026#39;s read method and return the response return Optional.ofNullable(managedResource.read(newRequest)); else if(requestType.equals(CREATE_REQUEST)) // Create the resource using the ManagedResource\u0026#39;s create method and return the response return Optional.ofNullable(managedResource.create(newRequest)); // Assuming getData() returns the resource data else if(requestType.equals(UPDATE_REQUEST)) // Update the resource using the ManagedResource\u0026#39;s update method and return the response return Optional.ofNullable(managedResource.update(newRequest)); else if(requestType.equals(DELETE_REQUEST)) // Delete the resource using the ManagedResource\u0026#39;s delete method and return the response return Optional.ofNullable(managedResource.delete(newRequest)); else { logger.error(\u0026#34;Unknown request type: {}\u0026#34;, requestType); return Optional.of(new ResourceResponse\u0026lt;\u0026gt;(400, \u0026#34;Unknown request type: \u0026#34; + requestType)); } } else { // Resource not found, return a 404 response return Optional.of(new ResourceResponse\u0026lt;\u0026gt;(404, \u0026#34;Resource not found with ID: \u0026#34; + resourceRequest.getResourceId())); } }catch (Exception e){ e.printStackTrace(); logger.error(\u0026#34;Error reading resource: {}\u0026#34;, e.getMessage()); return Optional.of(new ResourceResponse\u0026lt;\u0026gt;(400, \u0026#34;Error Managing the Resource Request: \u0026#34; + e.getMessage())); } } } At this point, only the read resource method has been implemented. However, we can define and add additional methods to the interface later. In the meantime, we can integrate the interface into the Digital Twin and test its core functionalities.\n3. Setup the Management Interface Now that weâ€™ve defined and implemented our ManagementInterfaceâ€”named DemoManagementInterfaceâ€”we can initialize it, attach it to the Digital Twin, and then start the Twin within the Digital Twin Engine.\nInitialize and attach the DemoManagementInterface:\n// Create a new Management Interface managementInterface = new DemoManagementInterface(); // Add the Management Interface to the Digital Twin digitalTwin.setManagementInterface(managementInterface); Register the Digital Twin with the engine and start it:\n// Add the Twin to the Engine digitalTwinEngine.addDigitalTwin(digitalTwin); // Start the Digital Twin digitalTwinEngine.startDigitalTwin(TEST_DIGITAL_TWIN_ID); 4. Resource Request \u0026amp; Response Now we can test the DemoManagementInterface that we have created to read a target resource (the DictionaryManagedResource instance) managed by the DT creating a ResourceRequest and accessing the ResourceResponse.\nThe ResourceRequest\u0026lt;T\u0026gt; class is a generic container used to encapsulate all the information needed to perform an operation on a managed resource within the Digital Twin framework. It is designed to be flexible and extensible, supporting a wide range of resource types and operations.\nKey Features:\nGeneric Content: The content field can hold any type of object relevant to the resource operation, making the request adaptable to different use cases. Resource Identification: The resourceId and optional subResourceId fields uniquely identify the target resource and, if needed, a sub-resource. Metadata Support: The metadata map allows attaching additional contextual information to the request, such as operation parameters or user data. On the other hand, the ResourceResponse\u0026lt;T\u0026gt; class is a generic container used to encapsulate the result of an operation performed on a managed resource in the Digital Twin framework. It standardizes how responses, including both successful results and errors, are communicated back to callers.\nKey Features:\nGeneric Content: The resource field can hold any type of object representing the result of the operation. Resource Identification: The resourceId and optional subResourceId fields identify the resource and sub-resource related to the response. Metadata Support: The metadata map allows attaching additional contextual information to the response. Error Handling: The isError, errorCode, and errorMessage fields provide a uniform way to report errors. Now we try the interaction with the defined DemoManagementInterface to access a target resource:\n// Create the Resource Request to read the Resource from the Interface ResourceRequest\u0026lt;String\u0026gt; resourceRequest = new ResourceRequest\u0026lt;\u0026gt;(RESOURCE_ID); // Test reading a resource from the Management Interface Optional\u0026lt;ResourceResponse\u0026lt;?\u0026gt;\u0026gt; resourceResponse = managementInterface.emulateReadResource(resourceRequest); // Check if the Resource Response is present if (resourceResponse.isPresent()) { ResourceResponse\u0026lt;?\u0026gt; response = resourceResponse.get(); logger.info(\u0026#34;Resource Response: {}\u0026#34;, response); logger.info(\u0026#34;Resource Content: {}\u0026#34;, response.getResource()); } else { logger.error(\u0026#34;Resource Response is not present\u0026#34;); } To access the value of an individual sub-resource within a DictionaryManagedResource, you can use the same ResourceRequest type, including an additional parameter that specifies the sub-resource\u0026rsquo;s ID.\n// Create the Resource Request to read the Resource from the Interface ResourceRequest\u0026lt;String\u0026gt; resourceRequest = new ResourceRequest\u0026lt;\u0026gt;(RESOURCE_ID, PROPERTY_NAME_1); // Test reading a resource from the Management Interface Optional\u0026lt;ResourceResponse\u0026lt;?\u0026gt;\u0026gt; resourceResponse = managementInterface.emulateReadResource(resourceRequest); // Check if the Resource Response is present if (resourceResponse.isPresent()) { ResourceResponse\u0026lt;?\u0026gt; response = resourceResponse.get(); logger.info(\u0026#34;Resource Response: {}\u0026#34;, response); logger.info(\u0026#34;Sub-Resource Content: {}\u0026#34;, response.getResource()); } else { logger.error(\u0026#34;Resource Response is not present\u0026#34;); } Considering the target demo resource DictionaryManagedResource we can also add the DemoManagementInterface to create a new resource. In this case since it is a resource mapping a Dictionary the creation will be associated to the creation of a new sub-resource to the dictionary.\nIn this configuration the associated code to emulate the create operation on the DemoManagementInterface is:\n// Create the Resource Request to create a Resource from the Interface // Since the main resource is a Map and we want to create a new property we have to set the sub-resource ID as // the new property name that we want to add or update ResourceRequest\u0026lt;String\u0026gt; resourceRequest = new ResourceRequest\u0026lt;\u0026gt;(RESOURCE_ID, PROPERTY_NAME_4); // Now we set the content of the request to the new value we want to set for the new property resourceRequest.setContent(PROPERTY_VALUE_4); // Test reading a resource from the Management Interface Optional\u0026lt;ResourceResponse\u0026lt;?\u0026gt;\u0026gt; resourceResponseOptional = managementInterface.emulateIncomingRequest(DemoManagementInterface.CREATE_REQUEST, resourceRequest); // Check if the Resource Response is present if (resourceResponseOptional.isPresent()) { ResourceResponse\u0026lt;?\u0026gt; response = resourceResponseOptional.get(); logger.info(\u0026#34;Resource Response: {}\u0026#34;, response); logger.info(\u0026#34;Resource Content: {}\u0026#34;, response.getResource()); } else { logger.error(\u0026#34;Resource Response is not present\u0026#34;); } The same approach can be applied to Update and Delete operations through the DemoManagementInterface. However, it\u0026rsquo;s important to note that these actions only affect the dictionary values (i.e., the sub-resources), not the main resource (the dictionary) itself. This behavior reflects a design choice where the main resource is considered non-deletable via the management interface, representing a resource managed directly by the Digital Twin. Developers can implement alternative behaviors based on their specific requirements.\n4. Resource Manager Observation The ResourceManager supports an observation mechanism that allows external components to be notified about changes in the managed resources. This is achieved through the IResourceManagerObserver interface and the observer management methods in the ResourceManager class.\nThe IResourceManagerObserver interface defines the contract for observers that wish to receive notifications about resource events in the ResourceManager. Implementers of this interface can react to resource additions, removals, updates, and when the resource list is cleared through the following methods:\nonManagerResourceAdded(String resourceId): This method is called when a new resource is added to the management interface. onManagerResourceRemoved(String resourceId): This method is called when a resource is removed from the management interface. onManagerResourceUpdated(String resourceId): This method is called when a resource is updated on the resource manager onManagerResourceListCleared(): This method is called when the resource list is cleared. By implementing this interface, external modules can subscribe to resource lifecycle events and synchronize their state or trigger custom logic accordingly. The ResourceManager class provides methods to manage observers:\naddObserver(IResourceManagerObserver observer): Registers an observer to receive notifications about resource changes. Observers are stored in an internal list and will be notified on relevant events. removeObserver(IResourceManagerObserver observer): Unregisters an observer, stopping further notifications to it. Usage Example:\n// Add an Observer to the Resource Manager digitalTwin.getResourceManager().addObserver(new IResourceManagerObserver() { @Override public void onManagerResourceAdded(String resourceId) { System.out.println(\u0026#34;Resource added: \u0026#34; + resourceId); } @Override public void onManagerResourceRemoved(String resourceId) { System.out.println(\u0026#34;Resource removed: \u0026#34; + resourceId); } @Override public void onManagerResourceUpdated(String resourceId) { System.out.println(\u0026#34;Resource updated: \u0026#34; + resourceId); } @Override public void onManagerResourceListCleared() { System.out.println(\u0026#34;Resource list cleared ...\u0026#34;); } }); Note: This observation mechanism is internal to the Digital Twin and operates at the ResourceManager level, not on individual resource changes. Observations and callbacks for actions originating from the ManagementInterface directly on single ManagedResource are handled separately, as described in the next section.\n5. Single Managed Resource Observation To monitor changes or actions on a specific ManagedResource, you can implement the IResourceObserver interface and use the addObserver() and removeObserver() methods available in the ManagedResource class. This enables you to receive notifications for create, read, update, and delete operations performed on that resource.\nMethod provided by the interface IResourceObserver are:\nvoid onCreate(String resourceId, String subResourceId): Called when a resource or subresource is created. resourceId: The unique identifier of the main resource. subResourceId: The unique identifier of the subresource created under the main resource. Can be null or empty if the event refers to the main resource itself. void onUpdate(String resourceId, String subResourceId): Called when a resource or subresource is updated. resourceId: The unique identifier of the main resource. subResourceId: The unique identifier of the subresource updated. Can be null or empty if the event refers to the main resource itself. void onDelete(String resourceId, String subResourceId): Called when a resource or subresource is deleted. resourceId: The unique identifier of the main resource. subResourceId: The unique identifier of the subresource deleted. Can be null or empty if the event refers to the main resource itself. Note: The resourceId always refers to the main or parent resource while the subResourceId refers to a nested subresource inside the main resource. If the operation targets the main resource directly, subResourceId may be null or an empty string.\nThe example below demonstrates how to register an observer for a target resource and handle callbacks triggered by changes initiated through the ManagementInterface. This mechanism allows Digital Twin developers to react to resource updates and synchronize behavior accordingly.\n// Read the resource from the Resource Manager Optional\u0026lt;ManagedResource\u0026lt;?, ?, ?\u0026gt;\u0026gt; resourceOptional = digitalTwin.getResourceManager().getResourceById(RESOURCE_ID); // Check with instance of if the Resource is of type DictionaryManagedResource if (resourceOptional.isPresent() \u0026amp;\u0026amp; resourceOptional.get() instanceof DictionaryManagedResource) { // Cast the Resource to DictionaryManagedResource DictionaryManagedResource dictionaryManagedResource = (DictionaryManagedResource) resourceOptional.get(); // Add a callback to the Managed Resource dictionaryManagedResource.addObserver(new IResourceObserver() { @Override public void onCreate(String resourceId, String subResourceId) { System.out.println(\u0026#34;Create Callback on Resource: \u0026#34; + resourceId + \u0026#34;, SubResource: \u0026#34; + subResourceId); } @Override public void onUpdate(String resourceId, String subResourceId) { System.out.println(\u0026#34;Update Callback on Resource: \u0026#34; + resourceId + \u0026#34;, SubResource: \u0026#34; + subResourceId); } @Override public void onDelete(String resourceId, String subResourceId) { System.out.println(\u0026#34;Delete Callback on Resource: \u0026#34; + resourceId + \u0026#34;, SubResource: \u0026#34; + subResourceId); } }); } else logger.error(\u0026#34;Resource is not of type DictionaryManagedResource\u0026#34;); ðŸ“ Logging in WLDT In order to keep the core of the library independent from external dependencies, WLDT introduces a flexible and configurable logging layer.\nThis design allows developers to extend and integrate the logging system according to the specific requirements of their projects,\nwithout being tied to any particular logging framework. The logging API interfaces and methods are inspired by popular libraries such as Log4j\nand Logback, making it easier for developers to integrate WLDT logging with their preferred solutions.\nFurthermore, the library provides a default implementation that uses classic Java System.out.* output, ensuring basic logging\nfunctionality is available out-of-the-box for immediate usability. This approach enables both quick adoption and\nadvanced customization as needed.\nThe WLDT logging layer provides a flexible and extensible way to handle logging within your digital twin applications.\nIt\u0026rsquo;s designed to allow developers to easily switch between different logging implementations without modifying core application code.\nThe core components of the WLDT logging layer are:\nWldtLogger: An interface defining the standard logging methods (e.g., info, debug, error). WldtLoggerFactory: An interface for creating WldtLogger instances. WldtLoggerProvider: A utility class that provides a static method to get WldtLogger instances and allows setting a custom WldtLoggerFactory. WldtDefaultLogger: A default implementation of WldtLogger that prints log messages to the console. WldtDefaultLoggerFactory: A default implementation of WldtLoggerFactory that creates WldtDefaultLogger instances. WldtLogger Interface The WldtLogger interface defines a set of methods for logging messages at different levels of severity.\nMethods:\ngetName(): Returns the name of the logger, typically the fully qualified class name. trace(String msg), trace(String format, Object arg), trace(String format, Object arg1, Object arg2), trace(String format, Object... arguments), trace(String msg, Throwable t): Methods for logging trace level messages. These are typically fine-grained informational events that are most useful for debugging an application. isTraceEnabled(): Checks if the trace level is enabled. debug(String msg), debug(String format, Object arg), debug(String format, Object arg1, Object arg2), debug(String format, Object... arguments), debug(String msg, Throwable t): Methods for logging debug level messages. These are typically used for debugging purposes during development. isDebugEnabled(): Checks if the debug level is enabled. info(String msg), info(String format, Object arg), info(String format, Object arg1, Object arg2), info(String format, Object... arguments), info(String msg, Throwable t): Methods for logging info level messages. These provide general information about the application\u0026rsquo;s progress. isInfoEnabled(): Checks if the info level is enabled. warn(String msg), warn(String format, Object arg), warn(String format, Object arg1, Object arg2), warn(String format, Object... arguments), warn(String msg, Throwable t): Methods for logging warn level messages. These indicate potential issues or unexpected events that do not prevent the application from continuing. isWarnEnabled(): Checks if the warn level is enabled. error(String msg), error(String format, Object arg), error(String format, Object arg1, Object arg2), error(String format, Object... arguments), error(String msg, Throwable t): Methods for logging error level messages. These indicate serious problems that prevent the application from functioning correctly. isErrorEnabled(): Checks if the error level is enabled. WldtLoggerFactory Interface The WldtLoggerFactory interface is responsible for creating instances of WldtLogger.\nMethod:\ngetLogger(Class\u0026lt;?\u0026gt; clazz): This method takes a Class\u0026lt;?\u0026gt; object as input and returns a WldtLogger instance associated with that class. This allows logs to be categorized by their source class. WldtLoggerProvider Class The WldtLoggerProvider acts as the entry point for obtaining logger instances.\nKey Features:\nDefault Factory: By default, it uses WldtDefaultLoggerFactory to create WldtDefaultLogger instances. Custom Factory Support: It allows you to set a custom WldtLoggerFactory to integrate with different logging frameworks or implement custom logging behavior. Methods:\npublic static void setFactory(WldtLoggerFactory customFactory): Use this method to replace the default logger factory with your own custom implementation. This should typically be called once at the application\u0026rsquo;s startup. public static WldtLogger getLogger(Class\u0026lt;?\u0026gt; clazz): This static method is used to obtain a logger instance for a specific class. It delegates the logger creation to the currently set WldtLoggerFactory. WldtDefaultLogger Class The WldtDefaultLogger is a basic, console-based implementation of the WldtLogger interface.\nFeatures:\nConsole Output: Logs messages to the standard output (System.out). Timestamping: Each log message is prefixed with a timestamp in the format \u0026ldquo;yyyy-MM-dd HH:mm:ss.SSS\u0026rdquo;. Log Level Indication: Includes the log level (TRACE, DEBUG, INFO, WARN, ERROR) in each message. Class Name: Shows the simple name of the class that requested the logger. WldtDefaultLoggerFactory Class The WldtDefaultLoggerFactory is the default factory implementation that creates WldtDefaultLogger instances.\nMethod:\npublic WldtLogger getLogger(Class\u0026lt;?\u0026gt; clazz): This method simply returns a new WldtDefaultLogger instance, initialized with the provided class. âš™ï¸ How to Create a Custom Logger and Custom Logger Factory The WLDT logging layer is designed to be extensible, allowing developers to integrate their preferred logging frameworks (e.g., Log4j, SLF4j, Logback) or implement entirely custom logging logic.\n1. Create a Custom Logger To create a custom logger, you need to implement the WldtLogger interface. This allows you to define how log messages are handled (e.g., written to a file, sent to a remote server, or integrated with an existing logging framework).\nHere\u0026rsquo;s an example of a MyCustomLogger that could integrate with a third-party logging framework:\npackage it.wldt.log; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class MyCustomLogger implements WldtLogger { private final Logger slf4jLogger; public MyCustomLogger(Class\u0026lt;?\u0026gt; clazz) { this.slf4jLogger = LoggerFactory.getLogger(clazz); } @Override public String getName() { return slf4jLogger.getName(); } @Override public void trace(String msg) { slf4jLogger.trace(msg); } @Override public void trace(String format, Object arg) { slf4jLogger.trace(format, arg); } @Override public void trace(String format, Object arg1, Object arg2) { slf4jLogger.trace(format, arg1, arg2); } @Override public void trace(String format, Object... arguments) { slf4jLogger.trace(format, arguments); } @Override public void trace(String msg, Throwable t) { slf4jLogger.trace(msg, t); } @Override public boolean isTraceEnabled() { return slf4jLogger.isTraceEnabled(); } @Override public void debug(String msg) { slf4jLogger.debug(msg); } @Override public void debug(String format, Object arg) { slf4jLogger.debug(format, arg); } @Override public void debug(String format, Object arg1, Object arg2) { slf4jLogger.debug(format, arg1, arg2); } @Override public void debug(String format, Object... arguments) { slf4jLogger.debug(format, arguments); } @Override public void debug(String msg, Throwable t) { slf4jLogger.debug(msg, t); } @Override public boolean isDebugEnabled() { return slf4jLogger.isDebugEnabled(); } @Override public void info(String msg) { slf4jLogger.info(msg); } @Override public void info(String format, Object arg) { slf4jLogger.info(format, arg); } @Override public void info(String format, Object arg1, Object arg2) { slf4jLogger.info(format, arg1, arg2); } @Override public void info(String format, Object... arguments) { slf4jLogger.info(format, arguments); } @Override public void info(String msg, Throwable t) { slf4jLogger.info(msg, t); } @Override public boolean isInfoEnabled() { return slf4jLogger.isInfoEnabled(); } @Override public void warn(String msg) { slf4jLogger.warn(msg); } @Override public void warn(String format, Object arg) { slf4jLogger.warn(format, arg); } @Override public void warn(String format, Object arg1, Object arg2) { slf4jLogger.warn(format, arg1, arg2); } @Override public void warn(String format, Object... arguments) { slf4jLogger.warn(format, arguments); } @Override public void warn(String msg, Throwable t) { slf4jLogger.warn(msg, t); } @Override public boolean isWarnEnabled() { return slf4jLogger.isWarnEnabled(); } @Override public void error(String msg) { slf4jLogger.error(msg); } @Override public void error(String format, Object arg) { slf4jLogger.error(format, arg); } @Override public void error(String format, Object arg1, Object arg2) { slf4jLogger.error(format, arg1, arg2); } @Override public void error(String format, Object... arguments) { slf4jLogger.error(format, arguments); } @Override public void error(String msg, Throwable t) { slf4jLogger.error(msg, t); } @Override public boolean isErrorEnabled() { return slf4jLogger.isErrorEnabled(); }} 2. Create a Custom Logger Factory Once you have your custom logger, you need a custom logger factory to provide instances of it.\nThis factory will implement the WldtLoggerFactory interface.\nHere\u0026rsquo;s an example of a MyCustomLoggerFactory that produces MyCustomLogger instances:\npackage it.wldt.log; public class MyCustomLoggerFactory implements WldtLoggerFactory { @Override public WldtLogger getLogger(Class\u0026lt;?\u0026gt; clazz) { return new MyCustomLogger(clazz); }} 3. Set the Custom Logger Factory Finally, to use your custom logger and factory, you need to instruct the WldtLoggerProvider to use your MyCustomLoggerFactory.\nThis should be done once at the beginning of your application\u0026rsquo;s lifecycle, before any loggers are requested.\nimport it.wldt.log.WldtLoggerProvider; import it.wldt.log.MyCustomLoggerFactory; // Your custom factory import it.wldt.log.WldtLogger; public class MyApplication { public static void main(String[] args) { // Set the custom logger factory WldtLoggerProvider.setFactory(new MyCustomLoggerFactory()); // Now, any logger obtained will be an instance of MyCustomLogger WldtLogger logger = WldtLoggerProvider.getLogger(MyApplication.class); logger.info(\u0026#34;This message will be logged using MyCustomLogger!\u0026#34;); logger.error(\u0026#34;An error occurred!\u0026#34;, new RuntimeException(\u0026#34;Something went wrong\u0026#34;)); }} By following these steps, you can seamlessly integrate custom logging solutions into your WLDT digital twin applications,\nensuring that your logging infrastructure meets your specific project requirements.\n","date":"January 8, 2026","id":29,"permalink":"/docs/change-logs/change-log-0.5.0/","summary":"The version 0.5.0 of the Digital Twin library introduces significant enhancements focused on Digital Twin Resources and a Management Interface for runtime configuration and management.","tags":"","title":"Change Log 0.5.0"},{"content":"\rThe entire WLDT Library and the associated DTs modeling has been designed as an event-driven system where each component is (almost) fully decoupled from the other and focused on a specific responsibilities. The communication among these independent components (e.g., Physical Adapters, Digital Adapters, Model, Storage, Shadowing Function etc ..) is implemented through an event-driven system and and effective exchange of messages and depicted in the reported Figure.\nIn order to better understand the type and nature of the available events this section provides additional information about the characteristics and responsibility for each category and are of interest in the Digital Twin.\nPhysical Asset Events Those events maps every bidirectional interaction with the Physical Asset (or multiple assets) that the DT is in charge of digitalizing. Involved events are related to:\nPhysical Asset Description: Associated to any variation in the description of the Physical Asset through the structure denoted as PhysicalAssetDescription (PAD) New Physical Asset Description: Maps the availability of a new PAD from a specific target Physical Asset through a Physical Adapter Updated Physical Asset Description: Maps the availability of an updated PAD from a specific target Physical Asset through a Physical Adapter Physical Asset Variation: Associated to any variation of the Physical Asset in terms of Properties, Events and Relationships Instances (previously declared in the PAD) Property Variation: Maps a variation of a Physical Property (e.g., temperature value of 25 Celsius Degrees) Event Notification: Maps an event notification generated by the Physical Asset (e.g., Over-Heating) Relation Instance Variation: Maps a variation of Relationships instance associated to a Relationship type declared in the PAD Physical Asset Action Request: Maps an event coming from the DT\u0026rsquo;s Core for the Physical Asset (managed by the Physical Adapter) to trigger an action in the physical world (e.g., turn on the switch) Digital Twin\u0026rsquo;s Events Those events are on the other end in charge of mapping event generate by the DT itself during its evolution and across its life-cycle. They can be associated to the following aspects:\nLife Cycle Variation: Maps a change in the life cycle\u0026rsquo;s state of the DT for example moving from Bound to Synchronized DT State Variation: Maps a variation in the State of the DT communicating the new State and the list of associated changes DT State Event Notification: Maps an event generated by the DT for example mapping an event notification coming from the Physical Asset (e.g., Over-Heating) or a \u0026ldquo;new\u0026rdquo; notification from the DT (e.g., Anomaly-Detected) Digital Action Request: Maps an action request on an available action exposed by the DT and that is requested by and external application. This Action trigger can be internally managed by the DT or can generate then a trigger for a Physical Action as previously described. ","date":"September 4, 2024","id":30,"permalink":"/docs/introduction/dt-events/","summary":"The entire WLDT Library and the associated DTs modeling has been designed as an event-driven system where each component is (almost) fully decoupled from the other and focused on a specific responsibilities.","tags":"","title":"DT Events"},{"content":"","date":"September 7, 2023","id":31,"permalink":"/docs/","summary":"","tags":"","title":"Docs"},{"content":"Welcome to White Label Digital Twins (WLDT), an open-source project dedicated to supporting the design, development, and deployment of Digital Twins within the Internet of Things (IoT) ecosystems.\nThe WLDT library has been designed to align with the latest DT definitions from both Industrial and Scientific domains. It identifies DTs as active, flexible, and scalable software components. Our library aims to provide developers with the tools and resources necessary to create robust Digital Twins that effectively simulate and monitor physical assets within IoT environments.\nWhether you\u0026rsquo;re working on IoT, Industrial IoT (IIoT) applications, Smart Cities projects, or any other IoT-related endeavor, the WLDT library offers a versatile solution for implementing Digital Twins that accurately represent real-world objects and support informed decision-making processes.\nðŸ’» Team \u0026amp; Mantainers [Founders \u0026amp; Main Contributors] Marco Picone - University of Modena \u0026amp; Reggio Emilia, Italy - (Link) [Key Contributors] Samuele Burattini - University of Bologna, Italy - (Link) [Additional Contributors] Marta Spadoni - University of Bologna, Italy - Master Thesis 2022 Mirco Sandonini - University of Modena \u0026amp; Reggio Emilia, Italy - Bachelor Thesis 2025 (GitHub-Link) ðŸ“œ Scientitic Citation \u0026amp; References If you use the WLDT Library in a Scientific Paper please use this reference:\n@article{PICONE2021100661, title = {WLDT: A general purpose library to build IoT digital twins}, journal = {SoftwareX}, volume = {13}, pages = {100661}, year = {2021}, issn = {2352-7110}, doi = {https://doi.org/10.1016/j.softx.2021.100661}, url = {https://www.sciencedirect.com/science/article/pii/S2352711021000066}, author = {Marco Picone and Marco Mamei and Franco Zambonelli}, keywords = {Internet of Things, Digital twin, Library, Software agent} } ðŸ“¨ Community Join our community and contribute to the advancement of Digital Twin technology with White Label Digital Twins!\nWLDT questions, feedback and discussions are tracked using slack channels in the WLDT Slack Workspace.\nThe workspace is available here: WLDT Slack Workspace\nNew users first need to join the MEC Sandbox slack workspace by creating a new account using the invitation link provided here: Join the WLDT Slack Workspace\nðŸ› Reporting Issues WLDT issues should be reported on Slack, where they can be discussed with the core team that maintains the WLDT Library.\n","date":"March 13, 2024","id":32,"permalink":"/about/","summary":"Welcome to White Label Digital Twins (WLDT), an open-source project dedicated to supporting the design, development, and deployment of Digital Twins within the Internet of Things (IoT) ecosystems.","tags":"","title":"About WLDT Library"},{"content":" What is a digital Twin? A Digital Twin (DT) is a comprehensive software representation of any individual Physical Asset (PA) in the real world.\nIt includes the properties, conditions, relationships, and behavior(s) of the real-life object through models and data.\nA Digital Twin is a set of realistic models that can digitalize an objectâ€™s behavior in the deployed environment and has the responsibility to represent and reflect its physical counterpart over time maintaining its digital replica across the objectâ€™s entire lifecycle.\nWhat can WLDT do for me? The White Label Digital Twin (WLDT) library aims to support the design, development, and deployment of Digital Twins within the Internet of Things (IoT) ecosystems.\nThe library has been designed following the latest DT definitions coming from both Industrial and Scientific domains and identifying DTs as active, flexible and scalable software components.\nScientitic Citation \u0026amp; Reference If you use the WLDT Library in a Scientific Paper refer to the About Page for additional information and scientific references. Thanks :)\n","date":"October 6, 2023","id":33,"permalink":"/","summary":"What is a digital Twin? A Digital Twin (DT) is a comprehensive software representation of any individual Physical Asset (PA) in the real world.","tags":"","title":"White Label Digital Twins"},{"content":"","date":"September 7, 2023","id":34,"permalink":"/privacy/","summary":"","tags":"","title":"Privacy Policy"},{"content":"","date":"January 1, 0001","id":35,"permalink":"/categories/","summary":"","tags":"","title":"Categories"},{"content":"","date":"January 1, 0001","id":36,"permalink":"/contributors/","summary":"","tags":"","title":"Contributors"},{"content":"","date":"January 1, 0001","id":37,"permalink":"/tags/","summary":"","tags":"","title":"Tags"}]